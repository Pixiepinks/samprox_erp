<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Machines | SAMPROX ERP</title>
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/machines.css') }}" />
</head>
<body>
    <div class="page">
        <header class="topbar">
            <div class="brand">
                <div class="brand__logo">S</div>
                <div class="brand__details">
                    <p class="brand__name">SAMPROX ERP</p>
                    <p class="brand__section">Machine Centre</p>
                </div>
            </div>
            <div class="topbar__actions">
                <a class="button button--ghost" href="{{ url_for('ui.mind_page') }}">Mind</a>
                <div class="user-summary">
                    <span class="user-summary__name" id="user-name"></span>
                    <span class="user-summary__role" id="user-role"></span>
                </div>
                <button type="button" class="button button--secondary" id="logout">Sign out</button>
            </div>
        </header>
        <nav class="subnav" aria-label="7M navigation">
            <a class="subnav__link" href="{{ url_for('ui.mind_page') }}">Mind</a>
            <a class="subnav__link" href="{{ url_for('ui.man_page') }}">Man</a>
            <a class="subnav__link subnav__link--active" href="{{ url_for('ui.machines_page') }}">Machine</a>
            <a class="subnav__link" href="{{ url_for('ui.material_page') }}">Material</a>
            <a class="subnav__link" href="{{ url_for('ui.market_page') }}">Market</a>
            <a class="subnav__link" href="{{ url_for('ui.manufacturing_page') }}">Manufacturing</a>
            <a class="subnav__link" href="{{ url_for('ui.money_page') }}">Money</a>
        </nav>
        <main class="machine-layout">
            <div class="machine-panels">
                <section id="maintenance-jobs" class="panel-group">
                    <header class="panel-group__header">
                        <h2>Maintenance jobs</h2>
                        <p>Monitor open jobs and refresh the list as work progresses.</p>
                    </header>
                    <div class="panel-grid panel-grid--single">
                        <section class="panel panel--list">
                            <header class="panel__header">
                                <div>
                                    <h3>Maintenance jobs</h3>
                                    <p class="panel__subtitle">Latest jobs ordered by creation date.</p>
                                </div>
                                <div class="panel__header-actions">
                                    <button type="button" class="button" data-modal-open="maintenance-job-modal" id="open-create-job">Create job</button>
                                    <button type="button" class="button button--ghost" id="refresh-jobs">Refresh</button>
                                </div>
                            </header>
                            <div class="panel__body">
                                <div class="alert alert--error" id="jobs-error" hidden></div>
                                <div class="empty-state" id="jobs-empty" hidden>
                                    <p>No jobs have been created yet.</p>
                                </div>
                                <div class="table-wrapper">
                                    <table class="jobs-table" aria-describedby="jobs-empty">
                                        <thead>
                                            <tr>
                                                <th scope="col" rowspan="2" class="jobs-table__sticky-col jobs-table__sticky-col--first">Code</th>
                                                <th scope="col" rowspan="2" class="jobs-table__sticky-col">Job category</th>
                                                <th scope="col" rowspan="2">Status</th>
                                                <th scope="col" rowspan="2">Priority</th>
                                                <th scope="col" rowspan="2">Assigned</th>
                                                <th scope="col" rowspan="2">Asset name</th>
                                                <th scope="col" rowspan="2">Part name (CKD)</th>
                                                <th scope="col" colspan="4" class="jobs-table__group">Dates</th>
                                                <th scope="col" colspan="4" class="jobs-table__group">Costs</th>
                                                <th scope="col" rowspan="2">More</th>
                                                <th scope="col" rowspan="2">Update status</th>
                                            </tr>
                                            <tr>
                                                <th scope="col">Job Date</th>
                                                <th scope="col">Expected completion</th>
                                                <th scope="col">Job started date</th>
                                                <th scope="col">Job finished date</th>
                                                <th scope="col">Materials used (Cost)</th>
                                                <th scope="col">Outsourced party cost</th>
                                                <th scope="col">Internal staff cost</th>
                                                <th scope="col">Total cost</th>
                                            </tr>
                                        </thead>
                                        <tbody id="jobs-table-body"></tbody>
                                    </table>
                                </div>
                            </div>
                        </section>
                    </div>
                </section>
                <section id="machine-inputs" class="panel-group">
                    <header class="panel-group__header">
                        <h2>Inputs</h2>
                        <p>Capture the latest machine information for your records.</p>
                    </header>
                    <div class="panel-grid">
                        <section class="panel panel--menu">
                            <header class="panel__header">
                                <div>
                                    <h3>Input actions</h3>
                                    <p class="panel__subtitle">Choose an action to open it in a popup without leaving the page.</p>
                                </div>
                            </header>
                            <div class="panel__body">
                                <nav class="input-menu" data-input-menu>
                                    <button type="button" class="input-menu__toggle" data-menu-toggle aria-expanded="false">
                                        <span>Inputs</span>
                                        <span class="input-menu__chevron" aria-hidden="true"></span>
                                    </button>
                                    <ul class="input-menu__list" data-menu-list>
                                        <li class="input-menu__item">
                                            <button type="button" class="input-menu__link" data-modal-open="asset-modal">Add new asset</button>
                                        </li>
                                        <li class="input-menu__item">
                                            <button type="button" class="input-menu__link" data-modal-open="ckd-modal">Add CKD part to machine</button>
                                        </li>
                                        <li class="input-menu__item">
                                            <button type="button" class="input-menu__link" data-modal-open="maintenance-job-modal">Request maintenance job</button>
                                        </li>
                                    </ul>
                                </nav>
                            </div>
                        </section>
                    </div>
                </section>
                <section id="machine-outputs" class="panel-group">
                    <header class="panel-group__header">
                        <h2>Outputs</h2>
                        <p>Review the current state of the machine fleet and its parts.</p>
                    </header>
                    <div class="panel-grid">
                        <section class="panel panel--list">
                            <header class="panel__header">
                                <div>
                                    <h3>Assets register</h3>
                                    <p class="panel__subtitle">All assets with quick access to CKD part lists.</p>
                                </div>
                                <div class="panel__header-actions">
                                    <button type="button" class="button button--ghost" id="refresh-assets">Refresh</button>
                                </div>
                            </header>
                            <div class="panel__body">
                                <div class="alert alert--error" id="asset-error" hidden></div>
                                <div class="empty-state" id="assets-empty" hidden>
                                    <p>No assets have been registered yet.</p>
                                </div>
                                <div class="table-wrapper">
                                    <table class="data-table" aria-describedby="assets-empty">
                                        <thead>
                                            <tr>
                                                <th scope="col">Code</th>
                                                <th scope="col">Name</th>
                                                <th scope="col">Location</th>
                                                <th scope="col">Status</th>
                                                <th scope="col">Parts</th>
                                                <th scope="col">Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody id="assets-table-body"></tbody>
                                    </table>
                                </div>
                            </div>
                        </section>
                    </div>
                </section>
                <section class="panel panel--detail" id="asset-detail" hidden>
                    <header class="panel__header">
                        <div>
                            <h2 id="asset-detail-title"></h2>
                            <p class="panel__subtitle" id="asset-detail-meta"></p>
                        </div>
                        <button type="button" class="button button--ghost" id="close-asset-detail">Close</button>
                    </header>
                    <div class="panel__body asset-detail__body">
                        <div class="asset-detail__column">
                            <h3>Asset information</h3>
                            <dl class="asset-detail__facts" id="asset-detail-facts"></dl>
                        </div>
                        <div class="asset-detail__column asset-detail__column--wide">
                            <section class="asset-parts">
                                <header class="asset-parts__header">
                                    <h3>Complete knock down (CKD) parts</h3>
                                    <div class="asset-parts__search">
                                        <label class="visually-hidden" for="asset-part-search">Search CKD parts</label>
                                        <input
                                            id="asset-part-search"
                                            class="asset-parts__search-input"
                                            type="search"
                                            name="asset-part-search"
                                            placeholder="Search parts"
                                            autocomplete="off"
                                            spellcheck="false"
                                        />
                                    </div>
                                </header>
                                <div class="alert alert--error" id="asset-part-error" hidden></div>
                                <div class="alert alert--success" id="asset-part-success" hidden>Part added successfully.</div>
                                <form class="form asset-part-form" id="asset-part-form" novalidate>
                                    <div class="form-grid">
                                        <div class="input-group">
                                            <label for="part-name">Part name <span class="required">*</span></label>
                                            <input id="part-name" name="name" type="text" placeholder="Hydraulic pump" required />
                                        </div>
                                        <div class="input-group">
                                            <label for="part-number">Part number <span class="required">*</span></label>
                                            <input id="part-number" name="part_number" type="text" placeholder="P-009" required readonly />
                                        </div>
                                        <div class="input-group">
                                            <label for="part-life">Expected life (hrs)</label>
                                            <input id="part-life" name="expected_life_hours" type="number" min="0" step="1" />
                                        </div>
                                    </div>
                                    <div class="input-group">
                                        <label for="part-description">Description</label>
                                        <textarea id="part-description" name="description" rows="2" placeholder="Reference or specification"></textarea>
                                    </div>
                                    <div class="input-group">
                                        <label for="part-notes">Notes</label>
                                        <textarea id="part-notes" name="notes" rows="2" placeholder="Storage, supplier, etc."></textarea>
                                    </div>
                                    <div class="form__footer">
                                        <button type="submit" class="button">Add part</button>
                                    </div>
                                </form>
                                <div class="asset-parts__list" id="asset-parts-list"></div>
                                <div class="empty-state" id="asset-parts-empty" hidden>
                                    <p>No parts have been registered for this asset yet.</p>
                                </div>
                            </section>
                        </div>
                    </div>
                </section>
                <section id="idle-section" class="panel-group">
                    <header class="panel-group__header">
                        <h2>Idle time monitoring</h2>
                        <p>Capture downtime windows and review utilisation insights.</p>
                    </header>
                    <section class="idle-hero">
                        <div class="idle-hero__content">
                            <p class="idle-hero__eyebrow">Intelligent downtime radar</p>
                            <h2>Daily machine utilisation pulse</h2>
                            <p>Capture hour meter readings, quantify idle time instantly and surface the reason behind every lull.</p>
                        </div>
                        <div class="idle-hero__controls">
                            <label for="idle-date">Analysis date</label>
                            <input id="idle-date" type="date" name="analysis_date" />
                        </div>
                        <div class="idle-hero__stats">
                            <div class="idle-stat">
                                <span class="idle-stat__label">Total runtime</span>
                                <span class="idle-stat__value" data-total-runtime>0 h</span>
                                <span class="idle-stat__hint">Including overtime</span>
                            </div>
                            <div class="idle-stat">
                                <span class="idle-stat__label">Idle within shift</span>
                                <span class="idle-stat__value" data-total-idle>0 h</span>
                                <span class="idle-stat__hint">07:00 &ndash; 19:00 window</span>
                            </div>
                            <div class="idle-stat">
                                <span class="idle-stat__label">Captured overtime</span>
                                <span class="idle-stat__value" data-total-extended>0 h</span>
                                <span class="idle-stat__hint">Beyond 19:00</span>
                            </div>
                        </div>
                        <div class="idle-hero__chart">
                            <div class="idle-hero__chart-card">
                                <div class="idle-chart-wrapper">
                                    <div
                                        id="idle-pulse-grid"
                                        class="idle-pulse"
                                        role="grid"
                                        aria-label="Daily machine utilisation pulse"
                                    ></div>
                                </div>
                                <p class="idle-chart__legend-hint">
                                    Each square represents one hour between 07:00 and 19:00. Green marks productive runtime,
                                    red highlights idle periods and mixed squares indicate split hours.
                                </p>
                            </div>
                        </div>
                    </section>
                    <div class="panel-grid idle-grid">
                        <section class="panel idle-panel idle-panel--form">
                            <header class="panel__header">
                                <div>
                                    <h2>Log downtime window</h2>
                                    <p class="panel__subtitle">Capture when the machine stopped, why it happened and any recovery notes.</p>
                                </div>
                            </header>
                            <div class="panel__body">
                                <div class="alert alert--info" id="idle-entry-notice" hidden></div>
                                <div class="alert alert--success" id="idle-entry-success" hidden></div>
                                <div class="alert alert--error" id="idle-entry-error" hidden></div>
                                <form class="form idle-form" id="idle-entry-form" novalidate>
                                    <div class="idle-form__grid">
                                        <div class="input-group">
                                            <label for="idle-machine">Machine <span class="required">*</span></label>
                                            <select id="idle-machine" name="machine" required>
                                                <option value="MCH-0001">MCH-0001 — Cutting Cell</option>
                                                <option value="MCH-0002">MCH-0002 — Precision Lathe</option>
                                                <option value="MCH-0003">MCH-0003 — Finishing Line</option>
                                            </select>
                                        </div>
                                        <div class="input-group">
                                            <label for="idle-start-time">Idle started <span class="required">*</span></label>
                                            <input id="idle-start-time" name="start_time" type="time" step="300" required />
                                            <span class="input-hint">Local plant time (e.g. 07:15)</span>
                                        </div>
                                        <div class="input-group">
                                            <label for="idle-end-time">Idle cleared</label>
                                            <input id="idle-end-time" name="end_time" type="time" step="300" />
                                            <span class="input-hint">Leave blank if the stoppage is still ongoing.</span>
                                        </div>
                                        <div class="input-group">
                                            <label for="idle-reason">Primary idle reason</label>
                                            <select id="idle-reason" name="reason">
                                                <option value="">Select primary reason</option>
                                                <option value="Machine">Machine</option>
                                                <option value="Labor">Labor</option>
                                                <option value="Material">Material</option>
                                                <option value="Other">Other</option>
                                            </select>
                                        </div>
                                        <div class="input-group" id="idle-secondary-group" hidden>
                                            <label for="idle-secondary-reason">Secondary idle reason <span class="required" data-secondary-required hidden>*</span></label>
                                            <select id="idle-secondary-reason" name="secondary_reason" disabled>
                                                <option value="">Select secondary reason</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="input-group">
                                        <label for="idle-notes">Notes</label>
                                        <textarea id="idle-notes" name="notes" rows="2" placeholder="Add context, corrective action or follow-up"></textarea>
                                    </div>
                                    <div class="form__footer">
                                        <button type="submit" class="button">Save idle record</button>
                                    </div>
                                </form>
                            </div>
                        </section>
                    </div>
                    <section class="panel idle-machines">
                        <header class="idle-machines__header">
                            <div>
                                <h2>Machine spotlight</h2>
                                <p class="panel__subtitle">Realtime utilisation pulse with reason-led idle windows.</p>
                            </div>
                        </header>
                        <div class="idle-machine-grid">
                            <article class="machine-glance" data-machine-card="MCH-0001">
                                <header class="machine-glance__header">
                                    <div>
                                        <p class="machine-glance__code">MCH-0001</p>
                                        <h3 class="machine-glance__title">Cutting Cell</h3>
                                    </div>
                                    <span class="status-pill" data-machine-status>Awaiting data</span>
                                </header>
                                <p class="machine-glance__runtime"><span data-machine-runtime>—</span> <small>runtime</small></p>
                                <div class="machine-glance__progress" aria-hidden="true">
                                    <div class="machine-glance__progress-bar" data-machine-progress></div>
                                </div>
                                <dl class="machine-glance__metrics">
                                    <div>
                                        <dt>Idle</dt>
                                        <dd data-machine-idle>—</dd>
                                    </div>
                                    <div>
                                        <dt>Overtime</dt>
                                        <dd data-machine-extended>—</dd>
                                    </div>
                                    <div>
                                        <dt>Utilisation</dt>
                                        <dd data-machine-utilisation>—</dd>
                                    </div>
                                </dl>
                                <div class="machine-glance__reason" data-machine-reason>Idle reason insights will appear here.</div>
                                <p class="machine-glance__note" data-machine-note></p>
                            </article>
                            <article class="machine-glance" data-machine-card="MCH-0002">
                                <header class="machine-glance__header">
                                    <div>
                                        <p class="machine-glance__code">MCH-0002</p>
                                        <h3 class="machine-glance__title">Precision Lathe</h3>
                                    </div>
                                    <span class="status-pill" data-machine-status>Awaiting data</span>
                                </header>
                                <p class="machine-glance__runtime"><span data-machine-runtime>—</span> <small>runtime</small></p>
                                <div class="machine-glance__progress" aria-hidden="true">
                                    <div class="machine-glance__progress-bar" data-machine-progress></div>
                                </div>
                                <dl class="machine-glance__metrics">
                                    <div>
                                        <dt>Idle</dt>
                                        <dd data-machine-idle>—</dd>
                                    </div>
                                    <div>
                                        <dt>Overtime</dt>
                                        <dd data-machine-extended>—</dd>
                                    </div>
                                    <div>
                                        <dt>Utilisation</dt>
                                        <dd data-machine-utilisation>—</dd>
                                    </div>
                                </dl>
                                <div class="machine-glance__reason" data-machine-reason>Idle reason insights will appear here.</div>
                                <p class="machine-glance__note" data-machine-note></p>
                            </article>
                            <article class="machine-glance" data-machine-card="MCH-0003">
                                <header class="machine-glance__header">
                                    <div>
                                        <p class="machine-glance__code">MCH-0003</p>
                                        <h3 class="machine-glance__title">Finishing Line</h3>
                                    </div>
                                    <span class="status-pill" data-machine-status>Awaiting data</span>
                                </header>
                                <p class="machine-glance__runtime"><span data-machine-runtime>—</span> <small>runtime</small></p>
                                <div class="machine-glance__progress" aria-hidden="true">
                                    <div class="machine-glance__progress-bar" data-machine-progress></div>
                                </div>
                                <dl class="machine-glance__metrics">
                                    <div>
                                        <dt>Idle</dt>
                                        <dd data-machine-idle>—</dd>
                                    </div>
                                    <div>
                                        <dt>Overtime</dt>
                                        <dd data-machine-extended>—</dd>
                                    </div>
                                    <div>
                                        <dt>Utilisation</dt>
                                        <dd data-machine-utilisation>—</dd>
                                    </div>
                                </dl>
                                <div class="machine-glance__reason" data-machine-reason>Idle reason insights will appear here.</div>
                                <p class="machine-glance__note" data-machine-note></p>
                            </article>
                        </div>
                    </section>
                    <section class="panel idle-insights">
                        <header class="idle-insights__header">
                            <div>
                                <h2>Actionable insights</h2>
                                <p class="panel__subtitle">Reasons with the biggest impact and suggested focus areas.</p>
                            </div>
                        </header>
                        <div class="idle-insights__body">
                            <ul class="insight-list" id="idle-insights"></ul>
                            <div class="idle-reasons" id="idle-reason-pills"></div>
                        </div>
                    </section>
                </section>
                <section id="supplier-section" class="panel-group">
                    <header class="panel-group__header">
                        <h2>Service supplier register</h2>
                        <p>Maintain a directory of trusted maintenance partners.</p>
                    </header>
                    <div class="panel-grid">
                        <section class="panel panel--form">
                            <header class="panel__header">
                                <div>
                                    <h2>Add service supplier</h2>
                                    <p class="panel__subtitle">Maintain a directory of trusted maintenance partners.</p>
                                </div>
                            </header>
                            <div class="panel__body">
                                <div class="alert alert--info" id="supplier-form-notice" hidden></div>
                                <div class="alert alert--success" id="supplier-form-success" hidden>Supplier added successfully.</div>
                                <div class="alert alert--error" id="supplier-form-error" hidden></div>
                                <form class="form" id="supplier-form" novalidate>
                                    <div class="form-grid">
                                        <div class="input-group">
                                            <label for="supplier-name">Supplier name <span class="required">*</span></label>
                                            <input id="supplier-name" name="name" type="text" placeholder="ABC Engineering" required />
                                        </div>
                                        <div class="input-group">
                                            <label for="supplier-contact">Contact person</label>
                                            <input id="supplier-contact" name="contact_person" type="text" placeholder="Ms. Perera" />
                                        </div>
                                        <div class="input-group">
                                            <label for="supplier-phone">Phone</label>
                                            <input id="supplier-phone" name="phone" type="tel" placeholder="011 123 4567" />
                                        </div>
                                        <div class="input-group">
                                            <label for="supplier-email">Email</label>
                                            <input id="supplier-email" name="email" type="email" placeholder="service@example.com" />
                                        </div>
                                    </div>
                                    <div class="input-group">
                                        <label for="supplier-services">Services offered</label>
                                        <textarea id="supplier-services" name="services_offered" rows="2" placeholder="Calibration, emergency repairs"></textarea>
                                    </div>
                                    <div class="input-group">
                                        <label for="supplier-assets">Preferred assets</label>
                                        <textarea id="supplier-assets" name="preferred_assets" rows="2" placeholder="List of assets or categories"></textarea>
                                    </div>
                                    <div class="input-group">
                                        <label for="supplier-notes">Notes</label>
                                        <textarea id="supplier-notes" name="notes" rows="2" placeholder="Payment terms, service hours, etc."></textarea>
                                    </div>
                                    <div class="form__footer">
                                        <button type="submit" class="button">Add supplier</button>
                                    </div>
                                </form>
                            </div>
                        </section>
                        <section class="panel panel--list">
                            <header class="panel__header">
                                <div>
                                    <h2>Service suppliers</h2>
                                    <p class="panel__subtitle">Reference contact and service information when needed.</p>
                                </div>
                                <button type="button" class="button button--ghost" id="refresh-suppliers">Refresh</button>
                            </header>
                            <div class="panel__body">
                                <div class="alert alert--error" id="supplier-error" hidden></div>
                                <div class="empty-state" id="suppliers-empty" hidden>
                                    <p>No service suppliers registered yet.</p>
                                </div>
                                <div class="table-wrapper">
                                    <table class="data-table" aria-describedby="suppliers-empty">
                                        <thead>
                                            <tr>
                                                <th scope="col">Name</th>
                                                <th scope="col">Contact</th>
                                                <th scope="col">Phone</th>
                                                <th scope="col">Email</th>
                                                <th scope="col">Services</th>
                                            </tr>
                                        </thead>
                                        <tbody id="suppliers-table-body"></tbody>
                                    </table>
                                </div>
                            </div>
                        </section>
                    </div>
                </section>
            </div>
        </main>
        <div class="modal" id="asset-modal" role="dialog" aria-modal="true" aria-labelledby="asset-modal-title" data-modal hidden>
            <div class="modal__backdrop" data-modal-close></div>
            <div class="modal__window" role="document">
                <header class="modal__header" data-modal-handle>
                    <h2 class="modal__title" id="asset-modal-title">Register a new asset</h2>
                    <button type="button" class="modal__close" data-modal-close aria-label="Close">&times;</button>
                </header>
                <div class="modal__body">
                    <p class="modal__subtitle">Maintain an up-to-date registry of every machine on site.</p>
                    <div class="alert alert--info" id="asset-form-notice" hidden></div>
                    <div class="alert alert--success" id="asset-form-success" hidden>Asset added successfully.</div>
                    <div class="alert alert--error" id="asset-form-error" hidden></div>
                    <form class="form" id="asset-form" novalidate>
                        <div class="form-grid">
                            <div class="input-group">
                                <label for="asset-code">Asset code <span class="required">*</span></label>
                                <input id="asset-code" name="code" type="text" placeholder="Select a category" required readonly />
                            </div>
                            <div class="input-group">
                                <label for="asset-name">Name <span class="required">*</span></label>
                                <input id="asset-name" name="name" type="text" placeholder="Hydraulic press" required />
                            </div>
                            <div class="input-group">
                                <label for="asset-category">Category</label>
                                <select id="asset-category" name="category">
                                    <option value="" selected hidden>Select a category</option>
                                    <option value="Land &amp; Building">Land &amp; Building</option>
                                    <option value="Plant &amp; Machines">Plant &amp; Machines</option>
                                    <option value="Vehicles">Vehicles</option>
                                    <option value="Furniture &amp; Fixtures">Furniture &amp; Fixtures</option>
                                    <option value="Tools &amp; Equipment">Tools &amp; Equipment</option>
                                    <option value="Computers">Computers</option>
                                    <option value="Electronic Equipments">Electronic Equipments</option>
                                    <option value="Phones">Phones</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="asset-location">Location</label>
                                <input id="asset-location" name="location" type="text" placeholder="Plant 1" />
                            </div>
                            <div class="input-group">
                                <label for="asset-manufacturer">Manufacturer</label>
                                <input id="asset-manufacturer" name="manufacturer" type="text" placeholder="OEM" />
                            </div>
                            <div class="input-group">
                                <label for="asset-model">Model number</label>
                                <input id="asset-model" name="model_number" type="text" placeholder="HP-300" />
                            </div>
                            <div class="input-group">
                                <label for="asset-serial">Serial number</label>
                                <input id="asset-serial" name="serial_number" type="text" placeholder="SN12345" />
                            </div>
                            <div class="input-group">
                                <label for="asset-installed">Installed on</label>
                                <input id="asset-installed" name="installed_on" type="date" />
                            </div>
                            <div class="input-group">
                                <label for="asset-status">Status</label>
                                <input id="asset-status" name="status" type="text" placeholder="Operational" />
                            </div>
                        </div>
                        <div class="input-group">
                            <label for="asset-notes">Notes</label>
                            <textarea id="asset-notes" name="notes" rows="3" placeholder="Any supporting notes"></textarea>
                        </div>
                        <div class="form__footer">
                            <button type="submit" class="button">Add asset</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
        <div class="modal" id="ckd-modal" role="dialog" aria-modal="true" aria-labelledby="ckd-modal-title" data-modal hidden>
            <div class="modal__backdrop" data-modal-close></div>
            <div class="modal__window" role="document">
                <header class="modal__header" data-modal-handle>
                    <h2 class="modal__title" id="ckd-modal-title">Add CKD part to machine</h2>
                    <button type="button" class="modal__close" data-modal-close aria-label="Close">&times;</button>
                </header>
                <div class="modal__body">
                    <p class="modal__subtitle">Quickly register CKD parts for a selected machine.</p>
                    <ol class="modal__list">
                        <li>Open an asset from the register to view its CKD parts.</li>
                        <li>Use the part form to add details such as part number, life and notes.</li>
                        <li>Save the part to keep the machine register up to date.</li>
                    </ol>
                    <p class="modal__hint">Need to jump there now?</p>
                    <div class="modal__actions">
                        <button type="button" class="button" data-scroll-target="#machine-outputs" data-modal-close-after>Go to assets register</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal" id="maintenance-job-modal" role="dialog" aria-modal="true" aria-labelledby="maintenance-job-modal-title" data-modal hidden>
            <div class="modal__backdrop" data-modal-close></div>
            <div class="modal__window modal__window--wide" role="document">
                <header class="modal__header" data-modal-handle>
                    <h2 class="modal__title" id="maintenance-job-modal-title">Create a maintenance job</h2>
                    <button type="button" class="modal__close" data-modal-close aria-label="Close">&times;</button>
                </header>
                <div class="modal__body maintenance-modal__body">
                    <section id="maintenance-section" class="panel-group">
                        <div class="panel-grid">
                            <section class="panel panel--form">
                                <header class="panel__header">
                                    <div>
                                        <h2>Create a maintenance job</h2>
                                        <p class="panel__subtitle">Log new work orders for the maintenance team.</p>
                                    </div>
                                </header>
                                <div class="panel__body">
                                    <div class="alert alert--info" id="creation-notice" hidden></div>
                                    <div class="alert alert--success" id="creation-success" hidden></div>
                                    <div class="alert alert--warning" id="creation-warning" hidden></div>
                                    <div class="alert alert--success" id="maintenance-success" hidden></div>
                                    <div class="alert alert--warning" id="maintenance-warning" hidden></div>
                                    <div class="alert alert--error" id="creation-error" hidden></div>
                                    <form class="form" id="job-form" novalidate>
                                        <input type="hidden" id="job-id" name="job_id" />
                                        <fieldset class="form-section" data-production-section>
                                            <legend>Production Manager</legend>
                                            <div class="form-grid">
                                                <div class="input-group">
                                                    <label for="job-code">Job code</label>
                                                    <input id="job-code" name="job_code" type="text" placeholder="JOB-001" readonly />
                                                </div>
                                                <div class="input-group">
                                                    <label for="job-date">Date</label>
                                                    <input id="job-date" name="job_date" type="date" />
                                                </div>
                                                <div class="input-group" data-field-group="job_category">
                                                    <label for="job-category">Job Category <span class="required">*</span></label>
                                                    <select id="job-category" name="job_category" required>
                                                        <option value="">Select a category</option>
                                                        <option value="Mechanical / Machine Issues">Mechanical / Machine Issues</option>
                                                        <option value="Electrical &amp; Power Related">Electrical &amp; Power Related</option>
                                                        <option value="Preventive / Routine Maintenance">Preventive / Routine Maintenance</option>
                                                        <option value="Utility / Plant Support">Utility / Plant Support</option>
                                                        <option value="Safety &amp; Facility Maintenance">Safety &amp; Facility Maintenance</option>
                                                        <option value="Vehicle Engine &amp; PowerTrain">Vehicle Engine &amp; PowerTrain</option>
                                                        <option value="Transmission &amp; Drivetrain">Transmission &amp; Drivetrain</option>
                                                        <option value="Tyres &amp; Suspension">Tyres &amp; Suspension</option>
                                                        <option value="Vehicle Electrical &amp; Lighting">Vehicle Electrical &amp; Lighting</option>
                                                        <option value="Brakes &amp; Safety">Brakes &amp; Safety</option>
                                                        <option value="Body Exterior">Body Exterior</option>
                                                        <option value="Hydrulic system">Hydrulic system</option>
                                                        <option value="Cooling System">Cooling System</option>
                                                        <option value="Structural &amp; Civil Maintenance">Structural &amp; Civil Maintenance</option>
                                                        <option value="Doors, Windows and Fixture">Doors, Windows and Fixture</option>
                                                        <option value="Plumbing &amp; Water System">Plumbing &amp; Water System</option>
                                                        <option value="Ventilation &amp; Environment">Ventilation &amp; Environment</option>
                                                        <option value="Housekeeping &amp; Safety">Housekeeping &amp; Safety</option>
                                                    </select>
                                                    <p class="form__error" data-field-error="job_category" hidden></p>
                                                </div>
                                                <div class="input-group">
                                                    <label for="job-priority">Priority</label>
                                                    <select id="job-priority" name="priority">
                                                        <option value="Normal">Normal</option>
                                                        <option value="Urgent">Urgent</option>
                                                        <option value="Critical">Critical</option>
                                                    </select>
                                                </div>
                                                <div class="input-group">
                                                    <label for="job-location">Location</label>
                                                    <select id="job-location" name="location">
                                                        <option value="">Select a location</option>
                                                        <option value="Plant 1">Plant 1</option>
                                                        <option value="Plant 2">Plant 2</option>
                                                        <option value="Plant 3">Plant 3</option>
                                                        <option value="Warehouse">Warehouse</option>
                                                    </select>
                                                </div>
                                                <div class="input-group">
                                                    <label for="job-expected">Expected completion</label>
                                                    <input id="job-expected" name="expected_completion" type="date" />
                                                </div>
                                            </div>
                                            <div class="input-group" data-field-group="asset_id">
                                                <label for="job-asset">Asset name</label>
                                                <input id="job-asset-search" type="search" placeholder="Search assets" data-select-filter="job-asset" autocomplete="off" />
                                                <select id="job-asset" name="asset_id">
                                                    <option value="">Select an asset</option>
                                                </select>
                                                <p class="form__error" data-field-error="asset_id" hidden></p>
                                            </div>
                                            <div class="input-group" data-field-group="part_id">
                                                <label for="job-part">Part name (CKD) <span class="required" data-part-required hidden>*</span></label>
                                                <input id="job-part-search" type="search" placeholder="Search parts" data-select-filter="job-part" aria-describedby="job-part-hint" autocomplete="off" />
                                                <select id="job-part" name="part_id">
                                                    <option value="">Select a part</option>
                                                </select>
                                                <p class="form__hint" id="job-part-hint">Select an asset to filter parts.</p>
                                                <p class="form__error" data-field-error="part_id" hidden></p>
                                            </div>
                                            <div class="input-group">
                                                <label for="job-description">Description of the job</label>
                                                <textarea id="job-description" name="description" rows="4" placeholder="Provide any additional details"></textarea>
                                            </div>
                                            <div class="input-group">
                                                <label for="maintenance-email">Email of Maintenance Manager</label>
                                                <input id="maintenance-email" name="maint_email" type="email" placeholder="manager@example.com" />
                                            </div>
                                            <div class="form__footer">
                                                <div class="button-group">
                                                    <button type="button" class="button" id="submit-to-maintenance">Submit to Maintenance Manager</button>
                                                    <button type="button" class="button button--ghost" id="reset-job-form">Start new job</button>
                                                </div>
                                            </div>
                                        </fieldset>

                                        <fieldset class="form-section" data-maintenance-section>
                                            <legend>Maintenance Manager</legend>
                                            <div class="form-grid">
                                                <div class="input-group">
                                                    <label for="job-start">Job started date</label>
                                                    <input id="job-start" name="job_started_date" type="date" />
                                                </div>
                                                <div class="input-group">
                                                    <label for="job-finish">Job finished date</label>
                                                    <input id="job-finish" name="job_finished_date" type="date" />
                                                </div>
                                            </div>
                                            <div class="input-group">
                                                <label>Materials used</label>
                                                <div class="table-wrapper" data-materials-table>
                                                    <table class="jobs-table">
                                                        <thead>
                                                            <tr>
                                                                <th scope="col">Material name</th>
                                                                <th scope="col">Units</th>
                                                                <th scope="col">Cost</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody id="materials-table-body"></tbody>
                                                    </table>
                                                </div>
                                                <div class="button-group button-group--inline">
                                                    <button type="button" class="button button--ghost" id="add-material-row">Add row</button>
                                                    <button type="button" class="button button--ghost" id="remove-material-row">Remove row</button>
                                                    </div>
                                                    <p class="form__hint">Total cost: <span id="materials-total">0.00</span></p>
                                            </div>
                                            <div class="input-group">
                                                <label>Outsourced party cost</label>
                                                <div class="table-wrapper" data-outsourced-table>
                                                    <table class="jobs-table">
                                                        <thead>
                                                            <tr>
                                                                <th scope="col">Outsourced Party</th>
                                                                <th scope="col">Service Date</th>
                                                                <th scope="col">Service Description</th>
                                                                <th scope="col">Engaged Hours</th>
                                                                <th scope="col">Cost (Rs.)</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody id="outsourced-table-body"></tbody>
                                                    </table>
                                                </div>
                                                <div class="button-group button-group--inline">
                                                    <button type="button" class="button button--ghost" id="add-outsourced-row">Add row</button>
                                                    <button type="button" class="button button--ghost" id="remove-outsourced-row">Remove row</button>
                                                </div>
                                                <p class="form__hint">Total outsourced cost: Rs. <span id="outsourced-total">0.00</span></p>
                                            </div>
                                            <div class="input-group">
                                                <label>Internal staff cost</label>
                                                <div class="table-wrapper" data-internal-staff-table>
                                                    <table class="jobs-table">
                                                        <thead>
                                                            <tr>
                                                                <th scope="col">Employee</th>
                                                                <th scope="col">Service Date</th>
                                                                <th scope="col">Work Description</th>
                                                                <th scope="col">Engaged Hours</th>
                                                                <th scope="col">Hourly Rate (Rs.)</th>
                                                                <th scope="col">Cost (Rs.)</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody id="internal-staff-table-body"></tbody>
                                                    </table>
                                                </div>
                                                <div class="button-group button-group--inline">
                                                    <button type="button" class="button button--ghost" id="add-internal-staff-row">Add row</button>
                                                    <button type="button" class="button button--ghost" id="remove-internal-staff-row">Remove row</button>
                                                </div>
                                                <p class="form__hint">Total internal staff cost: Rs. <span id="internal-staff-total">0.00</span></p>
                                            </div>
                                            <div class="input-group">
                                                <label for="maintenance-notes">Signature / Remarks</label>
                                                <textarea id="maintenance-notes" name="maintenance_notes" rows="3"></textarea>
                                            </div>
                                            <div class="input-group">
                                                <label for="production-email">Email of Production Manager</label>
                                                <input id="production-email" name="prod_email" type="email" placeholder="production@example.com" />
                                            </div>
                                            <div class="form__footer">
                                                <button type="button" class="button" id="submit-to-production">Submit to Production Manager</button>
                                            </div>
                                        </fieldset>
                                    </form>
                                </div>
                            </section>
                        </div>
                    </section>
                </div>
            </div>
        </div>
        <div class="modal" id="job-details-modal" role="dialog" aria-modal="true" aria-labelledby="job-details-modal-title" data-modal hidden>
            <div class="modal__backdrop" data-modal-close></div>
            <div class="modal__window modal__window--wide" role="document">
                <header class="modal__header" data-modal-handle>
                    <h2 class="modal__title" id="job-details-modal-title">Maintenance job</h2>
                    <button type="button" class="modal__close" data-modal-close aria-label="Close">&times;</button>
                </header>
                <div class="modal__body job-details-modal__body">
                    <div class="alert alert--error" id="job-details-error" hidden></div>
                    <div class="job-details-modal__loading" id="job-details-loading" hidden>Loading job details…</div>
                    <div class="job-details-modal__content" data-job-details-content hidden>
                        <section class="job-details__section">
                            <h3>Overview</h3>
                            <dl class="job-details__facts" id="job-details-overview"></dl>
                        </section>
                        <section class="job-details__section job-details__section--split">
                            <div>
                                <h3>Asset &amp; Part</h3>
                                <dl class="job-details__facts job-details__facts--inline">
                                    <div>
                                        <dt>Asset name</dt>
                                        <dd id="job-details-asset">—</dd>
                                    </div>
                                    <div>
                                        <dt>Part name (CKD)</dt>
                                        <dd id="job-details-part">—</dd>
                                    </div>
                                </dl>
                            </div>
                            <div>
                                <h3>Timeline</h3>
                                <ol class="job-timeline" id="job-details-timeline"></ol>
                            </div>
                        </section>
                        <section class="job-details__section job-details__section--columns">
                            <article class="job-details__card">
                                <h4>Description of the job</h4>
                                <p id="job-details-description" class="job-details__text">No description provided.</p>
                            </article>
                            <article class="job-details__card">
                                <h4>Remark</h4>
                                <p id="job-details-remark" class="job-details__text">No remarks recorded.</p>
                            </article>
                        </section>
                        <section class="job-details__section">
                            <h3>Materials used</h3>
                            <div class="table-wrapper">
                                <table class="jobs-table job-details__table">
                                    <thead>
                                        <tr>
                                            <th scope="col">Item</th>
                                            <th scope="col">Qty</th>
                                            <th scope="col">Unit cost</th>
                                            <th scope="col">Line cost</th>
                                        </tr>
                                    </thead>
                                    <tbody id="job-details-materials-body"></tbody>
                                </table>
                            </div>
                            <p class="job-details__subtotal">Subtotal: <span id="job-details-materials-total">Rs. 0.00</span></p>
                        </section>
                        <section class="job-details__section job-details__section--stacked">
                            <div class="job-details__group">
                                <h3>Outsourced party cost</h3>
                                <div class="table-wrapper">
                                    <table class="jobs-table job-details__table">
                                        <thead>
                                            <tr>
                                                <th scope="col">Party</th>
                                                <th scope="col">Service date</th>
                                                <th scope="col">Description</th>
                                                <th scope="col">Hours/Qty</th>
                                                <th scope="col">Cost</th>
                                            </tr>
                                        </thead>
                                        <tbody id="job-details-outsourced-body"></tbody>
                                    </table>
                                </div>
                                <p class="job-details__subtotal">Subtotal: <span id="job-details-outsourced-total">Rs. 0.00</span></p>
                            </div>
                            <div class="job-details__group">
                                <h3>Internal staff cost</h3>
                                <div class="table-wrapper">
                                    <table class="jobs-table job-details__table">
                                        <thead>
                                            <tr>
                                                <th scope="col">Employee</th>
                                                <th scope="col">Role</th>
                                                <th scope="col">Hours</th>
                                                <th scope="col">Rate</th>
                                                <th scope="col">Cost</th>
                                            </tr>
                                        </thead>
                                        <tbody id="job-details-staff-body"></tbody>
                                    </table>
                                </div>
                                <p class="job-details__subtotal">Subtotal: <span id="job-details-staff-total">Rs. 0.00</span></p>
                            </div>
                        </section>
                        <section class="job-details__section job-details__section--totals">
                            <h3>Totals</h3>
                            <dl class="job-details__facts job-details__facts--inline">
                                <div>
                                    <dt>Materials</dt>
                                    <dd id="job-details-total-materials">Rs. 0.00</dd>
                                </div>
                                <div>
                                    <dt>Outsourced</dt>
                                    <dd id="job-details-total-outsourced">Rs. 0.00</dd>
                                </div>
                                <div>
                                    <dt>Internal</dt>
                                    <dd id="job-details-total-internal">Rs. 0.00</dd>
                                </div>
                                <div>
                                    <dt>Total cost</dt>
                                    <dd id="job-details-total-cost">Rs. 0.00</dd>
                                </div>
                            </dl>
                        </section>
                        <section class="job-details__section">
                            <h3>Updates &amp; attachments</h3>
                            <div id="job-details-updates" class="job-details__updates">No updates recorded for this job yet.</div>
                        </section>
                    </div>
                </div>
                <footer class="modal__footer job-details-modal__footer">
                    <button type="button" class="button button--ghost" data-job-details-action="close">Close</button>
                    <button type="button" class="button" data-job-details-action="print">Print Job Sheet</button>
                </footer>
            </div>
        </div>
    </div>
    <script>
        const token = localStorage.getItem("samprox_token");
        const userRaw = localStorage.getItem("samprox_user");
        let user;

        try {
            user = userRaw ? JSON.parse(userRaw) : null;
        } catch (_) {
            user = null;
        }

        if (!token || !user) {
            window.location.href = "/";
        }

        const roleLabels = {
            admin: "Admin",
            production_manager: "Production Manager",
            maintenance_manager: "Maintenance Manager",
            technician: "Technician",
        };

        const userNameEl = document.getElementById("user-name");
        const userRoleEl = document.getElementById("user-role");
        const logoutButton = document.getElementById("logout");

        const DEFAULT_IDLE_MACHINES = [
            { code: "MCH-0001", name: "Cutting Cell" },
            { code: "MCH-0002", name: "Precision Lathe" },
            { code: "MCH-0003", name: "Finishing Line" },
        ];
        const MAX_MACHINE_CARDS = 6;
        const SECONDARY_IDLE_REASON_MAP = Object.freeze({
            "Machine": [
                "Cuppy motor issue",
                "Feeder Box Refilling",
                "Pannel Board Issue",
                "Oil Circulation Issue",
                "Loader Issue",
                "Die Holder spare parts Change",
                "Die Holder Cleaning",
                "Feeder Box Issue",
                "Screw Conveyor issue",
            ],
            "Labor": [
                "Key Member Absent",
                "Labor Strike",
                "Unautarized Leaves",
                "Recruitment issue",
            ],
            "Material": [
                "Material Quality Issue",
                "Material Mixing Issue",
                "Material Sourcing Issue",
            ],
            "Other": [
                "Planned maintenance",
                "Changeover setup",
                "Power cut",
                "Environment issue",
                "Not define",
            ],
        });

        userNameEl.textContent = user?.name || "Unknown";
        userRoleEl.textContent = roleLabels[user?.role] || "";

        logoutButton.addEventListener("click", () => {
            localStorage.removeItem("samprox_token");
            localStorage.removeItem("samprox_user");
            window.location.href = "/";
        });

        const inputMenu = document.querySelector("[data-input-menu]");
        const inputMenuToggle = inputMenu?.querySelector("[data-menu-toggle]");
        let inputMenuCloseTimeout = null;

        function setInputMenuState(open) {
            if (!inputMenu) return;
            if (open) {
                inputMenu.classList.add("is-open");
            } else {
                inputMenu.classList.remove("is-open");
            }
            if (inputMenuToggle) {
                inputMenuToggle.setAttribute("aria-expanded", open ? "true" : "false");
            }
        }

        if (inputMenu && inputMenuToggle) {
            const handleOpen = () => {
                if (inputMenuCloseTimeout) {
                    clearTimeout(inputMenuCloseTimeout);
                }
                setInputMenuState(true);
            };

            const handleClose = () => {
                if (inputMenuCloseTimeout) {
                    clearTimeout(inputMenuCloseTimeout);
                }
                inputMenuCloseTimeout = setTimeout(() => setInputMenuState(false), 120);
            };

            inputMenuToggle.addEventListener("click", (event) => {
                event.preventDefault();
                event.stopPropagation();
                setInputMenuState(!inputMenu.classList.contains("is-open"));
            });

            inputMenu.addEventListener("mouseenter", handleOpen);
            inputMenu.addEventListener("mouseleave", handleClose);
            inputMenu.addEventListener("focusin", handleOpen);
            inputMenu.addEventListener("focusout", (event) => {
                if (!inputMenu.contains(event.relatedTarget)) {
                    handleClose();
                }
            });

            document.addEventListener("click", (event) => {
                if (!inputMenu.contains(event.target)) {
                    setInputMenuState(false);
                }
            });
        }

        const modalStack = [];
        const modalFocusMemory = new Map();

        function resetModalPosition(modal) {
            const windowEl = modal?.querySelector?.(".modal__window");
            if (!windowEl) return;
            windowEl.dataset.offsetX = "0";
            windowEl.dataset.offsetY = "0";
            windowEl.style.transform = "translate(-50%, -50%)";
            windowEl.classList.remove("is-dragging");
        }

        function enableModalDrag(modal) {
            const windowEl = modal?.querySelector?.(".modal__window");
            const handle = modal?.querySelector?.("[data-modal-handle]");
            if (!windowEl || !handle) return;

            windowEl.dataset.offsetX = windowEl.dataset.offsetX || "0";
            windowEl.dataset.offsetY = windowEl.dataset.offsetY || "0";

            let pointerId = null;
            let startX = 0;
            let startY = 0;
            let offsetX = 0;
            let offsetY = 0;

            const onPointerDown = (event) => {
                if (event.button !== 0) return;
                if (event.target.closest("[data-modal-close]")) return;
                pointerId = event.pointerId;
                startX = event.clientX;
                startY = event.clientY;
                offsetX = parseFloat(windowEl.dataset.offsetX || "0");
                offsetY = parseFloat(windowEl.dataset.offsetY || "0");
                windowEl.classList.add("is-dragging");
                handle.setPointerCapture(pointerId);
                event.preventDefault();
            };

            const onPointerMove = (event) => {
                if (pointerId !== event.pointerId) return;
                const deltaX = event.clientX - startX;
                const deltaY = event.clientY - startY;
                const nextX = offsetX + deltaX;
                const nextY = offsetY + deltaY;
                windowEl.style.transform = `translate(calc(-50% + ${nextX}px), calc(-50% + ${nextY}px))`;
                windowEl.dataset.currentX = String(nextX);
                windowEl.dataset.currentY = String(nextY);
            };

            const onPointerUp = (event) => {
                if (pointerId !== event.pointerId) return;
                handle.releasePointerCapture(pointerId);
                pointerId = null;
                windowEl.classList.remove("is-dragging");
                windowEl.dataset.offsetX = windowEl.dataset.currentX || windowEl.dataset.offsetX || "0";
                windowEl.dataset.offsetY = windowEl.dataset.currentY || windowEl.dataset.offsetY || "0";
                delete windowEl.dataset.currentX;
                delete windowEl.dataset.currentY;
            };

            handle.addEventListener("pointerdown", onPointerDown);
            handle.addEventListener("pointermove", onPointerMove);
            handle.addEventListener("pointerup", onPointerUp);
            handle.addEventListener("pointercancel", onPointerUp);
        }

        function openModal(id) {
            const modal = document.getElementById(id);
            if (!modal || modalStack.includes(modal)) return;
            resetModalPosition(modal);
            modal.hidden = false;
            requestAnimationFrame(() => {
                modal.classList.add("is-open");
            });
            modalStack.push(modal);
            modalFocusMemory.set(modal, document.activeElement instanceof HTMLElement ? document.activeElement : null);
            document.body.classList.add("has-open-modal");
            const focusTarget = modal.querySelector(
                'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
            );
            if (focusTarget instanceof HTMLElement) {
                focusTarget.focus({ preventScroll: true });
            }
        }

        function closeModal(modal) {
            if (!modal) return;
            modal.classList.remove("is-open");
            const index = modalStack.indexOf(modal);
            if (index !== -1) {
                modalStack.splice(index, 1);
            }
            if (modalStack.length === 0) {
                document.body.classList.remove("has-open-modal");
            }
            const previousFocus = modalFocusMemory.get(modal);
            modalFocusMemory.delete(modal);
            setTimeout(() => {
                if (!modal.classList.contains("is-open")) {
                    modal.hidden = true;
                }
            }, 200);
            if (previousFocus instanceof HTMLElement) {
                previousFocus.focus({ preventScroll: true });
            }
        }

        const modalElements = document.querySelectorAll("[data-modal]");

        modalElements.forEach((modal) => {
            enableModalDrag(modal);
            modal.addEventListener("click", (event) => {
                const closeTrigger = event.target.closest("[data-modal-close]");
                if (closeTrigger) {
                    event.preventDefault();
                    closeModal(modal);
                }
            });
            const windowEl = modal.querySelector(".modal__window");
            if (windowEl) {
                windowEl.addEventListener("click", (event) => event.stopPropagation());
            }
        });

        document.querySelectorAll("[data-modal-open]").forEach((trigger) => {
            trigger.addEventListener("click", (event) => {
                event.preventDefault();
                const targetId = trigger.dataset.modalOpen;
                if (targetId) {
                    openModal(targetId);
                    setInputMenuState(false);
                }
            });
        });

        document.addEventListener("keydown", (event) => {
            if (event.key === "Escape" && modalStack.length > 0) {
                const lastModal = modalStack[modalStack.length - 1];
                closeModal(lastModal);
            }
        });

        document.querySelectorAll("[data-scroll-target]").forEach((element) => {
            element.addEventListener("click", (event) => {
                const targetSelector = element.dataset.scrollTarget;
                if (!targetSelector) return;
                const target = document.querySelector(targetSelector);
                if (target) {
                    target.scrollIntoView({ behavior: "smooth", block: "start" });
                }
            });
        });

        document.querySelectorAll("[data-modal-close-after]").forEach((element) => {
            element.addEventListener("click", () => {
                const modal = element.closest("[data-modal]");
                if (modal) {
                    closeModal(modal);
                }
            });
        });

        const canManageAssets = ["production_manager", "admin"].includes(user?.role);
        const canManageParts = canManageAssets || ["maintenance_manager"].includes(user?.role);
        const canManageProductionJobs = ["production_manager", "admin"].includes(user?.role);
        const canManageMaintenanceJobs = ["maintenance_manager", "admin"].includes(user?.role);
        const canLogIdle = ["production_manager", "maintenance_manager", "admin"].includes(user?.role);
        const canAddSuppliers = ["production_manager", "admin"].includes(user?.role);

        const addAssetTrigger = document.querySelector('[data-modal-open="asset-modal"]');
        if (addAssetTrigger && !canManageAssets) {
            addAssetTrigger.disabled = true;
            addAssetTrigger.setAttribute("aria-disabled", "true");
            addAssetTrigger.title = "Only Production Managers or Admins can add assets.";
        }

        const maintenanceTriggers = document.querySelectorAll('[data-modal-open="maintenance-job-modal"]');
        if (maintenanceTriggers.length && !canManageProductionJobs) {
            maintenanceTriggers.forEach((trigger) => {
                trigger.disabled = true;
                trigger.setAttribute("aria-disabled", "true");
                trigger.title = "Only Production Managers or Admins can request maintenance jobs.";
            });
        } else if (maintenanceTriggers.length) {
            maintenanceTriggers.forEach((trigger) => {
                trigger.addEventListener("click", () => {
                    prepareNewJobForm();
                });
            });
        }

        const assetsTableBody = document.getElementById("assets-table-body");
        const assetsEmpty = document.getElementById("assets-empty");
        const assetError = document.getElementById("asset-error");
        const refreshAssetsButton = document.getElementById("refresh-assets");
        const assetForm = document.getElementById("asset-form");
        const assetFormNotice = document.getElementById("asset-form-notice");
        const assetFormSuccess = document.getElementById("asset-form-success");
        const assetFormError = document.getElementById("asset-form-error");
        const assetDetail = document.getElementById("asset-detail");
        const assetDetailTitle = document.getElementById("asset-detail-title");
        const assetDetailMeta = document.getElementById("asset-detail-meta");
        const assetDetailFacts = document.getElementById("asset-detail-facts");
        const assetPartForm = document.getElementById("asset-part-form");
        const assetPartError = document.getElementById("asset-part-error");
        const assetPartSuccess = document.getElementById("asset-part-success");
        const assetPartsList = document.getElementById("asset-parts-list");
        const assetPartsEmpty = document.getElementById("asset-parts-empty");
        const assetPartSearchInput = document.getElementById("asset-part-search");
        const assetPartsEmptyMessage = document.querySelector("#asset-parts-empty p");
        const partNumberInput = document.getElementById("part-number");
        const closeAssetDetail = document.getElementById("close-asset-detail");
        const assetCodeInput = document.getElementById("asset-code");
        const assetCategorySelect = document.getElementById("asset-category");

        const jobForm = document.getElementById("job-form");
        const creationNotice = document.getElementById("creation-notice");
        const creationSuccess = document.getElementById("creation-success");
        const creationWarning = document.getElementById("creation-warning");
        const creationError = document.getElementById("creation-error");
        const maintenanceSuccess = document.getElementById("maintenance-success");
        const maintenanceWarning = document.getElementById("maintenance-warning");
        const jobIdInput = document.getElementById("job-id");
        const jobCodeInput = document.getElementById("job-code");
        const jobDateInput = document.getElementById("job-date");
        const jobCategorySelect = document.getElementById("job-category");
        const jobAssetSearchInput = document.getElementById("job-asset-search");
        const jobAssetSelect = document.getElementById("job-asset");
        const jobPartSearchInput = document.getElementById("job-part-search");
        const jobPartSelect = document.getElementById("job-part");
        const jobPartHint = document.getElementById("job-part-hint");
        const partRequiredIndicator = document.querySelector("[data-part-required]");
        const jobPrioritySelect = document.getElementById("job-priority");
        const jobLocationSelect = document.getElementById("job-location");
        const jobExpectedInput = document.getElementById("job-expected");
        const jobDescriptionInput = document.getElementById("job-description");
        const maintenanceEmailInput = document.getElementById("maintenance-email");
        const productionEmailInput = document.getElementById("production-email");
        const jobStartInput = document.getElementById("job-start");
        const jobFinishInput = document.getElementById("job-finish");
        const maintenanceNotesInput = document.getElementById("maintenance-notes");
        const submitToMaintenanceButton = document.getElementById("submit-to-maintenance");
        const submitToProductionButton = document.getElementById("submit-to-production");
        const addMaterialRowButton = document.getElementById("add-material-row");
        const removeMaterialRowButton = document.getElementById("remove-material-row");
        const materialsTableBody = document.getElementById("materials-table-body");
        const materialsTotalEl = document.getElementById("materials-total");
        const addOutsourcedRowButton = document.getElementById("add-outsourced-row");
        const removeOutsourcedRowButton = document.getElementById("remove-outsourced-row");
        const outsourcedTableBody = document.getElementById("outsourced-table-body");
        const outsourcedTotalEl = document.getElementById("outsourced-total");
        const addInternalStaffRowButton = document.getElementById("add-internal-staff-row");
        const removeInternalStaffRowButton = document.getElementById("remove-internal-staff-row");
        const internalStaffTableBody = document.getElementById("internal-staff-table-body");
        const internalStaffTotalEl = document.getElementById("internal-staff-total");
        const productionSection = document.querySelector("[data-production-section]");
        const maintenanceSection = document.querySelector("[data-maintenance-section]");
        const resetJobFormButton = document.getElementById("reset-job-form");
        const jobsError = document.getElementById("jobs-error");
        const jobsEmpty = document.getElementById("jobs-empty");
        const jobsTableBody = document.getElementById("jobs-table-body");
        const refreshJobsButton = document.getElementById("refresh-jobs");
        const jobDetailsModal = document.getElementById("job-details-modal");
        const jobDetailsTitle = document.getElementById("job-details-modal-title");
        const jobDetailsError = document.getElementById("job-details-error");
        const jobDetailsLoading = document.getElementById("job-details-loading");
        const jobDetailsContent = jobDetailsModal?.querySelector("[data-job-details-content]");
        const jobDetailsOverview = document.getElementById("job-details-overview");
        const jobDetailsAsset = document.getElementById("job-details-asset");
        const jobDetailsPart = document.getElementById("job-details-part");
        const jobDetailsTimeline = document.getElementById("job-details-timeline");
        const jobDetailsDescription = document.getElementById("job-details-description");
        const jobDetailsRemark = document.getElementById("job-details-remark");
        const jobDetailsMaterialsBody = document.getElementById("job-details-materials-body");
        const jobDetailsMaterialsTotal = document.getElementById("job-details-materials-total");
        const jobDetailsOutsourcedBody = document.getElementById("job-details-outsourced-body");
        const jobDetailsOutsourcedTotal = document.getElementById("job-details-outsourced-total");
        const jobDetailsStaffBody = document.getElementById("job-details-staff-body");
        const jobDetailsStaffTotal = document.getElementById("job-details-staff-total");
        const jobDetailsTotalsMaterials = document.getElementById("job-details-total-materials");
        const jobDetailsTotalsOutsourced = document.getElementById("job-details-total-outsourced");
        const jobDetailsTotalsInternal = document.getElementById("job-details-total-internal");
        const jobDetailsTotalsCost = document.getElementById("job-details-total-cost");
        const jobDetailsUpdates = document.getElementById("job-details-updates");

        const jobFieldErrors = {
            job_category: document.querySelector('[data-field-error="job_category"]'),
            asset_id: document.querySelector('[data-field-error="asset_id"]'),
            part_id: document.querySelector('[data-field-error="part_id"]'),
        };

        document.querySelectorAll('[data-select-filter]').forEach((input) => {
            const targetId = input.getAttribute("data-select-filter");
            if (!targetId) return;
            const targetSelect = document.getElementById(targetId);
            if (!targetSelect) return;
            const applyFilter = () => filterSelectOptions(targetSelect, input.value);
            input.addEventListener("input", applyFilter);
            input.addEventListener("search", applyFilter);
        });

        if (jobCategorySelect) {
            jobCategorySelect.addEventListener("change", () => {
                setFieldError("job_category", "");
            });
        }

        if (jobAssetSelect) {
            jobAssetSelect.addEventListener("change", () => {
                setFieldError("asset_id", "");
                if (jobPartSearchInput) jobPartSearchInput.value = "";
                const assetId = jobAssetSelect.value || null;
                Promise.resolve(refreshPartOptionsForAsset(assetId, { presetValue: "" })).catch(() => {});
            });
        }

        if (jobPartSelect) {
            jobPartSelect.addEventListener("change", () => {
                setFieldError("part_id", "");
            });
        }

        if (jobStartInput) {
            const handleStartChange = () => {
                updateOutsourcedDateConstraints();
                updateInternalStaffDateConstraints();
            };
            jobStartInput.addEventListener("change", handleStartChange);
            jobStartInput.addEventListener("input", handleStartChange);
        }

        if (jobFinishInput) {
            const handleFinishChange = () => {
                updateOutsourcedDateConstraints();
                updateInternalStaffDateConstraints();
            };
            jobFinishInput.addEventListener("change", handleFinishChange);
            jobFinishInput.addEventListener("input", handleFinishChange);
        }

        const idleEntryForm = document.getElementById("idle-entry-form");
        const idleEntryNotice = document.getElementById("idle-entry-notice");
        const idleEntrySuccess = document.getElementById("idle-entry-success");
        const idleEntryError = document.getElementById("idle-entry-error");
        const idleDateInput = document.getElementById("idle-date");
        const idleMachineSelect = document.getElementById("idle-machine");
        const idleStartTimeInput = document.getElementById("idle-start-time");
        const idleEndTimeInput = document.getElementById("idle-end-time");
        const idleReasonSelect = document.getElementById("idle-reason");
        const idleSecondaryReasonGroup = document.getElementById("idle-secondary-group");
        const idleSecondaryReasonSelect = document.getElementById("idle-secondary-reason");
        const idleSecondaryRequiredIndicator = document.querySelector("[data-secondary-required]");
        const idleNotesInput = document.getElementById("idle-notes");
        const idlePulseGrid = document.getElementById("idle-pulse-grid");
        const idleStatRuntime = document.querySelector("[data-total-runtime]");
        const idleStatIdle = document.querySelector("[data-total-idle]");
        const idleStatExtended = document.querySelector("[data-total-extended]");
        const idleInsightsList = document.getElementById("idle-insights");
        const idleReasonPills = document.getElementById("idle-reason-pills");
        const machineCardsContainer = document.querySelector(".idle-machine-grid");
        let machineCards = Array.from(
            machineCardsContainer?.querySelectorAll("[data-machine-card]") || []
        );
        let serviceSuppliers = [];
        let activeEmployees = [];

        let currentMaintenanceJob = null;
        let selectedJobId = null;
        const jobDetailsCache = new Map();

        const supplierForm = document.getElementById("supplier-form");
        const supplierFormNotice = document.getElementById("supplier-form-notice");
        const supplierFormSuccess = document.getElementById("supplier-form-success");
        const supplierFormError = document.getElementById("supplier-form-error");
        const supplierError = document.getElementById("supplier-error");
        const suppliersEmpty = document.getElementById("suppliers-empty");
        const suppliersTableBody = document.getElementById("suppliers-table-body");
        const refreshSuppliersButton = document.getElementById("refresh-suppliers");

        let assets = [];
        let currentAssetId = null;
        let currentParts = [];
        let maintenanceParts = [];
        let maintenancePartsRequest = 0;
        let latestPartFilterRequest = 0;
        let isPartSelectionRequired = false;
        let latestCodeRequest = 0;

        const SHIFT_DURATION_HOURS = 12;
        const machineMetadata = new Map(
            DEFAULT_IDLE_MACHINES.map((machine) => [machine.code, { title: machine.name }])
        );

        const today = new Date();
        const todayDateString = today.toISOString().slice(0, 10);

        let idleInitialized = false;
        let idleEvents = [];
        const idleSummaryCache = new Map();

        function setFieldError(field, message) {
            const errorEl = jobFieldErrors[field];
            if (!errorEl) return;
            const group = errorEl.closest("[data-field-group]");
            if (message) {
                errorEl.textContent = message;
                errorEl.hidden = false;
                if (group) group.classList.add("input-group--error");
            } else {
                errorEl.textContent = "";
                errorEl.hidden = true;
                if (group) group.classList.remove("input-group--error");
            }
        }

        function clearFieldErrors() {
            Object.keys(jobFieldErrors).forEach((field) => setFieldError(field, ""));
        }

        function filterSelectOptions(select, query) {
            if (!select) return;
            const normalized = (query || "").toString().toLowerCase().trim();
            Array.from(select.options).forEach((option, index) => {
                if (index === 0) {
                    option.hidden = false;
                    return;
                }
                const label = (option.dataset.label || option.textContent || "").toLowerCase();
                option.hidden = Boolean(normalized) && !label.includes(normalized);
            });
            if (!normalized) return;
            const selectedOption = select.selectedOptions[0];
            if (selectedOption && selectedOption.hidden) {
                select.value = "";
            }
        }

        function formatAssetLabel(asset) {
            if (!asset) return "";
            const parts = [];
            if (asset.code) parts.push(asset.code);
            if (asset.name) parts.push(asset.name);
            return parts.join(" — ") || asset.name || asset.code || "";
        }

        function formatPartLabel(part) {
            if (!part) return "";
            const parts = [];
            if (part.part_number) parts.push(part.part_number);
            if (part.name) parts.push(part.name);
            return parts.join(" — ") || part.name || part.part_number || "";
        }

        function sumCost(items) {
            if (!Array.isArray(items)) return 0;
            return items.reduce((total, item) => {
                const value = Number(item?.cost);
                if (!Number.isFinite(value)) {
                    return total;
                }
                return total + value;
            }, 0);
        }

        function deriveUnitCost(units, cost) {
            if (units == null || cost == null) return null;
            const quantity = Number.parseFloat(units);
            const numericCost = Number(cost);
            if (!Number.isFinite(quantity) || !Number.isFinite(numericCost) || quantity === 0) {
                return null;
            }
            return numericCost / quantity;
        }

        function formatNumber(value, { fallback = "—", minimumFractionDigits = 0, maximumFractionDigits = 2 } = {}) {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return fallback;
            }
            return number.toLocaleString(undefined, {
                minimumFractionDigits,
                maximumFractionDigits,
            });
        }

        function getJobCostSummary(job) {
            const materialsTotal = sumCost(job?.materials);
            const outsourcedTotal = sumCost(job?.outsourced_services);
            const internalTotal = sumCost(job?.internal_staff_costs);
            const combined = materialsTotal + outsourcedTotal + internalTotal;
            const totalCost = Number(job?.total_cost);
            return {
                materialsTotal,
                outsourcedTotal,
                internalTotal,
                combinedTotal: Number.isFinite(totalCost) ? totalCost : combined,
            };
        }

        const ACTIVE_ASSET_STATUSES = new Set(["operational", "active"]);

        function isAssetSelectable(asset) {
            if (!asset) return false;
            const statusRaw = typeof asset.status === "string" ? asset.status.trim() : "";
            if (!statusRaw) return true;
            return ACTIVE_ASSET_STATUSES.has(statusRaw.toLowerCase());
        }

        function populateMaintenanceAssetSelect({ ensureAsset } = {}) {
            if (!jobAssetSelect) return;
            const previousValue = jobAssetSelect.value;
            const searchQuery = jobAssetSearchInput?.value?.trim().toLowerCase() || "";

            jobAssetSelect.innerHTML = "";
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Select an asset";
            placeholder.dataset.label = "";
            jobAssetSelect.appendChild(placeholder);

            const selectableAssets = Array.isArray(assets)
                ? assets
                      .filter((asset) => isAssetSelectable(asset))
                      .sort((a, b) => (a.code || "").localeCompare(b.code || ""))
                : [];

            selectableAssets.forEach((asset) => {
                if (asset?.id == null) return;
                const option = document.createElement("option");
                option.value = String(asset.id);
                const label = formatAssetLabel(asset) || `Asset #${asset.id}`;
                option.textContent = label;
                option.dataset.label = label.toLowerCase();
                jobAssetSelect.appendChild(option);
            });

            const ensureCandidates = [];
            if (ensureAsset && ensureAsset.id != null) {
                ensureCandidates.push(ensureAsset);
            }
            if (previousValue && !jobAssetSelect.querySelector(`option[value="${previousValue}"]`)) {
                const assetFromList = assets.find((item) => String(item.id) === previousValue);
                if (assetFromList) {
                    ensureCandidates.push(assetFromList);
                } else if (currentMaintenanceJob?.asset && String(currentMaintenanceJob.asset.id) === previousValue) {
                    ensureCandidates.push(currentMaintenanceJob.asset);
                }
            }

            ensureCandidates.forEach((asset) => {
                const value = String(asset.id);
                if (!jobAssetSelect.querySelector(`option[value="${value}"]`)) {
                    const option = document.createElement("option");
                    option.value = value;
                    const label = formatAssetLabel(asset) || `Asset #${value}`;
                    option.textContent = label;
                    option.dataset.label = label.toLowerCase();
                    jobAssetSelect.appendChild(option);
                }
            });

            if (previousValue && jobAssetSelect.querySelector(`option[value="${previousValue}"]`)) {
                jobAssetSelect.value = previousValue;
            } else if (ensureCandidates.length) {
                jobAssetSelect.value = String(ensureCandidates[0].id);
            } else {
                jobAssetSelect.value = "";
            }

            if (searchQuery) {
                filterSelectOptions(jobAssetSelect, searchQuery);
            }
        }

        function normalizeMaintenancePart(part) {
            if (!part) return null;
            const id = part.id != null ? Number(part.id) : null;
            if (id == null || Number.isNaN(id)) return null;
            const assetId = part.asset_id != null ? Number(part.asset_id) : null;
            const partNumberRaw = part.part_number != null ? String(part.part_number).trim() : "";
            const partNameRaw = part.part_name || part.name || "";
            return {
                id,
                asset_id: Number.isNaN(assetId) ? null : assetId,
                part_number: partNumberRaw,
                part_name: partNameRaw,
                name: partNameRaw,
            };
        }

        function sortMaintenanceParts(a, b) {
            const numberA = (a.part_number || "").toLowerCase();
            const numberB = (b.part_number || "").toLowerCase();
            if (numberA && numberB && numberA !== numberB) {
                return numberA.localeCompare(numberB);
            }
            const nameA = (a.part_name || "").toLowerCase();
            const nameB = (b.part_name || "").toLowerCase();
            return nameA.localeCompare(nameB);
        }

        async function loadMaintenanceParts(force = false) {
            if (!force && maintenanceParts.length > 0) {
                return maintenanceParts.slice();
            }
            const requestId = ++maintenancePartsRequest;
            const parts = await fetchJson("/api/machines/parts");
            if (maintenancePartsRequest !== requestId) {
                return maintenanceParts.slice();
            }
            maintenanceParts = Array.isArray(parts)
                ? parts
                      .map((item) => normalizeMaintenancePart(item))
                      .filter(Boolean)
                      .sort(sortMaintenanceParts)
                : [];
            return maintenanceParts.slice();
        }

        function updatePartRequirement(assetId, parts) {
            const hasAsset = assetId != null && assetId !== "";
            const availableParts = Array.isArray(parts) ? parts.length : 0;
            isPartSelectionRequired = Boolean(hasAsset && availableParts > 0);
            if (partRequiredIndicator) {
                partRequiredIndicator.hidden = !isPartSelectionRequired;
            }
            if (!isPartSelectionRequired) {
                setFieldError("part_id", "");
            }
        }

        function updatePartHint(assetId, parts) {
            if (!jobPartHint) return;
            const hasAsset = assetId != null && assetId !== "";
            if (!hasAsset) {
                jobPartHint.textContent = "Select an asset to filter parts.";
                jobPartHint.hidden = false;
            } else if (!Array.isArray(parts) || parts.length === 0) {
                jobPartHint.textContent = "No CKD parts are registered for the selected asset.";
                jobPartHint.hidden = false;
            } else {
                jobPartHint.textContent = "";
                jobPartHint.hidden = true;
            }
        }

        function fillPartSelect(parts, { selectedValue = "", assetId = null } = {}) {
            if (!jobPartSelect) return;
            const searchQuery = jobPartSearchInput?.value?.trim().toLowerCase() || "";
            jobPartSelect.innerHTML = "";
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.dataset.label = "";
            if (Array.isArray(parts) && parts.length > 0) {
                placeholder.textContent = "Select a part";
            } else if (assetId) {
                placeholder.textContent = "No parts available for this asset";
            } else {
                placeholder.textContent = "No parts available";
            }
            jobPartSelect.appendChild(placeholder);

            (parts || []).forEach((part) => {
                if (!part) return;
                const option = document.createElement("option");
                option.value = String(part.id);
                const partNumber = part.part_number || "";
                const partName = part.part_name || part.name || "";
                option.textContent = partNumber ? `${partNumber} — ${partName}` : partName;
                option.dataset.label = option.textContent.toLowerCase();
                jobPartSelect.appendChild(option);
            });

            if (selectedValue && jobPartSelect.querySelector(`option[value="${selectedValue}"]`)) {
                jobPartSelect.value = String(selectedValue);
            } else {
                jobPartSelect.value = "";
            }

            if (searchQuery) {
                filterSelectOptions(jobPartSelect, searchQuery);
            }
        }

        async function refreshPartOptionsForAsset(assetId, { presetValue = "" } = {}) {
            if (!jobPartSelect) return;
            const requestId = ++latestPartFilterRequest;
            if (jobPartSearchInput) jobPartSearchInput.disabled = true;
            jobPartSelect.disabled = true;
            jobPartSelect.innerHTML = "";
            const loadingOption = document.createElement("option");
            loadingOption.value = "";
            loadingOption.textContent = "Loading parts…";
            loadingOption.dataset.label = "";
            jobPartSelect.appendChild(loadingOption);
            updatePartHint(assetId, []);
            setFieldError("part_id", "");

            try {
                const parts = await loadMaintenanceParts();
                if (latestPartFilterRequest !== requestId) return;
                const filteredParts = assetId
                    ? parts.filter((part) => String(part.asset_id) === String(assetId))
                    : parts.slice();
                fillPartSelect(filteredParts, { selectedValue: presetValue, assetId });
                updatePartRequirement(assetId, filteredParts);
                updatePartHint(assetId, filteredParts);
                const disableSelect = assetId ? filteredParts.length === 0 : parts.length === 0;
                jobPartSelect.disabled = disableSelect;
                if (jobPartSearchInput) {
                    jobPartSearchInput.disabled = disableSelect;
                }
            } catch (error) {
                if (latestPartFilterRequest !== requestId) return;
                jobPartSelect.innerHTML = "";
                const errorOption = document.createElement("option");
                errorOption.value = "";
                errorOption.textContent = "Unable to load parts";
                errorOption.dataset.label = "";
                jobPartSelect.appendChild(errorOption);
                jobPartSelect.disabled = true;
                if (jobPartSearchInput) jobPartSearchInput.disabled = true;
                updatePartRequirement(null, []);
                updatePartHint(null, []);
                setFieldError("part_id", error.message || "Unable to load CKD parts.");
            }
        }

        function buildIdleSummaryCacheKey(monthKey, machineCodes) {
            const month = typeof monthKey === "string" ? monthKey.slice(0, 7) : "";
            if (!month) {
                return null;
            }
            const codes = normalizeMachineCodes(machineCodes || []);
            codes.sort((a, b) => a.localeCompare(b));
            return `${month}|${codes.join(",")}`;
        }

        function invalidateIdleSummaryCache(monthKey, machineCodes) {
            if (!(idleSummaryCache instanceof Map)) {
                return;
            }
            if (!monthKey) {
                idleSummaryCache.clear();
                return;
            }
            const cacheKey = buildIdleSummaryCacheKey(monthKey, machineCodes);
            if (cacheKey) {
                idleSummaryCache.delete(cacheKey);
            }
        }

        const IDLE_SHIFT_START = "07:00";
        const IDLE_SHIFT_END = "19:00";

        function getSecondaryReasonOptions(primaryReason) {
            const key = (primaryReason || "").trim();
            return SECONDARY_IDLE_REASON_MAP[key] || [];
        }

        function requiresSecondaryReason(primaryReason) {
            return getSecondaryReasonOptions(primaryReason).length > 0;
        }

        function updateSecondaryReasonField(selectedValue) {
            if (!idleSecondaryReasonSelect || !idleSecondaryReasonGroup) {
                return;
            }

            const options = getSecondaryReasonOptions(idleReasonSelect?.value || "");
            const previousSelection =
                selectedValue !== undefined ? selectedValue : idleSecondaryReasonSelect.value;

            idleSecondaryReasonSelect.innerHTML = "";

            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = options.length > 0 ? "Select secondary reason" : "No secondary reason";
            idleSecondaryReasonSelect.appendChild(placeholder);

            options.forEach((label) => {
                const option = document.createElement("option");
                option.value = label;
                option.textContent = label;
                idleSecondaryReasonSelect.appendChild(option);
            });

            if (options.length > 0) {
                idleSecondaryReasonGroup.hidden = false;
                const isEnabled = canLogIdle;
                idleSecondaryReasonSelect.disabled = !isEnabled;
                idleSecondaryReasonSelect.required = isEnabled;
                if (idleSecondaryRequiredIndicator) {
                    idleSecondaryRequiredIndicator.hidden = false;
                }

                if (options.includes(previousSelection)) {
                    idleSecondaryReasonSelect.value = previousSelection;
                } else {
                    idleSecondaryReasonSelect.value = "";
                }
            } else {
                idleSecondaryReasonGroup.hidden = true;
                idleSecondaryReasonSelect.disabled = true;
                idleSecondaryReasonSelect.required = false;
                idleSecondaryReasonSelect.value = "";
                if (idleSecondaryRequiredIndicator) {
                    idleSecondaryRequiredIndicator.hidden = true;
                }
            }
        }

        const DEFAULT_PARTS_EMPTY_MESSAGE = assetPartsEmptyMessage?.textContent?.trim() ||
            "No parts have been registered for this asset yet.";
        const FILTERED_PARTS_EMPTY_MESSAGE = "No parts match your search.";

        if (!canManageAssets) {
            if (assetFormNotice) {
                assetFormNotice.textContent = "Only Production Managers or Admins can add assets.";
                assetFormNotice.hidden = false;
            }
            if (assetForm) {
                assetForm.querySelectorAll("input, textarea, button").forEach((element) => {
                    element.disabled = true;
                });
            }
        }

        if (!canManageParts) {
            if (assetPartForm) {
                assetPartForm.querySelectorAll("input, textarea, button").forEach((element) => {
                    element.disabled = true;
                });
            }
            if (assetPartError) {
                assetPartError.textContent = "Only authorised maintenance roles can add parts or log replacements.";
                assetPartError.hidden = false;
            }
        }

        if (assetPartSearchInput) {
            assetPartSearchInput.addEventListener("input", () => {
                renderFilteredParts();
            });
            assetPartSearchInput.addEventListener("search", () => {
                renderFilteredParts();
            });
        }

        function setProductionFieldsDisabled(disabled) {
            if (!productionSection) return;
            productionSection.querySelectorAll("input, textarea, select").forEach((element) => {
                if (element) element.disabled = disabled;
            });
            if (submitToMaintenanceButton) {
                submitToMaintenanceButton.disabled = disabled || !canManageProductionJobs;
            }
            if (resetJobFormButton) {
                resetJobFormButton.disabled = !canManageProductionJobs;
            }
        }

        function setMaintenanceFieldsDisabled(disabled) {
            if (!maintenanceSection) return;
            maintenanceSection.querySelectorAll("input, textarea, select").forEach((element) => {
                if (element) element.disabled = disabled;
            });
            if (addMaterialRowButton) addMaterialRowButton.disabled = disabled || !canManageMaintenanceJobs;
            if (removeMaterialRowButton) removeMaterialRowButton.disabled = disabled || !canManageMaintenanceJobs;
            if (addOutsourcedRowButton) addOutsourcedRowButton.disabled = disabled || !canManageMaintenanceJobs;
            if (removeOutsourcedRowButton) removeOutsourcedRowButton.disabled = disabled || !canManageMaintenanceJobs;
            if (addInternalStaffRowButton) addInternalStaffRowButton.disabled = disabled || !canManageMaintenanceJobs;
            if (removeInternalStaffRowButton) removeInternalStaffRowButton.disabled = disabled || !canManageMaintenanceJobs;
            if (submitToProductionButton) {
                submitToProductionButton.disabled = disabled || !canManageMaintenanceJobs;
            }
        }

        if (!canManageProductionJobs && creationNotice) {
            creationNotice.textContent = "Only Production Managers can submit new maintenance jobs.";
            creationNotice.hidden = false;
        }

        if (!canManageProductionJobs) {
            setProductionFieldsDisabled(true);
        }

        if (!canManageMaintenanceJobs) {
            setMaintenanceFieldsDisabled(true);
        }

        function hideJobAlerts() {
            if (creationSuccess) creationSuccess.hidden = true;
            if (creationWarning) creationWarning.hidden = true;
            if (maintenanceSuccess) maintenanceSuccess.hidden = true;
            if (maintenanceWarning) maintenanceWarning.hidden = true;
            if (creationError) creationError.hidden = true;
        }

        function showSuccess(alertEl, message) {
            if (!alertEl) return;
            alertEl.textContent = message;
            alertEl.hidden = false;
        }

        function showWarning(alertEl, message) {
            if (!alertEl) return;
            alertEl.textContent = message;
            alertEl.hidden = false;
        }

        function showError(message) {
            if (!creationError) return;
            creationError.textContent = message;
            creationError.hidden = false;
        }

        function clearTableBody(body) {
            if (!body) return;
            while (body.firstChild) {
                body.removeChild(body.firstChild);
            }
        }

        function getSupplierLabel(supplier) {
            if (!supplier) return "";
            const name = supplier.name || "";
            const contact = supplier.contact_person?.trim();
            return contact ? `${name} — ${contact}` : name;
        }

        function fillSupplierSelectOptions(select, { selectedValue = "", fallbackLabel = "" } = {}) {
            if (!select) return;
            const hasSuppliers = Array.isArray(serviceSuppliers) && serviceSuppliers.length > 0;
            const previousValue = selectedValue ? String(selectedValue) : "";
            select.innerHTML = "";

            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = hasSuppliers ? "Select outsourced party" : "No suppliers available";
            select.appendChild(placeholder);

            if (hasSuppliers) {
                serviceSuppliers.forEach((supplier) => {
                    if (!supplier) return;
                    const option = document.createElement("option");
                    option.value = String(supplier.id);
                    option.textContent = getSupplierLabel(supplier);
                    select.appendChild(option);
                });
            }

            if (previousValue) {
                if (!select.querySelector(`option[value="${previousValue}"]`) && fallbackLabel) {
                    const fallbackOption = document.createElement("option");
                    fallbackOption.value = previousValue;
                    fallbackOption.textContent = fallbackLabel;
                    fallbackOption.dataset.fallback = "true";
                    select.appendChild(fallbackOption);
                }
                select.value = previousValue;
                const selectedOption = select.options[select.selectedIndex];
                const labelText = selectedOption ? selectedOption.textContent : fallbackLabel;
                select.dataset.fallbackLabel = labelText || fallbackLabel || "";
            } else {
                select.value = "";
                select.dataset.fallbackLabel = "";
            }

            select.disabled = !hasSuppliers;
            if (select.disabled) {
                select.value = "";
                select.dataset.fallbackLabel = "";
            }
        }

        function updateOutsourcedSupplierOptions() {
            if (!outsourcedTableBody) return;
            outsourcedTableBody
                .querySelectorAll("select[data-outsourced-party]")
                .forEach((select) => {
                    const fallbackLabel = select.dataset.fallbackLabel || "";
                    fillSupplierSelectOptions(select, {
                        selectedValue: select.value,
                        fallbackLabel,
                    });
                });
        }

        function applyOutsourcedDateConstraints(input) {
            if (!input) return;
            const minDate = jobStartInput?.value || "";
            const maxDate = jobFinishInput?.value || "";
            input.min = minDate;
            input.max = maxDate;
        }

        function updateOutsourcedDateConstraints() {
            if (!outsourcedTableBody) return;
            outsourcedTableBody.querySelectorAll('input[type="date"]').forEach((input) => {
                applyOutsourcedDateConstraints(input);
            });
        }

        function applyInternalStaffDateConstraints(input) {
            if (!input) return;
            const minDate = jobStartInput?.value || "";
            const maxDate = jobFinishInput?.value || "";
            input.min = minDate;
            input.max = maxDate;
        }

        function updateInternalStaffDateConstraints() {
            if (!internalStaffTableBody) return;
            internalStaffTableBody.querySelectorAll('input[type="date"]').forEach((input) => {
                applyInternalStaffDateConstraints(input);
            });
        }

        function getEmployeeLabel(employee) {
            if (!employee) return "";
            const code =
                employee.regNumber ||
                employee.reg_number ||
                employee.reg_no ||
                employee.employee_code ||
                employee.code ||
                "";
            const name =
                employee.name ||
                employee.full_name ||
                employee.fullName ||
                employee.employee_name ||
                "";
            const parts = [];
            if (code) parts.push(code);
            if (name) parts.push(name);
            return parts.join(" — ");
        }

        function fillEmployeeSelectOptions(select, { selectedValue = "", fallbackLabel = "" } = {}) {
            if (!select) return;
            const hasEmployees = Array.isArray(activeEmployees) && activeEmployees.length > 0;
            const previousValue = selectedValue ? String(selectedValue) : "";
            select.innerHTML = "";

            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = hasEmployees
                ? "Select employee"
                : "No active employees available";
            select.appendChild(placeholder);

            if (hasEmployees) {
                activeEmployees.forEach((employee) => {
                    if (!employee) return;
                    const option = document.createElement("option");
                    option.value = String(employee.id);
                    option.textContent = getEmployeeLabel(employee) || employee.name || employee.id;
                    select.appendChild(option);
                });
            }

            if (previousValue) {
                if (!select.querySelector(`option[value="${previousValue}"]`) && fallbackLabel) {
                    const fallbackOption = document.createElement("option");
                    fallbackOption.value = previousValue;
                    fallbackOption.textContent = fallbackLabel;
                    fallbackOption.dataset.fallback = "true";
                    select.appendChild(fallbackOption);
                }
                select.value = previousValue;
                const selectedOption = select.options[select.selectedIndex];
                const labelText = selectedOption ? selectedOption.textContent : fallbackLabel;
                select.dataset.fallbackLabel = labelText || fallbackLabel || "";
            } else {
                select.value = "";
                select.dataset.fallbackLabel = "";
            }

            select.disabled = !hasEmployees;
            if (select.disabled) {
                if (previousValue && fallbackLabel) {
                    select.value = previousValue;
                    select.dataset.fallbackLabel = fallbackLabel;
                } else {
                    select.value = "";
                    select.dataset.fallbackLabel = "";
                }
            }
        }

        function updateInternalStaffEmployeeOptions() {
            if (!internalStaffTableBody) return;
            internalStaffTableBody
                .querySelectorAll("select[data-internal-employee]")
                .forEach((select) => {
                    const fallbackLabel = select.dataset.fallbackLabel || "";
                    fillEmployeeSelectOptions(select, {
                        selectedValue: select.value,
                        fallbackLabel,
                    });
                });
        }

        function updateInternalStaffRowCost(row) {
            if (!row) return;
            const hoursInput = row.querySelector('td:nth-child(4) input');
            const rateInput = row.querySelector('td:nth-child(5) input');
            const costInput = row.querySelector('input[data-internal-cost]');
            if (!hoursInput || !rateInput || !costInput) return;
            const hoursValue = hoursInput.value;
            const rateValue = rateInput.value;
            const hoursNumber = Number(hoursValue);
            const rateNumber = Number(rateValue);
            if (
                hoursValue !== ""
                && rateValue !== ""
                && Number.isFinite(hoursNumber)
                && Number.isFinite(rateNumber)
            ) {
                const computed = hoursNumber * rateNumber;
                if (Number.isFinite(computed)) {
                    costInput.value = computed.toFixed(2);
                }
            }
        }

        function addInternalStaffRow(entry = {}) {
            if (!internalStaffTableBody) return;
            const row = document.createElement("tr");

            const employeeCell = document.createElement("td");
            const employeeSelect = document.createElement("select");
            employeeSelect.required = true;
            employeeSelect.dataset.internalEmployee = "true";
            const employeeIdValue =
                entry.employee_id != null
                    ? String(entry.employee_id)
                    : entry.employee?.id != null
                        ? String(entry.employee.id)
                        : "";
            const fallbackEmployee =
                entry.employee ||
                (entry.employee_code || entry.employee_name
                    ? { employee_code: entry.employee_code, employee_name: entry.employee_name }
                    : null);
            const employeeLabel = getEmployeeLabel(fallbackEmployee) || "";
            employeeSelect.dataset.fallbackLabel = employeeLabel;
            fillEmployeeSelectOptions(employeeSelect, {
                selectedValue: employeeIdValue,
                fallbackLabel: employeeLabel,
            });
            employeeSelect.addEventListener("change", () => {
                hideJobAlerts();
                const selectedOption = employeeSelect.options[employeeSelect.selectedIndex];
                employeeSelect.dataset.fallbackLabel = selectedOption ? selectedOption.textContent : "";
            });
            employeeCell.appendChild(employeeSelect);

            const dateCell = document.createElement("td");
            const dateInput = document.createElement("input");
            dateInput.type = "date";
            dateInput.required = true;
            if (entry.service_date) {
                dateInput.value = entry.service_date;
            } else if (todayDateString) {
                dateInput.value = todayDateString;
            }
            applyInternalStaffDateConstraints(dateInput);
            dateInput.addEventListener("change", () => {
                hideJobAlerts();
            });
            dateCell.appendChild(dateInput);

            const descriptionCell = document.createElement("td");
            const descriptionInput = document.createElement("input");
            descriptionInput.type = "text";
            descriptionInput.placeholder = "e.g., Bearing replacement | Oil pump service";
            descriptionInput.required = true;
            if (entry.work_description) {
                descriptionInput.value = entry.work_description;
            }
            descriptionInput.addEventListener("input", () => {
                hideJobAlerts();
            });
            descriptionCell.appendChild(descriptionInput);

            const hoursCell = document.createElement("td");
            const hoursInput = document.createElement("input");
            hoursInput.type = "number";
            hoursInput.min = "0";
            hoursInput.step = "0.5";
            hoursInput.placeholder = "0";
            if (entry.engaged_hours != null) {
                hoursInput.value = entry.engaged_hours;
            }
            hoursInput.addEventListener("input", () => {
                hideJobAlerts();
                updateInternalStaffRowCost(row);
                updateInternalStaffTotal();
            });
            hoursCell.appendChild(hoursInput);

            const rateCell = document.createElement("td");
            const rateInput = document.createElement("input");
            rateInput.type = "number";
            rateInput.min = "0";
            rateInput.step = "0.01";
            rateInput.placeholder = "0.00";
            if (entry.hourly_rate != null) {
                rateInput.value = entry.hourly_rate;
            }
            rateInput.addEventListener("input", () => {
                hideJobAlerts();
                updateInternalStaffRowCost(row);
                updateInternalStaffTotal();
            });
            rateCell.appendChild(rateInput);

            const costCell = document.createElement("td");
            const costInput = document.createElement("input");
            costInput.type = "number";
            costInput.min = "0";
            costInput.step = "0.01";
            costInput.placeholder = "0.00";
            costInput.dataset.internalCost = "true";
            if (entry.cost != null) {
                costInput.value = entry.cost;
            }
            costInput.addEventListener("input", () => {
                hideJobAlerts();
                updateInternalStaffTotal();
            });
            costCell.appendChild(costInput);

            row.appendChild(employeeCell);
            row.appendChild(dateCell);
            row.appendChild(descriptionCell);
            row.appendChild(hoursCell);
            row.appendChild(rateCell);
            row.appendChild(costCell);

            internalStaffTableBody.appendChild(row);
            updateInternalStaffRowCost(row);
            updateInternalStaffTotal();
        }

        function updateInternalStaffTotal() {
            if (!internalStaffTableBody || !internalStaffTotalEl) return;
            let total = 0;
            internalStaffTableBody.querySelectorAll("input[data-internal-cost]").forEach((input) => {
                const value = parseFloat(input.value);
                if (!Number.isNaN(value)) {
                    total += value;
                }
            });
            internalStaffTotalEl.textContent = total.toFixed(2);
        }

        function setInternalStaffCosts(costs = []) {
            clearTableBody(internalStaffTableBody);
            if (!costs || costs.length === 0) {
                addInternalStaffRow({});
            } else {
                costs.forEach((cost) => addInternalStaffRow(cost));
            }
            updateInternalStaffDateConstraints();
            updateInternalStaffEmployeeOptions();
            updateInternalStaffTotal();
        }

        function gatherInternalStaffCosts() {
            if (!internalStaffTableBody) return [];
            const costs = [];
            const startDateValue = jobStartInput?.value || "";
            const finishDateValue = jobFinishInput?.value || "";
            const startDate = parseDateOnly(startDateValue);
            const finishDate = parseDateOnly(finishDateValue);

            const rows = internalStaffTableBody.querySelectorAll("tr");
            rows.forEach((row, index) => {
                const employeeSelect = row.querySelector("select[data-internal-employee]");
                const dateInput = row.querySelector('input[type="date"]');
                const descriptionInput = row.querySelector('td:nth-child(3) input');
                const hoursInput = row.querySelector('td:nth-child(4) input');
                const rateInput = row.querySelector('td:nth-child(5) input');
                const costInput = row.querySelector('td:nth-child(6) input');

                const employeeValue = employeeSelect?.value?.trim() || "";
                const dateValue = dateInput?.value || "";
                const descriptionValue = descriptionInput?.value?.trim() || "";
                const hoursValue = hoursInput?.value || "";
                const rateValue = rateInput?.value || "";
                const costValue = costInput?.value || "";

                if (
                    !employeeValue
                    && !descriptionValue
                    && !hoursValue
                    && !rateValue
                    && !costValue
                ) {
                    return;
                }

                const rowNumber = index + 1;

                if (!employeeValue) {
                    throw new Error(`Select an employee for row ${rowNumber}.`);
                }

                const employeeIdNumber = Number(employeeValue);
                if (!Number.isFinite(employeeIdNumber) || employeeIdNumber <= 0) {
                    throw new Error(`Select a valid employee for row ${rowNumber}.`);
                }

                if (!dateValue) {
                    throw new Error(`Select a service date for row ${rowNumber}.`);
                }

                const serviceDate = parseDateOnly(dateValue);
                if (!serviceDate) {
                    throw new Error(`Enter a valid service date for row ${rowNumber}.`);
                }
                if (startDate && serviceDate < startDate) {
                    throw new Error(`Service date in row ${rowNumber} cannot be before the job started date.`);
                }
                if (finishDate && serviceDate > finishDate) {
                    throw new Error(`Service date in row ${rowNumber} cannot be after the job finished date.`);
                }

                if (!descriptionValue) {
                    throw new Error(`Enter a work description for row ${rowNumber}.`);
                }

                let engagedHours = null;
                if (hoursValue !== "") {
                    const hoursNumber = Number(hoursValue);
                    if (!Number.isFinite(hoursNumber) || hoursNumber < 0) {
                        throw new Error(`Engaged hours in row ${rowNumber} must be zero or more.`);
                    }
                    engagedHours = hoursNumber;
                }

                let hourlyRate = null;
                if (rateValue !== "") {
                    const rateNumber = Number(rateValue);
                    if (!Number.isFinite(rateNumber) || rateNumber < 0) {
                        throw new Error(`Hourly rate in row ${rowNumber} must be zero or more.`);
                    }
                    hourlyRate = rateNumber;
                }

                if (costValue === "") {
                    throw new Error(`Enter a cost for row ${rowNumber}.`);
                }
                const costNumber = Number(costValue);
                if (!Number.isFinite(costNumber) || costNumber < 0) {
                    throw new Error(`Cost in row ${rowNumber} must be zero or more.`);
                }

                costs.push({
                    employee_id: employeeIdNumber,
                    service_date: dateValue,
                    work_description: descriptionValue,
                    engaged_hours: engagedHours,
                    hourly_rate: hourlyRate,
                    cost: costNumber,
                });
            });

            return costs;
        }

        function addOutsourcedRow(service = {}) {
            if (!outsourcedTableBody) return;
            const row = document.createElement("tr");

            const supplierCell = document.createElement("td");
            const supplierSelect = document.createElement("select");
            supplierSelect.required = true;
            supplierSelect.dataset.outsourcedParty = "true";
            const supplierIdValue =
                service.supplier_id != null
                    ? String(service.supplier_id)
                    : service.supplier?.id != null
                        ? String(service.supplier.id)
                        : "";
            const supplierLabel = service.supplier ? getSupplierLabel(service.supplier) : "";
            supplierSelect.dataset.fallbackLabel = supplierLabel;
            fillSupplierSelectOptions(supplierSelect, {
                selectedValue: supplierIdValue,
                fallbackLabel: supplierLabel,
            });
            supplierSelect.addEventListener("change", () => {
                hideJobAlerts();
                const selectedOption = supplierSelect.options[supplierSelect.selectedIndex];
                supplierSelect.dataset.fallbackLabel = selectedOption ? selectedOption.textContent : "";
            });
            supplierCell.appendChild(supplierSelect);

            const dateCell = document.createElement("td");
            const dateInput = document.createElement("input");
            dateInput.type = "date";
            dateInput.required = true;
            if (service.service_date) {
                dateInput.value = service.service_date;
            }
            applyOutsourcedDateConstraints(dateInput);
            dateInput.addEventListener("change", () => {
                hideJobAlerts();
            });
            dateCell.appendChild(dateInput);

            const descriptionCell = document.createElement("td");
            const descriptionInput = document.createElement("input");
            descriptionInput.type = "text";
            descriptionInput.placeholder = "e.g., Bearing housing machining";
            descriptionInput.required = true;
            if (service.service_description) {
                descriptionInput.value = service.service_description;
            }
            descriptionInput.addEventListener("input", () => {
                hideJobAlerts();
            });
            descriptionCell.appendChild(descriptionInput);

            const hoursCell = document.createElement("td");
            const hoursInput = document.createElement("input");
            hoursInput.type = "number";
            hoursInput.min = "0";
            hoursInput.step = "0.5";
            if (service.engaged_hours != null && service.engaged_hours !== "") {
                hoursInput.value = service.engaged_hours;
            }
            hoursInput.addEventListener("input", () => {
                hideJobAlerts();
            });
            hoursCell.appendChild(hoursInput);

            const costCell = document.createElement("td");
            const costInput = document.createElement("input");
            costInput.type = "number";
            costInput.min = "0";
            costInput.step = "0.01";
            costInput.required = true;
            costInput.placeholder = "0.00";
            costInput.dataset.outsourcedCost = "true";
            if (service.cost != null && service.cost !== "") {
                costInput.value = service.cost;
            }
            costInput.addEventListener("input", () => {
                hideJobAlerts();
                updateOutsourcedTotal();
            });
            costCell.appendChild(costInput);

            [supplierSelect, dateInput, descriptionInput, hoursInput].forEach((input) => {
                input.addEventListener("input", () => {
                    hideJobAlerts();
                });
            });

            row.appendChild(supplierCell);
            row.appendChild(dateCell);
            row.appendChild(descriptionCell);
            row.appendChild(hoursCell);
            row.appendChild(costCell);
            outsourcedTableBody.appendChild(row);
        }

        function updateOutsourcedTotal() {
            if (!outsourcedTableBody || !outsourcedTotalEl) return;
            let total = 0;
            outsourcedTableBody.querySelectorAll("input[data-outsourced-cost]").forEach((input) => {
                const value = parseFloat(input.value);
                if (!Number.isNaN(value)) {
                    total += value;
                }
            });
            outsourcedTotalEl.textContent = total.toFixed(2);
        }

        function setOutsourcedServices(services = []) {
            clearTableBody(outsourcedTableBody);
            if (!services || services.length === 0) {
                addOutsourcedRow();
            } else {
                services.forEach((service) => addOutsourcedRow(service));
            }
            updateOutsourcedDateConstraints();
            updateOutsourcedTotal();
        }

        function parseDateOnly(value) {
            if (!value) return null;
            const parsed = new Date(`${value}T00:00:00`);
            if (Number.isNaN(parsed.getTime())) {
                return null;
            }
            return parsed;
        }

        function gatherOutsourcedServices() {
            if (!outsourcedTableBody) return [];
            const services = [];
            const startDateValue = jobStartInput?.value || "";
            const finishDateValue = jobFinishInput?.value || "";
            const startDate = parseDateOnly(startDateValue);
            const finishDate = parseDateOnly(finishDateValue);

            const rows = outsourcedTableBody.querySelectorAll("tr");
            rows.forEach((row, index) => {
                const supplierSelect = row.querySelector("select[data-outsourced-party]");
                const dateInput = row.querySelector('input[type="date"]');
                const descriptionInput = row.querySelector('td:nth-child(3) input');
                const hoursInput = row.querySelector('td:nth-child(4) input');
                const costInput = row.querySelector('td:nth-child(5) input');

                const supplierValue = supplierSelect?.value?.trim() || "";
                const dateValue = dateInput?.value || "";
                const descriptionValue = descriptionInput?.value?.trim() || "";
                const hoursValue = hoursInput?.value || "";
                const costValue = costInput?.value || "";

                if (!supplierValue && !dateValue && !descriptionValue && !hoursValue && !costValue) {
                    return;
                }

                const rowNumber = index + 1;

                if (!supplierValue) {
                    throw new Error(`Select an outsourced party for row ${rowNumber}.`);
                }

                if (!dateValue) {
                    throw new Error(`Select a service date for row ${rowNumber}.`);
                }

                const serviceDate = parseDateOnly(dateValue);
                if (!serviceDate) {
                    throw new Error(`Enter a valid service date for row ${rowNumber}.`);
                }
                if (startDate && serviceDate < startDate) {
                    throw new Error(`Service date in row ${rowNumber} cannot be before the job started date.`);
                }
                if (finishDate && serviceDate > finishDate) {
                    throw new Error(`Service date in row ${rowNumber} cannot be after the job finished date.`);
                }

                if (!descriptionValue) {
                    throw new Error(`Enter a service description for row ${rowNumber}.`);
                }

                if (costValue === "") {
                    throw new Error(`Enter a cost for row ${rowNumber}.`);
                }
                const costNumber = Number(costValue);
                if (!Number.isFinite(costNumber) || costNumber < 0) {
                    throw new Error(`Enter a valid non-negative cost for row ${rowNumber}.`);
                }

                let engagedHours = null;
                if (hoursValue !== "") {
                    const hoursNumber = Number(hoursValue);
                    if (!Number.isFinite(hoursNumber) || hoursNumber < 0) {
                        throw new Error(`Engaged hours in row ${rowNumber} must be zero or more.`);
                    }
                    engagedHours = hoursNumber;
                }

                services.push({
                    supplier_id: Number(supplierValue),
                    service_date: dateValue,
                    service_description: descriptionValue,
                    engaged_hours: engagedHours,
                    cost: costNumber,
                });
            });

            return services;
        }

        function addMaterialRow(material = {}) {
            if (!materialsTableBody) return;
            const row = document.createElement("tr");

            const nameCell = document.createElement("td");
            const nameInput = document.createElement("input");
            nameInput.type = "text";
            nameInput.placeholder = "Bearing";
            nameInput.value = material.material_name || "";
            nameCell.appendChild(nameInput);

            const unitCell = document.createElement("td");
            const unitInput = document.createElement("input");
            unitInput.type = "text";
            unitInput.placeholder = "2 pcs";
            unitInput.value = material.units || "";
            unitCell.appendChild(unitInput);

            const costCell = document.createElement("td");
            const costInput = document.createElement("input");
            costInput.type = "number";
            costInput.step = "0.01";
            costInput.min = "0";
            costInput.placeholder = "0.00";
            costInput.value = material.cost != null ? material.cost : "";
            costCell.appendChild(costInput);

            [nameInput, unitInput, costInput].forEach((input) => {
                input.addEventListener("input", () => {
                    hideJobAlerts();
                    updateMaterialsTotal();
                });
            });

            row.appendChild(nameCell);
            row.appendChild(unitCell);
            row.appendChild(costCell);
            materialsTableBody.appendChild(row);
        }

        function updateMaterialsTotal() {
            if (!materialsTableBody || !materialsTotalEl) return;
            let total = 0;
            materialsTableBody.querySelectorAll("input[type='number']").forEach((input) => {
                const value = parseFloat(input.value);
                if (!Number.isNaN(value)) {
                    total += value;
                }
            });
            materialsTotalEl.textContent = total.toFixed(2);
        }

        function setMaterials(materials = []) {
            clearTableBody(materialsTableBody);
            if (!materials || materials.length === 0) {
                addMaterialRow();
            } else {
                materials.forEach((material) => addMaterialRow(material));
            }
            updateMaterialsTotal();
        }

        function gatherMaterials() {
            if (!materialsTableBody) return [];
            const materials = [];
            materialsTableBody.querySelectorAll("tr").forEach((row) => {
                const inputs = row.querySelectorAll("input");
                if (!inputs.length) return;
                const [nameInput, unitsInput, costInput] = inputs;
                const name = nameInput.value.trim();
                const units = unitsInput.value.trim();
                const costRaw = costInput.value;
                const cost = costRaw === "" ? null : Number(costRaw);
                if (costRaw !== "" && Number.isNaN(cost)) {
                    throw new Error(`Invalid cost value in materials table${name ? ` for "${name}"` : ""}.`);
                }
                if (!name && cost === null && !units) return;
                materials.push({
                    material_name: name,
                    units: units || null,
                    cost,
                });
            });
            return materials;
        }

        function populateSelect(select, value) {
            if (!select) return;
            if (value && !Array.from(select.options).some((option) => option.value === value)) {
                const option = document.createElement("option");
                option.value = value;
                option.textContent = value;
                select.appendChild(option);
            }
            select.value = value || "";
        }

        function setSelectedRowHighlight() {
            if (!jobsTableBody) return;
            jobsTableBody.querySelectorAll("tr").forEach((row) => {
                if (Number(row.dataset.jobId) === Number(selectedJobId)) {
                    row.classList.add("is-selected");
                } else {
                    row.classList.remove("is-selected");
                }
            });
        }

        function populateJobForm(job) {
            currentMaintenanceJob = job || null;
            clearFieldErrors();
            if (!job) {
                if (jobIdInput) jobIdInput.value = "";
                if (jobCodeInput) jobCodeInput.value = "";
                if (jobCategorySelect) jobCategorySelect.value = "";
                if (jobDateInput) jobDateInput.value = "";
                if (jobExpectedInput) jobExpectedInput.value = "";
                if (jobDescriptionInput) jobDescriptionInput.value = "";
                if (maintenanceEmailInput) maintenanceEmailInput.value = "";
                if (productionEmailInput) productionEmailInput.value = user?.email || "";
                if (jobStartInput) jobStartInput.value = "";
                if (jobFinishInput) jobFinishInput.value = "";
                if (maintenanceNotesInput) maintenanceNotesInput.value = "";
                if (jobAssetSelect) jobAssetSelect.value = "";
                if (jobAssetSearchInput) jobAssetSearchInput.value = "";
                if (jobPartSelect) jobPartSelect.value = "";
                if (jobPartSearchInput) jobPartSearchInput.value = "";
                populateMaintenanceAssetSelect();
                Promise.resolve(refreshPartOptionsForAsset(null, { presetValue: "" })).catch(() => {});
                setMaterials([]);
                updateMaterialsTotal();
                setOutsourcedServices([]);
                setInternalStaffCosts([]);
                if (canManageMaintenanceJobs) {
                    setMaintenanceFieldsDisabled(true);
                }
                updatePartRequirement(null, []);
                updatePartHint(null, []);
                return;
            }

            if (jobIdInput) jobIdInput.value = job.id || "";
            if (jobCodeInput) jobCodeInput.value = job.job_code || "";
            if (jobDateInput && job.job_date) jobDateInput.value = job.job_date;
            if (jobCategorySelect) {
                jobCategorySelect.value = job.job_category || job.title || "";
            }
            populateSelect(jobPrioritySelect, job.priority || "Normal");
            populateSelect(jobLocationSelect, job.location || "");
            if (jobExpectedInput) jobExpectedInput.value = job.expected_completion || "";
            if (jobDescriptionInput) jobDescriptionInput.value = job.description || "";
            if (maintenanceEmailInput) maintenanceEmailInput.value = job.maint_email || "";
            if (productionEmailInput) {
                productionEmailInput.value = job.prod_email || user?.email || "";
            }
            if (jobStartInput) jobStartInput.value = job.job_started_date || "";
            if (jobFinishInput) jobFinishInput.value = job.job_finished_date || "";
            if (maintenanceNotesInput) maintenanceNotesInput.value = job.maintenance_notes || "";
            const assetIdValue = job.asset_id != null ? String(job.asset_id) : "";
            const assetForSelect = job.asset && job.asset.id != null ? job.asset : assetIdValue ? { id: Number(assetIdValue), code: job.asset?.code, name: job.asset?.name } : null;
            populateMaintenanceAssetSelect({ ensureAsset: assetForSelect });
            if (jobAssetSelect) {
                jobAssetSelect.value = assetIdValue;
            }
            if (jobAssetSearchInput) jobAssetSearchInput.value = "";
            const partIdValue = job.part_id != null ? String(job.part_id) : "";
            if (jobPartSearchInput) jobPartSearchInput.value = "";
            Promise.resolve(
                refreshPartOptionsForAsset(assetIdValue || null, { presetValue: partIdValue })
            ).catch(() => {});
            setMaterials(job.materials || []);
            updateMaterialsTotal();
            setOutsourcedServices(job.outsourced_services || []);
            setInternalStaffCosts(job.internal_staff_costs || []);
        }

        function syncSectionState(job) {
            const productionLocked = !canManageProductionJobs || (job && job.prod_submitted_at);
            const maintenanceLocked = !canManageMaintenanceJobs || !job || job.status === "COMPLETED";

            setProductionFieldsDisabled(productionLocked);
            setMaintenanceFieldsDisabled(maintenanceLocked);

            if (!job && canManageProductionJobs) {
                setProductionFieldsDisabled(false);
            }
        }

        async function loadJob(jobId) {
            if (!jobId) return;
            hideJobAlerts();
            try {
                const job = await fetchJson(`/api/maintenance-jobs/${jobId}`);
                const cacheKey = Number.isFinite(Number(jobId)) ? Number(jobId) : jobId;
                jobDetailsCache.set(cacheKey, job);
                populateJobForm(job);
                syncSectionState(job);
            } catch (error) {
                showError(error.message || "Unable to load job details.");
            }
        }

        async function selectJob(jobId) {
            selectedJobId = jobId;
            setSelectedRowHighlight();
            await loadJob(jobId);
        }

        function prepareNewJobForm() {
            selectedJobId = null;
            setSelectedRowHighlight();
            populateJobForm(null);
            hideJobAlerts();
            if (!canManageProductionJobs) return;
            const today = new Date();
            const iso = today.toISOString().slice(0, 10);
            if (jobDateInput) jobDateInput.value = iso;
            if (jobPrioritySelect) jobPrioritySelect.value = "Normal";
            if (jobLocationSelect) jobLocationSelect.value = "";
            setMaterials([]);
            setProductionFieldsDisabled(false);
            setMaintenanceFieldsDisabled(true);
            setInternalStaffCosts([]);
            if (productionEmailInput) productionEmailInput.value = user?.email || "";
            fetchNextJobCode();
        }

        async function fetchNextJobCode() {
            if (!canManageProductionJobs || !jobCodeInput) return;
            try {
                jobCodeInput.value = "";
                jobCodeInput.placeholder = "Generating…";
                const data = await fetchJson("/api/maintenance-jobs/next-code");
                jobCodeInput.value = data.code || "";
                jobCodeInput.placeholder = data.code ? data.code : "JOB-001";
            } catch (error) {
                jobCodeInput.placeholder = "Unable to fetch";
                showError(error.message || "Unable to generate job code.");
            }
        }
        if (!canLogIdle && idleEntryForm) {
            if (idleEntryNotice) {
                idleEntryNotice.textContent = "Only Production, Maintenance Managers or Admins can log hour meter readings.";
                idleEntryNotice.hidden = false;
            }
            idleEntryForm.querySelectorAll("input, textarea, select, button").forEach((element) => {
                element.disabled = true;
            });
        }

        if (!canAddSuppliers) {
            if (supplierFormNotice) {
                supplierFormNotice.textContent = "Only Production Managers or Admins can add suppliers.";
                supplierFormNotice.hidden = false;
            }
            if (supplierForm) {
                supplierForm.querySelectorAll("input, textarea, button").forEach((element) => {
                    element.disabled = true;
                });
            }
        }

        function formatDate(value, withTime = false) {
            if (!value) return "—";
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) return value;
            return withTime ? date.toLocaleString() : date.toLocaleDateString();
        }

        function formatCurrency(value, { fallback = "Rs. 0.00" } = {}) {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return fallback;
            }
            return `Rs. ${number.toLocaleString(undefined, {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
            })}`;
        }

        function formatTotalCost(value) {
            return formatCurrency(value);
        }

        function formatDuration(minutes) {
            if (minutes == null) return "—";
            if (minutes < 60) return `${minutes} min`;
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            if (!mins) return `${hours} hr`;
            return `${hours} hr ${mins} min`;
        }

        async function fetchJson(url, options = {}) {
            const headers = {
                Accept: "application/json",
                Authorization: `Bearer ${token}`,
                ...(options.headers || {}),
            };

            if (options.body && !headers["Content-Type"] && !headers["content-type"]) {
                headers["Content-Type"] = "application/json";
            }

            const response = await fetch(url, {
                ...options,
                headers,
            });

            if (!response.ok) {
                let message = `Request failed (${response.status})`;
                let payload = null;
                try {
                    payload = await response.json();
                    if (payload?.msg) message = payload.msg;
                } catch (_) {
                    // ignore
                }
                const error = new Error(message);
                error.status = response.status;
                if (payload !== null) {
                    error.payload = payload;
                }
                throw error;
            }

            if (response.status === 204) {
                return null;
            }

            return response.json();
        }

        async function refreshAssetCodePreview() {
            if (!canManageAssets || !assetCodeInput || !assetCategorySelect) return;

            const category = assetCategorySelect.value?.trim();

            if (!category) {
                assetCodeInput.value = "";
                assetCodeInput.placeholder = "Select a category";
                return;
            }

            const requestId = ++latestCodeRequest;
            assetCodeInput.value = "";
            assetCodeInput.placeholder = "Generating code…";

            try {
                const data = await fetchJson(
                    `/api/machines/assets/code?category=${encodeURIComponent(category)}`
                );
                if (latestCodeRequest !== requestId) return;
                assetCodeInput.value = data.code || "";
                assetCodeInput.placeholder = data.code ? data.code : "Select a category";
            } catch (error) {
                if (latestCodeRequest !== requestId) return;
                assetCodeInput.value = "";
                assetCodeInput.placeholder = "Unable to generate";
                assetFormError.textContent = error.message || "Unable to generate asset code.";
                assetFormError.hidden = false;
            }
        }

        function renderAssets() {
            if (!assetsTableBody) return;

            assetsTableBody.innerHTML = "";

            if (!Array.isArray(assets) || assets.length === 0) {
                if (assetsEmpty) assetsEmpty.hidden = false;
                return;
            }

            if (assetsEmpty) assetsEmpty.hidden = true;

            assets.forEach((asset) => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td data-label="Code">${asset.code}</td>
                    <td data-label="Name">${asset.name}</td>
                    <td data-label="Location">${asset.location || "—"}</td>
                    <td data-label="Status">${asset.status || "—"}</td>
                    <td data-label="Parts">${asset.part_count || 0}</td>
                    <td data-label="Actions"><button type="button" class="button button--ghost button--small" data-action="ckd" data-asset-id="${asset.id}">CKD</button></td>
                `;
                assetsTableBody.appendChild(row);
            });
        }

        function getIdleMachinesForUi() {
            if (Array.isArray(assets) && assets.length > 0) {
                return assets
                    .slice()
                    .sort((a, b) => (a.code || "").localeCompare(b.code || ""));
            }
            return DEFAULT_IDLE_MACHINES.slice();
        }

        function populateAssetSelects() {
            if (!idleMachineSelect) return;
            const previousValue = idleMachineSelect.value;
            const machines = getIdleMachinesForUi();

            idleMachineSelect.innerHTML = "";

            machines.forEach((machine) => {
                const code = machine?.code;
                if (!code) return;
                const label = machine?.name || machine?.title || code;
                const option = document.createElement("option");
                option.value = code;
                option.textContent = `${code} — ${label}`;
                idleMachineSelect.appendChild(option);
                const existing = machineMetadata.get(code);
                if (existing) {
                    existing.title = label;
                } else {
                    machineMetadata.set(code, { title: label });
                }
            });

            const hasPrevious = machines.some((machine) => machine?.code === previousValue);
            if (previousValue && hasPrevious) {
                idleMachineSelect.value = previousValue;
            } else if (idleMachineSelect.options.length > 0) {
                idleMachineSelect.value = idleMachineSelect.options[0].value;
            }

            populateMaintenanceAssetSelect();
        }

        function renderMachineCards() {
            if (!machineCardsContainer) return;

            const machines = getIdleMachinesForUi();
            machineCardsContainer.innerHTML = "";

            machines.slice(0, MAX_MACHINE_CARDS).forEach((machine) => {
                const code = machine?.code;
                if (!code) return;
                const label = machine?.name || machine?.title || code;
                const card = document.createElement("article");
                card.className = "machine-glance";
                card.dataset.machineCard = code;
                card.innerHTML = `
                    <header class="machine-glance__header">
                        <div>
                            <p class="machine-glance__code">${code}</p>
                            <h3 class="machine-glance__title">${label}</h3>
                        </div>
                        <span class="status-pill" data-machine-status>Awaiting data</span>
                    </header>
                    <p class="machine-glance__runtime"><span data-machine-runtime>—</span> <small>runtime</small></p>
                    <div class="machine-glance__progress" aria-hidden="true">
                        <div class="machine-glance__progress-bar" data-machine-progress></div>
                    </div>
                    <dl class="machine-glance__metrics">
                        <div>
                            <dt>Idle</dt>
                            <dd data-machine-idle>—</dd>
                        </div>
                        <div>
                            <dt>Overtime</dt>
                            <dd data-machine-extended>—</dd>
                        </div>
                        <div>
                            <dt>Utilisation</dt>
                            <dd data-machine-utilisation>—</dd>
                        </div>
                    </dl>
                    <div class="machine-glance__reason" data-machine-reason>Idle reason insights will appear here.</div>
                    <p class="machine-glance__note" data-machine-note></p>
                `;
                machineCardsContainer.appendChild(card);
                const existing = machineMetadata.get(code);
                if (existing) {
                    existing.title = label;
                } else {
                    machineMetadata.set(code, { title: label });
                }
            });

            machineCards = Array.from(
                machineCardsContainer.querySelectorAll("[data-machine-card]")
            );
        }

        async function loadAssets() {
            if (assetError) {
                assetError.hidden = true;
                assetError.textContent = "";
            }
            try {
                assets = await fetchJson("/api/machines/assets");
                renderAssets();
                populateAssetSelects();
                renderMachineCards();
                idleSummaryCache.clear();
                if (idleInitialized) {
                    Promise.resolve(refreshIdleAnalytics()).catch(() => {});
                }
            } catch (error) {
                if (assetError) {
                    assetError.textContent = error.message || "Unable to load assets";
                    assetError.hidden = false;
                }
                assets = [];
                renderAssets();
                populateAssetSelects();
                renderMachineCards();
                idleSummaryCache.clear();
                if (idleInitialized) {
                    Promise.resolve(refreshIdleAnalytics()).catch(() => {});
                }
            }
        }

        async function loadAssetParts(assetId) {
            if (assetPartError) assetPartError.hidden = true;
            if (assetPartSuccess) assetPartSuccess.hidden = true;
            try {
                const parts = await fetchJson(`/api/machines/assets/${assetId}/parts`);
                currentParts = Array.isArray(parts) ? parts : [];
                updatePartNumberField(currentParts);
                renderFilteredParts();
            } catch (error) {
                if (assetPartError) {
                    assetPartError.textContent = error.message || "Unable to load parts";
                    assetPartError.hidden = false;
                }
                currentParts = [];
                updatePartNumberField(currentParts);
                renderFilteredParts();
            }
        }

        function showAssetDetail(asset, { focusPart } = {}) {
            if (!asset || asset.id == null) return;
            currentAssetId = asset.id;
            if (assetPartSearchInput) {
                assetPartSearchInput.value = focusPart ? focusPart : "";
            }
            if (assetPartsEmptyMessage) {
                assetPartsEmptyMessage.textContent = DEFAULT_PARTS_EMPTY_MESSAGE;
            }
            if (assetDetailTitle) {
                const code = asset.code ? ` (${asset.code})` : "";
                assetDetailTitle.textContent = asset.name ? `${asset.name}${code}` : asset.code || "Asset details";
            }
            const metaParts = asset.part_count === 1 ? "1 part" : `${asset.part_count || 0} parts`;
            const metaLocation = asset.location ? ` • ${asset.location}` : "";
            if (assetDetailMeta) assetDetailMeta.textContent = `${metaParts}${metaLocation}`;
            const facts = [];
            if (asset.manufacturer) facts.push(["Manufacturer", asset.manufacturer]);
            if (asset.model_number) facts.push(["Model", asset.model_number]);
            if (asset.serial_number) facts.push(["Serial", asset.serial_number]);
            if (asset.installed_on) facts.push(["Installed", formatDate(asset.installed_on)]);
            if (asset.status) facts.push(["Status", asset.status]);
            if (asset.category) facts.push(["Category", asset.category]);
            if (asset.notes) facts.push(["Notes", asset.notes]);
            if (assetDetailFacts) {
                assetDetailFacts.innerHTML = facts.length
                    ? facts.map(([label, value]) => `<div><dt>${label}</dt><dd>${value}</dd></div>`).join("")
                    : "<p>No additional details provided.</p>";
            }
            if (assetDetail) assetDetail.hidden = false;
            Promise.resolve(loadAssetParts(asset.id))
                .then(() => {
                    if (focusPart && assetPartSearchInput) {
                        assetPartSearchInput.value = focusPart;
                        assetPartSearchInput.dispatchEvent(new Event("input", { bubbles: true }));
                    }
                })
                .catch(() => {});
        }

        function computeNextPartNumber(parts) {
            if (!Array.isArray(parts) || parts.length === 0) {
                return "P-001";
            }
            let maxNumber = 0;
            parts.forEach((part) => {
                if (!part || typeof part.part_number !== "string") return;
                const match = part.part_number.trim().match(/^P-(\d+)$/i);
                if (!match) return;
                const numeric = Number.parseInt(match[1], 10);
                if (!Number.isNaN(numeric)) {
                    maxNumber = Math.max(maxNumber, numeric);
                }
            });
            return `P-${String(maxNumber + 1).padStart(3, "0")}`;
        }

        function updatePartNumberField(parts) {
            if (!canManageParts || !partNumberInput) return;
            const nextNumber = computeNextPartNumber(parts);
            partNumberInput.value = nextNumber;
        }

        function partMatchesQuery(part, query) {
            if (!query) return true;
            const terms = query.split(/\s+/).filter(Boolean);
            if (!terms.length) return true;
            const partNumber = typeof part.part_number === "string" ? part.part_number : "";
            const normalizedPartNumber = partNumber.replace(/[^a-z0-9]/gi, "");
            const haystack = [
                part.name,
                partNumber,
                normalizedPartNumber,
                part.description,
                part.notes,
                part.expected_life_hours != null ? String(part.expected_life_hours) : "",
                Array.isArray(part.replacement_history)
                    ? part.replacement_history
                          .map((replacement) =>
                              [
                                  replacement.replaced_on,
                                  replacement.replaced_by,
                                  replacement.reason,
                                  replacement.notes,
                              ]
                                  .filter(Boolean)
                                  .join(" ")
                          )
                          .join(" ")
                    : "",
            ]
                .filter(Boolean)
                .join(" ")
                .toLowerCase();
            return terms.every((term) => haystack.includes(term));
        }

        function renderPartsList(parts, { filtered = false } = {}) {
            assetPartsList.innerHTML = "";
            if (!Array.isArray(parts) || parts.length === 0) {
                assetPartsEmpty.hidden = false;
                if (assetPartsEmptyMessage) {
                    assetPartsEmptyMessage.textContent = filtered
                        ? FILTERED_PARTS_EMPTY_MESSAGE
                        : DEFAULT_PARTS_EMPTY_MESSAGE;
                }
                return;
            }
            assetPartsEmpty.hidden = true;
            if (assetPartsEmptyMessage) {
                assetPartsEmptyMessage.textContent = DEFAULT_PARTS_EMPTY_MESSAGE;
            }

            parts.forEach((part) => {
                const card = document.createElement("article");
                card.className = "part-card";
                const lastReplacement = part.replacement_history?.[0];
                const historyCount = part.replacement_history?.length || 0;
                card.innerHTML = `
                    <header class="part-card__header">
                        <div>
                            <h4 class="part-card__title">${part.name}</h4>
                            <p class="part-card__meta">
                                ${part.part_number ? `Part #${part.part_number}` : "No part number"}
                                ${part.expected_life_hours ? ` • ${part.expected_life_hours} hrs expected life` : ""}
                            </p>
                            ${lastReplacement ? `<p class="part-card__meta">Last replaced on ${formatDate(lastReplacement.replaced_on)}</p>` : ""}
                        </div>
                        <div class="part-card__actions">
                            <button type="button" class="button button--ghost button--small" data-action="toggle-history">History (${historyCount})</button>
                            <button type="button" class="button button--ghost button--small" data-action="log-replacement">Log replacement</button>
                        </div>
                    </header>
                    ${part.description ? `<p class="part-card__description">${part.description}</p>` : ""}
                    ${part.notes ? `<p class="part-card__notes">${part.notes}</p>` : ""}
                    <details class="part-card__history" ${historyCount ? "" : "open"}>
                        <summary>Replacement history (${historyCount})</summary>
                        <ul class="part-card__history-list">
                            ${historyCount ? part.replacement_history.map((replacement) => `
                                <li>
                                    <div>
                                        <strong>${formatDate(replacement.replaced_on)}</strong>
                                        ${replacement.reason ? ` – ${replacement.reason}` : ""}
                                    </div>
                                    ${replacement.replaced_by ? `<div>By: ${replacement.replaced_by}</div>` : ""}
                                    ${replacement.notes ? `<div>${replacement.notes}</div>` : ""}
                                </li>
                            `).join("") : "<li>No replacements logged yet.</li>"}
                        </ul>
                    </details>
                    <form class="part-card__form" data-part-id="${part.id}" hidden>
                        <div class="form-grid">
                            <div class="input-group">
                                <label>Replaced on</label>
                                <input name="replaced_on" type="date" />
                            </div>
                            <div class="input-group">
                                <label>Replaced by</label>
                                <input name="replaced_by" type="text" placeholder="Technician" />
                            </div>
                            <div class="input-group">
                                <label>Reason</label>
                                <input name="reason" type="text" placeholder="Wear, upgrade, etc." />
                            </div>
                        </div>
                        <div class="input-group">
                            <label>Notes</label>
                            <textarea name="notes" rows="2" placeholder="Optional remarks"></textarea>
                        </div>
                        <div class="form__footer">
                            <button type="submit" class="button">Save replacement</button>
                        </div>
                    </form>
                `;

                const historyToggle = card.querySelector('[data-action="toggle-history"]');
                const historyDetails = card.querySelector(".part-card__history");
                if (historyToggle) {
                    historyToggle.addEventListener("click", () => {
                        historyDetails.open = !historyDetails.open;
                    });
                }

                const form = card.querySelector(".part-card__form");
                const logButton = card.querySelector('[data-action="log-replacement"]');
                if (!canManageParts) {
                    if (logButton) logButton.disabled = true;
                    if (form) {
                        form.querySelectorAll("input, textarea, button").forEach((element) => {
                            element.disabled = true;
                        });
                    }
                } else if (logButton && form) {
                    logButton.addEventListener("click", () => {
                        form.hidden = !form.hidden;
                    });
                    form.addEventListener("submit", async (event) => {
                        event.preventDefault();
                        const submitButton = form.querySelector('button[type="submit"]');
                        submitButton.disabled = true;
                        const formData = new FormData(form);
                        const payload = {
                            replaced_on: formData.get("replaced_on") || null,
                            replaced_by: formData.get("replaced_by")?.trim() || null,
                            reason: formData.get("reason")?.trim() || null,
                            notes: formData.get("notes")?.trim() || null,
                        };
                        try {
                            await fetchJson(`/api/machines/parts/${part.id}/replacements`, {
                                method: "POST",
                                body: JSON.stringify(payload),
                            });
                            form.reset();
                            form.hidden = true;
                            await loadAssetParts(currentAssetId);
                        } catch (error) {
                            alert(error.message || "Unable to log replacement");
                        } finally {
                            submitButton.disabled = false;
                        }
                    });
                }

                assetPartsList.appendChild(card);
            });
        }

        function renderFilteredParts() {
            const query = assetPartSearchInput?.value?.trim().toLowerCase() || "";
            const partsToRender = query
                ? currentParts.filter((part) => partMatchesQuery(part, query))
                : currentParts.slice();
            const isFiltered = Boolean(query) && currentParts.length > 0;
            renderPartsList(partsToRender, { filtered: isFiltered });
        }

        assetsTableBody?.addEventListener("click", (event) => {
            const button = event.target.closest("[data-action='ckd']");
            if (!button) return;
            const assetId = Number(button.dataset.assetId);
            const asset = assets.find((item) => item.id === assetId);
            if (!asset) return;
            showAssetDetail(asset);
        });

        closeAssetDetail?.addEventListener("click", () => {
            if (assetDetail) assetDetail.hidden = true;
            currentAssetId = null;
            currentParts = [];
            if (assetPartsList) assetPartsList.innerHTML = "";
            if (assetPartsEmpty) assetPartsEmpty.hidden = true;
            if (assetPartSearchInput) {
                assetPartSearchInput.value = "";
            }
            if (assetPartsEmptyMessage) {
                assetPartsEmptyMessage.textContent = DEFAULT_PARTS_EMPTY_MESSAGE;
            }
            updatePartNumberField(currentParts);
        });

        refreshAssetsButton?.addEventListener("click", loadAssets);

        if (canManageAssets && assetCategorySelect) {
            assetCategorySelect.addEventListener("change", () => {
                if (assetFormError) assetFormError.hidden = true;
                if (assetFormSuccess) assetFormSuccess.hidden = true;
                refreshAssetCodePreview();
            });
        }

        if (canManageAssets && assetForm) {
            assetForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                if (assetFormSuccess) assetFormSuccess.hidden = true;
                if (assetFormError) assetFormError.hidden = true;
                const formData = new FormData(assetForm);
                const payload = {
                    name: formData.get("name")?.trim() || "",
                    category: formData.get("category")?.trim() || null,
                    location: formData.get("location")?.trim() || null,
                    manufacturer: formData.get("manufacturer")?.trim() || null,
                    model_number: formData.get("model_number")?.trim() || null,
                    serial_number: formData.get("serial_number")?.trim() || null,
                    installed_on: formData.get("installed_on") || null,
                    status: formData.get("status")?.trim() || null,
                    notes: formData.get("notes")?.trim() || null,
                };

                if (!payload.name && assetFormError) {
                    assetFormError.textContent = "Name is required.";
                    assetFormError.hidden = false;
                    return;
                }

                if (!payload.category && assetFormError) {
                    assetFormError.textContent = "Select a category to generate an asset code.";
                    assetFormError.hidden = false;
                    return;
                }

                const submitButton = assetForm.querySelector('button[type="submit"]');
                submitButton.disabled = true;

                try {
                    await fetchJson("/api/machines/assets", {
                        method: "POST",
                        body: JSON.stringify(payload),
                    });
                    const selectedCategory = assetCategorySelect?.value || null;
                    assetForm.reset();
                    if (assetFormSuccess) assetFormSuccess.hidden = false;
                    if (assetCategorySelect && selectedCategory) {
                        assetCategorySelect.value = selectedCategory;
                        await refreshAssetCodePreview();
                    }
                    await loadAssets();
                } catch (error) {
                    if (assetFormError) {
                        assetFormError.textContent = error.message || "Unable to add asset";
                        assetFormError.hidden = false;
                    }
                } finally {
                    submitButton.disabled = false;
                }
            });
        }

        if (canManageAssets && assetCategorySelect) {
            refreshAssetCodePreview();
        }

        if (canManageParts && assetPartForm) {
            assetPartForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                if (!currentAssetId) return;
                if (assetPartError) assetPartError.hidden = true;
                if (assetPartSuccess) assetPartSuccess.hidden = true;
                const formData = new FormData(assetPartForm);
                const payload = {
                    name: formData.get("name")?.trim(),
                    part_number: formData.get("part_number")?.trim(),
                    expected_life_hours: formData.get("expected_life_hours") || null,
                    description: formData.get("description")?.trim() || null,
                    notes: formData.get("notes")?.trim() || null,
                };
                if (!payload.name && assetPartError) {
                    assetPartError.textContent = "Part name is required.";
                    assetPartError.hidden = false;
                    return;
                }
                if (!payload.part_number && assetPartError) {
                    assetPartError.textContent = "Part number is required.";
                    assetPartError.hidden = false;
                    return;
                }
                if (payload.expected_life_hours) {
                    payload.expected_life_hours = Number(payload.expected_life_hours);
                    if (Number.isNaN(payload.expected_life_hours)) {
                        payload.expected_life_hours = null;
                    }
                }

                const submitButton = assetPartForm.querySelector('button[type="submit"]');
                submitButton.disabled = true;
                try {
                    await fetchJson(`/api/machines/assets/${currentAssetId}/parts`, {
                        method: "POST",
                        body: JSON.stringify(payload),
                    });
                    assetPartForm.reset();
                    if (assetPartSuccess) assetPartSuccess.hidden = false;
                    await loadAssets();
                    await loadAssetParts(currentAssetId);
                } catch (error) {
                    if (assetPartError) {
                        assetPartError.textContent = error.message || "Unable to add part";
                        assetPartError.hidden = false;
                    }
                } finally {
                    submitButton.disabled = false;
                }
            });
        }

        async function loadJobs() {
            if (jobsError) {
                jobsError.hidden = true;
                jobsError.textContent = "";
            }

            try {
                const jobs = await fetchJson("/api/maintenance-jobs");
                renderJobs(jobs);
            } catch (error) {
                if (jobsError) {
                    jobsError.textContent = error.message || "Unable to load jobs";
                    jobsError.hidden = false;
                }
                renderJobs([]);
            }
        }

        function renderJobs(jobs) {
            if (!jobsTableBody) return;

            jobsTableBody.innerHTML = "";

            if (!Array.isArray(jobs) || jobs.length === 0) {
                if (jobsEmpty) jobsEmpty.hidden = false;
                return;
            }

            if (jobsEmpty) jobsEmpty.hidden = true;

            jobs.forEach((job) => {
                const row = document.createElement("tr");
                row.dataset.jobId = job.id;
                const statusText = job.status_label || job.status || "—";
                const { materialsTotal, outsourcedTotal, internalTotal, combinedTotal } = getJobCostSummary(job);
                const updateStatusCell = canManageMaintenanceJobs
                    ? '<button type="button" class="button button--ghost button--small" data-job-action="update-status">Update status</button>'
                    : '—';
                const assetName = job.asset?.name || "—";
                const partDisplay = job.part ? job.part.name || job.part.part_number || "—" : "—";

                row.innerHTML = `
                    <td data-label="Code" class="jobs-table__sticky-col jobs-table__sticky-col--first">${job.job_code}</td>
                    <td data-label="Job category" class="jobs-table__sticky-col">${job.job_category || job.title || "—"}</td>
                    <td data-label="Status">${statusText}</td>
                    <td data-label="Priority">${job.priority || "—"}</td>
                    <td data-label="Assigned">${job.assigned_to ? job.assigned_to.name : "—"}</td>
                    <td data-label="Asset name">${assetName}</td>
                    <td data-label="Part name (CKD)">${partDisplay}</td>
                    <td data-label="Job Date">${formatDate(job.job_date)}</td>
                    <td data-label="Expected completion">${formatDate(job.expected_completion)}</td>
                    <td data-label="Job started date">${formatDate(job.job_started_date)}</td>
                    <td data-label="Job finished date">${formatDate(job.job_finished_date)}</td>
                    <td data-label="Materials used (Cost)">${formatCurrency(materialsTotal)}</td>
                    <td data-label="Outsourced party cost">${formatCurrency(outsourcedTotal)}</td>
                    <td data-label="Internal staff cost">${formatCurrency(internalTotal)}</td>
                    <td data-label="Total cost">${formatCurrency(combinedTotal)}</td>
                    <td data-label="More"><button type="button" class="button button--ghost button--small" data-job-action="view-more">More</button></td>
                    <td data-label="Update status">${updateStatusCell}</td>
                `;
                const updateButton = row.querySelector('[data-job-action="update-status"]');
                if (updateButton) {
                    updateButton.addEventListener("click", (event) => {
                        event.stopPropagation();
                        openModal("maintenance-job-modal");
                        selectJob(job.id);
                        if (maintenanceSection) {
                            maintenanceSection.scrollIntoView({ behavior: "smooth", block: "start" });
                            const focusable = maintenanceSection.querySelector(
                                "input:not([disabled]), select:not([disabled]), textarea:not([disabled])"
                            );
                            focusable?.focus();
                        }
                    });
                }
                const moreButton = row.querySelector('[data-job-action="view-more"]');
                if (moreButton) {
                    moreButton.addEventListener("click", (event) => {
                        event.stopPropagation();
                        openJobDetailsModal(job.id);
                    });
                }
                row.addEventListener("click", () => {
                    selectJob(job.id);
                });
                if (selectedJobId && Number(selectedJobId) === Number(job.id)) {
                    row.classList.add("is-selected");
                }
                jobsTableBody.appendChild(row);
            });
            setSelectedRowHighlight();
        }

        function showJobDetailsLoading() {
            if (jobDetailsError) {
                jobDetailsError.textContent = "";
                jobDetailsError.hidden = true;
            }
            if (jobDetailsLoading) jobDetailsLoading.hidden = false;
            if (jobDetailsContent) jobDetailsContent.hidden = true;
        }

        function showJobDetailsContent() {
            if (jobDetailsLoading) jobDetailsLoading.hidden = true;
            if (jobDetailsError) jobDetailsError.hidden = true;
            if (jobDetailsContent) jobDetailsContent.hidden = false;
        }

        function showJobDetailsError(message) {
            if (jobDetailsLoading) jobDetailsLoading.hidden = true;
            if (jobDetailsContent) jobDetailsContent.hidden = true;
            if (jobDetailsError) {
                jobDetailsError.textContent = message || "Unable to load job details.";
                jobDetailsError.hidden = false;
            }
        }

        function resetJobDetailsFields() {
            if (jobDetailsTitle) jobDetailsTitle.textContent = "Maintenance job";
            if (jobDetailsOverview) jobDetailsOverview.innerHTML = "";
            if (jobDetailsAsset) jobDetailsAsset.textContent = "—";
            if (jobDetailsPart) jobDetailsPart.textContent = "—";
            if (jobDetailsTimeline) jobDetailsTimeline.innerHTML = "";
            if (jobDetailsDescription) jobDetailsDescription.textContent = "No description provided.";
            if (jobDetailsRemark) jobDetailsRemark.textContent = "No remarks recorded.";
            if (jobDetailsMaterialsBody) {
                jobDetailsMaterialsBody.innerHTML = "";
                const emptyRow = document.createElement("tr");
                const emptyCell = document.createElement("td");
                emptyCell.colSpan = 4;
                emptyCell.className = "job-details__empty";
                emptyCell.textContent = "No materials recorded.";
                emptyRow.appendChild(emptyCell);
                jobDetailsMaterialsBody.appendChild(emptyRow);
            }
            if (jobDetailsMaterialsTotal) jobDetailsMaterialsTotal.textContent = formatCurrency(0);
            if (jobDetailsOutsourcedBody) {
                jobDetailsOutsourcedBody.innerHTML = "";
                const emptyRow = document.createElement("tr");
                const emptyCell = document.createElement("td");
                emptyCell.colSpan = 5;
                emptyCell.className = "job-details__empty";
                emptyCell.textContent = "No outsourced services recorded.";
                emptyRow.appendChild(emptyCell);
                jobDetailsOutsourcedBody.appendChild(emptyRow);
            }
            if (jobDetailsOutsourcedTotal) jobDetailsOutsourcedTotal.textContent = formatCurrency(0);
            if (jobDetailsStaffBody) {
                jobDetailsStaffBody.innerHTML = "";
                const emptyRow = document.createElement("tr");
                const emptyCell = document.createElement("td");
                emptyCell.colSpan = 5;
                emptyCell.className = "job-details__empty";
                emptyCell.textContent = "No internal staff costs recorded.";
                emptyRow.appendChild(emptyCell);
                jobDetailsStaffBody.appendChild(emptyRow);
            }
            if (jobDetailsStaffTotal) jobDetailsStaffTotal.textContent = formatCurrency(0);
            if (jobDetailsTotalsMaterials) jobDetailsTotalsMaterials.textContent = formatCurrency(0);
            if (jobDetailsTotalsOutsourced) jobDetailsTotalsOutsourced.textContent = formatCurrency(0);
            if (jobDetailsTotalsInternal) jobDetailsTotalsInternal.textContent = formatCurrency(0);
            if (jobDetailsTotalsCost) jobDetailsTotalsCost.textContent = formatCurrency(0);
            if (jobDetailsUpdates) {
                jobDetailsUpdates.textContent = "No updates recorded for this job yet.";
            }
        }

        function populateJobDetails(job) {
            if (!job) return;
            const statusText = job.status_label || job.status || "—";
            const { materialsTotal, outsourcedTotal, internalTotal, combinedTotal } = getJobCostSummary(job);

            if (jobDetailsTitle) {
                const category = job.job_category || job.title || "Job details";
                jobDetailsTitle.textContent = job.job_code ? `${job.job_code} • ${category}` : category;
            }

            if (jobDetailsOverview) {
                jobDetailsOverview.innerHTML = "";
                const assignedParts = [];
                if (job.assigned_to?.name) assignedParts.push(job.assigned_to.name);
                if (job.assigned_to?.email) assignedParts.push(`(${job.assigned_to.email})`);
                const assignedLabel = assignedParts.length
                    ? assignedParts.join(" ")
                    : job.maint_email || "—";
                const overviewItems = [
                    ["Code", job.job_code || "—"],
                    ["Job category", job.job_category || job.title || "—"],
                    ["Priority", job.priority || "—"],
                    ["Status", statusText],
                    ["Assigned to", assignedLabel],
                    ["Location", job.location || "—"],
                ];
                overviewItems.forEach(([label, value]) => {
                    const wrapper = document.createElement("div");
                    const dt = document.createElement("dt");
                    dt.textContent = label;
                    const dd = document.createElement("dd");
                    const displayValue = value == null || value === "" ? "—" : value;
                    dd.textContent = displayValue;
                    wrapper.append(dt, dd);
                    jobDetailsOverview.appendChild(wrapper);
                });
            }

            if (jobDetailsAsset) {
                jobDetailsAsset.innerHTML = "";
                const asset = job.asset;
                if (asset && asset.id != null) {
                    const link = document.createElement("a");
                    link.href = "#";
                    link.dataset.jobDetailsLink = "asset";
                    link.dataset.assetId = String(asset.id);
                    link.textContent = formatAssetLabel(asset) || asset.name || asset.code || `Asset #${asset.id}`;
                    jobDetailsAsset.appendChild(link);
                } else {
                    jobDetailsAsset.textContent = "—";
                }
            }

            if (jobDetailsPart) {
                jobDetailsPart.innerHTML = "";
                const part = job.part;
                if (part && part.id != null) {
                    const link = document.createElement("a");
                    link.href = "#";
                    link.dataset.jobDetailsLink = "part";
                    if (part.asset_id != null) {
                        link.dataset.assetId = String(part.asset_id);
                    }
                    link.dataset.partId = String(part.id);
                    link.dataset.partLabel = part.name || part.part_number || "";
                    link.textContent = formatPartLabel(part) || part.name || part.part_number || `Part #${part.id}`;
                    jobDetailsPart.appendChild(link);
                } else {
                    jobDetailsPart.textContent = "—";
                }
            }

            if (jobDetailsTimeline) {
                jobDetailsTimeline.innerHTML = "";
                const timelineItems = [
                    ["Job Date", job.job_date],
                    ["Expected completion", job.expected_completion],
                    ["Job started date", job.job_started_date],
                    ["Job finished date", job.job_finished_date],
                ];
                timelineItems.forEach(([label, value]) => {
                    const item = document.createElement("li");
                    item.className = "job-timeline__item";
                    if (!value) {
                        item.classList.add("job-timeline__item--pending");
                    }
                    const labelEl = document.createElement("span");
                    labelEl.className = "job-timeline__label";
                    labelEl.textContent = label;
                    const valueEl = document.createElement("span");
                    valueEl.className = "job-timeline__value";
                    valueEl.textContent = formatDate(value);
                    item.append(labelEl, valueEl);
                    jobDetailsTimeline.appendChild(item);
                });
            }

            if (jobDetailsDescription) {
                jobDetailsDescription.textContent = job.description || "No description provided.";
            }
            if (jobDetailsRemark) {
                jobDetailsRemark.textContent = job.maintenance_notes || "No remarks recorded.";
            }

            if (jobDetailsMaterialsBody) {
                jobDetailsMaterialsBody.innerHTML = "";
                const materials = Array.isArray(job.materials) ? job.materials : [];
                if (materials.length === 0) {
                    const emptyRow = document.createElement("tr");
                    const emptyCell = document.createElement("td");
                    emptyCell.colSpan = 4;
                    emptyCell.className = "job-details__empty";
                    emptyCell.textContent = "No materials recorded.";
                    emptyRow.appendChild(emptyCell);
                    jobDetailsMaterialsBody.appendChild(emptyRow);
                } else {
                    materials.forEach((material) => {
                        const row = document.createElement("tr");
                        const itemCell = document.createElement("td");
                        itemCell.dataset.label = "Item";
                        itemCell.textContent = material.material_name || "—";
                        const qtyCell = document.createElement("td");
                        qtyCell.dataset.label = "Qty";
                        qtyCell.textContent = material.units || "—";
                        const unitCostCell = document.createElement("td");
                        unitCostCell.dataset.label = "Unit cost";
                        const unitCost = deriveUnitCost(material.units, material.cost);
                        unitCostCell.textContent = unitCost != null ? formatCurrency(unitCost) : "—";
                        const lineCostCell = document.createElement("td");
                        lineCostCell.dataset.label = "Line cost";
                        lineCostCell.textContent = formatCurrency(material.cost);
                        row.append(itemCell, qtyCell, unitCostCell, lineCostCell);
                        jobDetailsMaterialsBody.appendChild(row);
                    });
                }
            }
            if (jobDetailsMaterialsTotal) jobDetailsMaterialsTotal.textContent = formatCurrency(materialsTotal);

            if (jobDetailsOutsourcedBody) {
                jobDetailsOutsourcedBody.innerHTML = "";
                const services = Array.isArray(job.outsourced_services) ? job.outsourced_services : [];
                if (services.length === 0) {
                    const emptyRow = document.createElement("tr");
                    const emptyCell = document.createElement("td");
                    emptyCell.colSpan = 5;
                    emptyCell.className = "job-details__empty";
                    emptyCell.textContent = "No outsourced services recorded.";
                    emptyRow.appendChild(emptyCell);
                    jobDetailsOutsourcedBody.appendChild(emptyRow);
                } else {
                    services.forEach((service) => {
                        const row = document.createElement("tr");
                        const partyCell = document.createElement("td");
                        partyCell.dataset.label = "Party";
                        partyCell.textContent = service.supplier?.name || "—";
                        const dateCell = document.createElement("td");
                        dateCell.dataset.label = "Service date";
                        dateCell.textContent = formatDate(service.service_date);
                        const descriptionCell = document.createElement("td");
                        descriptionCell.dataset.label = "Description";
                        descriptionCell.textContent = service.service_description || "—";
                        const hoursCell = document.createElement("td");
                        hoursCell.dataset.label = "Hours/Qty";
                        hoursCell.textContent = formatNumber(service.engaged_hours);
                        const costCell = document.createElement("td");
                        costCell.dataset.label = "Cost";
                        costCell.textContent = formatCurrency(service.cost);
                        row.append(partyCell, dateCell, descriptionCell, hoursCell, costCell);
                        jobDetailsOutsourcedBody.appendChild(row);
                    });
                }
            }
            if (jobDetailsOutsourcedTotal) jobDetailsOutsourcedTotal.textContent = formatCurrency(outsourcedTotal);

            if (jobDetailsStaffBody) {
                jobDetailsStaffBody.innerHTML = "";
                const staffCosts = Array.isArray(job.internal_staff_costs) ? job.internal_staff_costs : [];
                if (staffCosts.length === 0) {
                    const emptyRow = document.createElement("tr");
                    const emptyCell = document.createElement("td");
                    emptyCell.colSpan = 5;
                    emptyCell.className = "job-details__empty";
                    emptyCell.textContent = "No internal staff costs recorded.";
                    emptyRow.appendChild(emptyCell);
                    jobDetailsStaffBody.appendChild(emptyRow);
                } else {
                    staffCosts.forEach((cost) => {
                        const row = document.createElement("tr");
                        const employeeCell = document.createElement("td");
                        employeeCell.dataset.label = "Employee";
                        const employee = cost.employee;
                        if (employee && (employee.name || employee.reg_number)) {
                            const nameParts = [];
                            if (employee.name) nameParts.push(employee.name);
                            if (employee.reg_number) nameParts.push(`#${employee.reg_number}`);
                            employeeCell.textContent = nameParts.join(" ") || "—";
                        } else {
                            employeeCell.textContent = "—";
                        }
                        const roleCell = document.createElement("td");
                        roleCell.dataset.label = "Role";
                        roleCell.textContent = employee?.position || employee?.status || "—";
                        const hoursCell = document.createElement("td");
                        hoursCell.dataset.label = "Hours";
                        hoursCell.textContent = formatNumber(cost.engaged_hours);
                        const rateCell = document.createElement("td");
                        rateCell.dataset.label = "Rate";
                        rateCell.textContent = cost.hourly_rate != null ? formatCurrency(cost.hourly_rate) : "—";
                        const costCell = document.createElement("td");
                        costCell.dataset.label = "Cost";
                        costCell.textContent = formatCurrency(cost.cost);
                        row.append(employeeCell, roleCell, hoursCell, rateCell, costCell);
                        jobDetailsStaffBody.appendChild(row);
                    });
                }
            }
            if (jobDetailsStaffTotal) jobDetailsStaffTotal.textContent = formatCurrency(internalTotal);

            if (jobDetailsTotalsMaterials) jobDetailsTotalsMaterials.textContent = formatCurrency(materialsTotal);
            if (jobDetailsTotalsOutsourced) jobDetailsTotalsOutsourced.textContent = formatCurrency(outsourcedTotal);
            if (jobDetailsTotalsInternal) jobDetailsTotalsInternal.textContent = formatCurrency(internalTotal);
            if (jobDetailsTotalsCost) jobDetailsTotalsCost.textContent = formatCurrency(combinedTotal);

            if (jobDetailsUpdates) {
                const updates = [];
                if (job.created_at) {
                    updates.push(["Created", formatDate(job.created_at, true)]);
                }
                if (job.maint_submitted_at) {
                    updates.push(["Submitted to maintenance", formatDate(job.maint_submitted_at, true)]);
                }
                if (job.job_started_date) {
                    updates.push(["Work started", formatDate(job.job_started_date)]);
                }
                if (job.job_finished_date) {
                    updates.push(["Work finished", formatDate(job.job_finished_date)]);
                }
                if (job.updated_at && job.updated_at !== job.created_at) {
                    updates.push(["Last updated", formatDate(job.updated_at, true)]);
                }
                updates.push(["Status", statusText]);

                if (updates.length === 0) {
                    jobDetailsUpdates.textContent = "No updates recorded for this job yet.";
                } else {
                    const list = document.createElement("ul");
                    list.className = "job-details__updates-list";
                    updates.forEach(([label, value]) => {
                        const item = document.createElement("li");
                        const labelSpan = document.createElement("span");
                        labelSpan.className = "job-details__updates-label";
                        labelSpan.textContent = `${label}:`;
                        const valueSpan = document.createElement("span");
                        valueSpan.className = "job-details__updates-value";
                        valueSpan.textContent = value || "—";
                        item.append(labelSpan, valueSpan);
                        list.appendChild(item);
                    });
                    jobDetailsUpdates.innerHTML = "";
                    jobDetailsUpdates.appendChild(list);
                }
            }

            showJobDetailsContent();
        }

        async function fetchJobDetails(jobId) {
            if (!jobId) return null;
            const numericKey = Number(jobId);
            const cacheKey = Number.isFinite(numericKey) ? numericKey : jobId;
            const cached = jobDetailsCache.get(cacheKey);
            if (cached) return cached;
            const job = await fetchJson(`/api/maintenance-jobs/${jobId}`);
            jobDetailsCache.set(cacheKey, job);
            return job;
        }

        async function openJobDetailsModal(jobId) {
            if (!jobId) return;
            resetJobDetailsFields();
            showJobDetailsLoading();
            openModal("job-details-modal");
            try {
                const job = await fetchJobDetails(jobId);
                populateJobDetails(job);
            } catch (error) {
                showJobDetailsError(error.message || "Unable to load job details.");
            }
        }

        async function focusAssetFromModal(assetId, { focusPart } = {}) {
            if (assetId == null) return;
            let asset = assets.find((item) => item.id === Number(assetId));
            if (!asset) {
                try {
                    await loadAssets();
                } catch (error) {
                    console.error("Failed to refresh assets", error);
                }
                asset = assets.find((item) => item.id === Number(assetId));
            }
            if (!asset) return;
            closeModal(jobDetailsModal);
            showAssetDetail(asset, { focusPart });
            document.getElementById("machine-outputs")?.scrollIntoView({ behavior: "smooth", block: "start" });
        }

        refreshJobsButton?.addEventListener("click", loadJobs);

        if (addMaterialRowButton) {
            addMaterialRowButton.addEventListener("click", () => {
                hideJobAlerts();
                addMaterialRow();
                updateMaterialsTotal();
            });
        }

        jobDetailsModal?.addEventListener("click", (event) => {
            const actionButton = event.target.closest("[data-job-details-action]");
            if (actionButton) {
                event.preventDefault();
                const action = actionButton.dataset.jobDetailsAction;
                if (action === "close") {
                    closeModal(jobDetailsModal);
                } else if (action === "print") {
                    window.print();
                }
            }

            const link = event.target.closest("[data-job-details-link]");
            if (link) {
                event.preventDefault();
                const assetId = Number(link.dataset.assetId);
                if (!Number.isFinite(assetId)) return;
                const focusPart = link.dataset.jobDetailsLink === "part" ? link.dataset.partLabel || null : null;
                focusAssetFromModal(assetId, { focusPart });
            }
        });

        if (removeMaterialRowButton) {
            removeMaterialRowButton.addEventListener("click", () => {
                hideJobAlerts();
                if (!materialsTableBody) return;
                const rows = materialsTableBody.querySelectorAll("tr");
                if (rows.length > 1) {
                    materialsTableBody.removeChild(rows[rows.length - 1]);
                    updateMaterialsTotal();
                } else {
                    rows[0].querySelectorAll("input").forEach((input) => {
                        input.value = "";
                    });
                    updateMaterialsTotal();
                }
            });
        }

        if (addOutsourcedRowButton) {
            addOutsourcedRowButton.addEventListener("click", () => {
                hideJobAlerts();
                addOutsourcedRow();
                updateOutsourcedDateConstraints();
                updateOutsourcedTotal();
            });
        }

        if (removeOutsourcedRowButton) {
            removeOutsourcedRowButton.addEventListener("click", () => {
                hideJobAlerts();
                if (!outsourcedTableBody) return;
                const rows = outsourcedTableBody.querySelectorAll("tr");
                if (rows.length > 1) {
                    outsourcedTableBody.removeChild(rows[rows.length - 1]);
                } else if (rows.length === 1) {
                    const row = rows[0];
                    const select = row.querySelector("select[data-outsourced-party]");
                    const dateInput = row.querySelector('input[type="date"]');
                    const descriptionInput = row.querySelector('td:nth-child(3) input');
                    const hoursInput = row.querySelector('td:nth-child(4) input');
                    const costInput = row.querySelector('td:nth-child(5) input');
                    if (select) {
                        select.value = "";
                        select.dataset.fallbackLabel = "";
                    }
                    if (dateInput) dateInput.value = "";
                    if (descriptionInput) descriptionInput.value = "";
                    if (hoursInput) hoursInput.value = "";
                    if (costInput) costInput.value = "";
                }
                updateOutsourcedDateConstraints();
                updateOutsourcedTotal();
            });
        }

        if (addInternalStaffRowButton) {
            addInternalStaffRowButton.addEventListener("click", () => {
                hideJobAlerts();
                addInternalStaffRow();
                updateInternalStaffDateConstraints();
                updateInternalStaffEmployeeOptions();
                updateInternalStaffTotal();
            });
        }

        if (removeInternalStaffRowButton) {
            removeInternalStaffRowButton.addEventListener("click", () => {
                hideJobAlerts();
                if (!internalStaffTableBody) return;
                const rows = internalStaffTableBody.querySelectorAll("tr");
                if (rows.length > 1) {
                    internalStaffTableBody.removeChild(rows[rows.length - 1]);
                } else if (rows.length === 1) {
                    const row = rows[0];
                    const select = row.querySelector("select[data-internal-employee]");
                    const dateInput = row.querySelector('input[type="date"]');
                    const descriptionInput = row.querySelector('td:nth-child(3) input');
                    const hoursInput = row.querySelector('td:nth-child(4) input');
                    const rateInput = row.querySelector('td:nth-child(5) input');
                    const costInput = row.querySelector('td:nth-child(6) input');
                    if (select) {
                        select.value = "";
                        select.dataset.fallbackLabel = "";
                    }
                    if (dateInput) {
                        dateInput.value = todayDateString || "";
                    }
                    if (descriptionInput) descriptionInput.value = "";
                    if (hoursInput) hoursInput.value = "";
                    if (rateInput) rateInput.value = "";
                    if (costInput) costInput.value = "";
                }
                updateInternalStaffDateConstraints();
                updateInternalStaffTotal();
            });
        }

        if (resetJobFormButton) {
            resetJobFormButton.addEventListener("click", (event) => {
                event.preventDefault();
                prepareNewJobForm();
            });
        }

        if (submitToMaintenanceButton) {
            submitToMaintenanceButton.addEventListener("click", async () => {
                if (!canManageProductionJobs) return;
                hideJobAlerts();
                clearFieldErrors();
                if (currentMaintenanceJob) {
                    showError("This job has already been submitted to Maintenance.");
                    return;
                }

                const jobCategory = jobCategorySelect?.value?.trim();
                let hasValidationError = false;
                if (!jobCategory) {
                    setFieldError("job_category", "Select a job category.");
                    hasValidationError = true;
                }

                const assetIdValue = jobAssetSelect?.value?.trim() || "";
                const partIdValue = jobPartSelect?.value?.trim() || "";

                if (isPartSelectionRequired && !partIdValue) {
                    setFieldError("part_id", "Select a part for the chosen asset.");
                    hasValidationError = true;
                }

                if (hasValidationError) {
                    showError("Please fix the highlighted fields.");
                    return;
                }

                if (jobCodeInput && !jobCodeInput.value) {
                    await fetchNextJobCode();
                }

                const payload = {
                    job_code: jobCodeInput?.value?.trim() || null,
                    job_date: jobDateInput?.value || null,
                    job_category: jobCategory,
                    title: jobCategory,
                    priority: jobPrioritySelect?.value || "Normal",
                    location: jobLocationSelect?.value || null,
                    expected_completion: jobExpectedInput?.value || null,
                    description: jobDescriptionInput?.value?.trim() || null,
                    maint_email: maintenanceEmailInput?.value?.trim() || null,
                    prod_email: productionEmailInput?.value?.trim() || user?.email || null,
                    asset_id: assetIdValue || null,
                    part_id: partIdValue || null,
                };

                submitToMaintenanceButton.disabled = true;
                try {
                    const result = await fetchJson("/api/maintenance-jobs", {
                        method: "POST",
                        body: JSON.stringify(payload),
                    });
                    const job = result?.job || result;
                    const notification = result?.email_notification || null;
                    populateJobForm(job);
                    syncSectionState(job);
                    selectedJobId = job?.id;
                    const baseSuccessMessage = "Job submitted to Maintenance Manager.";
                    if (notification && notification.sent === false) {
                        const detail = notification.message
                            ? `${notification.message} Please notify them manually.`
                            : "The email notification could not be sent. Please notify them manually.";
                        showWarning(creationWarning, `${baseSuccessMessage} ${detail}`);
                    } else {
                        const detail = notification?.message ? ` ${notification.message}` : "";
                        showSuccess(creationSuccess, `${baseSuccessMessage}${detail}`);
                    }
                    await loadJobs();
                } catch (error) {
                    showError(error.message || "Unable to submit job to Maintenance Manager.");
                } finally {
                    submitToMaintenanceButton.disabled = false;
                }
            });
        }

        if (submitToProductionButton) {
            submitToProductionButton.addEventListener("click", async () => {
                if (!canManageMaintenanceJobs) return;
                hideJobAlerts();
                const jobId = jobIdInput?.value;
                if (!jobId) {
                    showError("Select a maintenance job before submitting.");
                    return;
                }

                let materials;
                try {
                    materials = gatherMaterials();
                } catch (materialError) {
                    showError(materialError.message || "Invalid material details.");
                    return;
                }

                let outsourcedServices;
                try {
                    outsourcedServices = gatherOutsourcedServices();
                } catch (outsourcedError) {
                    showError(outsourcedError.message || "Invalid outsourced service details.");
                    return;
                }

                let internalStaffCosts;
                try {
                    internalStaffCosts = gatherInternalStaffCosts();
                } catch (staffError) {
                    showError(staffError.message || "Invalid internal staff cost details.");
                    return;
                }

                const payload = {
                    job_started_date: jobStartInput?.value || null,
                    job_finished_date: jobFinishInput?.value || null,
                    maintenance_notes: maintenanceNotesInput?.value?.trim() || null,
                    prod_email: productionEmailInput?.value?.trim() || null,
                    materials,
                    outsourced_services: outsourcedServices,
                    internal_staff_costs: internalStaffCosts,
                };

                submitToProductionButton.disabled = true;
                try {
                    const result = await fetchJson(`/api/maintenance-jobs/${jobId}`, {
                        method: "PATCH",
                        body: JSON.stringify(payload),
                    });
                    const job = result?.job || result;
                    const notification = result?.email_notification || null;
                    populateJobForm(job);
                    syncSectionState(job);
                    selectedJobId = job?.id;
                    const baseSuccessMessage = "Maintenance details submitted to Production Manager.";
                    if (notification && notification.sent === false) {
                        const detail = notification.message
                            ? `${notification.message} Please notify them manually.`
                            : "The email notification could not be sent. Please notify them manually.";
                        showWarning(maintenanceWarning, `${baseSuccessMessage} ${detail}`);
                    } else {
                        const detail = notification?.message ? ` ${notification.message}` : "";
                        showSuccess(maintenanceSuccess, `${baseSuccessMessage}${detail}`);
                    }
                    await loadJobs();
                } catch (error) {
                    showError(error.message || "Unable to submit maintenance details.");
                } finally {
                    submitToProductionButton.disabled = false;
                }
            });
        }

        if (canManageProductionJobs) {
            prepareNewJobForm();
        } else {
            populateJobForm(null);
        }

        loadJobs();


        function hideIdleMessages() {
            if (idleEntrySuccess) idleEntrySuccess.hidden = true;
            if (idleEntryError) idleEntryError.hidden = true;
        }

        function normalizeMachineCodes(values) {
            const normalized = [];
            const seen = new Set();
            if (!Array.isArray(values)) return normalized;
            values.forEach((value) => {
                if (typeof value !== "string") return;
                const trimmed = value.trim();
                if (!trimmed) return;
                const key = trimmed.toUpperCase();
                if (seen.has(key)) return;
                seen.add(key);
                normalized.push(trimmed);
            });
            return normalized;
        }

        function getTrackedMachineCodes() {
            const codes = new Set();
            machineCards.forEach((card) => {
                const code = card.dataset.machineCard;
                if (code) codes.add(code);
            });
            assets.forEach((asset) => {
                if (asset?.code) codes.add(asset.code);
            });
            return normalizeMachineCodes(Array.from(codes));
        }

        function getEventDurationMinutes(event) {
            if (!event) return 0;
            if (typeof event.duration_minutes === "number" && !Number.isNaN(event.duration_minutes)) {
                return Math.max(event.duration_minutes, 0);
            }
            const start = event?.started_at ? new Date(event.started_at) : null;
            const end = event?.ended_at ? new Date(event.ended_at) : new Date();
            if (!start || Number.isNaN(start.getTime()) || !end || Number.isNaN(end.getTime())) {
                return 0;
            }
            const diff = (end.getTime() - start.getTime()) / 60000;
            return diff > 0 ? diff : 0;
        }

        function toTimeInputValue(value) {
            if (!value) return "";
            if (value instanceof Date) {
                return value.toISOString().slice(11, 16);
            }
            const stringValue = String(value);
            const parts = stringValue.split("T");
            if (parts.length < 2) return "";
            const timePart = parts[1];
            return timePart.slice(0, 5);
        }

        function addDaysToDateString(dateString, days) {
            if (!dateString) return dateString;
            const parts = String(dateString).split("-");
            if (parts.length !== 3) return dateString;
            const [yearRaw, monthRaw, dayRaw] = parts;
            const year = Number.parseInt(yearRaw, 10);
            const month = Number.parseInt(monthRaw, 10);
            const day = Number.parseInt(dayRaw, 10);
            if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
                return dateString;
            }

            const utcDate = new Date(Date.UTC(year, month - 1, day));
            if (Number.isNaN(utcDate.getTime())) {
                return dateString;
            }

            utcDate.setUTCDate(utcDate.getUTCDate() + days);

            const nextYear = String(utcDate.getUTCFullYear()).padStart(4, "0");
            const nextMonth = String(utcDate.getUTCMonth() + 1).padStart(2, "0");
            const nextDay = String(utcDate.getUTCDate()).padStart(2, "0");
            return `${nextYear}-${nextMonth}-${nextDay}`;
        }

        function getProductionHourWindowDetails(dateValue, hourNo) {
            const hourNumber = Number(hourNo);
            if (!Number.isFinite(hourNumber) || hourNumber < 1 || hourNumber > 24) {
                return null;
            }

            const startHour = Math.max(0, Math.min(hourNumber - 1, 23));
            const startIso = buildDateTimeString(dateValue, startHour);
            if (!startIso) return null;

            const endIso =
                hourNumber >= 24
                    ? buildDateTimeString(addDaysToDateString(dateValue, 1), 0)
                    : buildDateTimeString(dateValue, startHour + 1);

            if (!endIso) return null;

            const startDate = parseDateFromIso(startIso);
            const endDate = parseDateFromIso(endIso);

            if (!startDate || !endDate) {
                return null;
            }

            return { startIso, endIso, startDate, endDate };
        }

        function parseTimeParts(value) {
            if (!value) {
                return [0, 0];
            }
            const stringValue = String(value);
            const [hourRaw = "0", minuteRaw = "0"] = stringValue.split(":");
            const hour = Math.max(0, Math.min(Number.parseInt(hourRaw, 10), 23));
            const minute = Math.max(0, Math.min(Number.parseInt(minuteRaw, 10), 59));
            return [hour, minute];
        }

        function buildDateTimeString(dateString, hour, minute = 0) {
            if (!dateString) return null;
            const parts = String(dateString).split("-");
            if (parts.length !== 3) return null;
            const [yearRaw, monthRaw, dayRaw] = parts;
            const year = Number.parseInt(yearRaw, 10);
            const month = Number.parseInt(monthRaw, 10);
            const day = Number.parseInt(dayRaw, 10);
            if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
                return null;
            }

            const safeHour = Math.max(0, Math.min(Number.parseInt(hour, 10), 23));
            const safeMinute = Math.max(0, Math.min(Number.parseInt(minute, 10), 59));

            const y = String(year).padStart(4, "0");
            const m = String(month).padStart(2, "0");
            const d = String(day).padStart(2, "0");
            const h = String(safeHour).padStart(2, "0");
            const min = String(safeMinute).padStart(2, "0");
            return `${y}-${m}-${d}T${h}:${min}:00`;
        }

        function parseDateFromIso(value) {
            if (!value) return null;
            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) {
                return null;
            }
            return parsed;
        }

        function getShiftWindowBounds(dateString) {
            if (!dateString) return null;
            const [startHour, startMinute] = parseTimeParts(IDLE_SHIFT_START);
            const [endHour, endMinute] = parseTimeParts(IDLE_SHIFT_END);
            const startIso = buildDateTimeString(dateString, startHour, startMinute);
            const endIso = buildDateTimeString(dateString, endHour, endMinute);
            if (!startIso || !endIso) {
                return null;
            }

            const startDate = parseDateFromIso(startIso);
            const endDate = parseDateFromIso(endIso);
            if (!startDate || !endDate) {
                return null;
            }

            return {
                start: startDate,
                end: endDate,
            };
        }

        function getEventIdleMinutesWithinShift(event, dateString) {
            if (!event || !dateString) {
                return 0;
            }

            const bounds = getShiftWindowBounds(dateString);
            if (!bounds) {
                return 0;
            }

            const startDate = event?.started_at ? parseDateFromIso(event.started_at) : null;
            const rawEndDate = event?.ended_at ? parseDateFromIso(event.ended_at) : null;
            if (!startDate) {
                return 0;
            }

            const startMs = startDate.getTime();
            const endMs = (rawEndDate || new Date()).getTime();
            if (!Number.isFinite(startMs) || !Number.isFinite(endMs)) {
                return 0;
            }

            const overlapStart = Math.max(startMs, bounds.start.getTime());
            const overlapEnd = Math.min(endMs, bounds.end.getTime());
            if (overlapEnd <= overlapStart) {
                return 0;
            }

            return (overlapEnd - overlapStart) / 60000;
        }

        function getEventIdleMinutesWithinWindow(event, windowStart, windowEnd) {
            if (!event || !(windowStart instanceof Date) || !(windowEnd instanceof Date)) {
                return 0;
            }

            const startDate = event?.started_at ? parseDateFromIso(event.started_at) : null;
            const rawEndDate = event?.ended_at ? parseDateFromIso(event.ended_at) : null;
            if (!startDate) {
                return 0;
            }

            const eventStart = startDate.getTime();
            const eventEnd = (rawEndDate || new Date()).getTime();
            if (!Number.isFinite(eventStart) || !Number.isFinite(eventEnd)) {
                return 0;
            }

            const overlapStart = Math.max(eventStart, windowStart.getTime());
            const overlapEnd = Math.min(eventEnd, windowEnd.getTime());
            if (overlapEnd <= overlapStart) {
                return 0;
            }

            return (overlapEnd - overlapStart) / 60000;
        }

        function formatTimeFromDate(date) {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
                return "--:--";
            }

            const hours = String(date.getHours()).padStart(2, "0");
            const minutes = String(date.getMinutes()).padStart(2, "0");
            return `${hours}:${minutes}`;
        }

        function formatPulseRange(startDate, endDate) {
            const startLabel = formatTimeFromDate(startDate);
            const endLabel = formatTimeFromDate(endDate);
            return `${startLabel} – ${endLabel}`;
        }

        function buildIdlePulseSlots(machineEvents, dateValue, metrics) {
            const shiftBounds = getShiftWindowBounds(dateValue);
            const events = Array.isArray(machineEvents) ? machineEvents : [];
            const hasEntry = Boolean(metrics?.hasEntry);

            if (!shiftBounds) {
                return Array.from({ length: SHIFT_DURATION_HOURS }, (_, index) => ({
                    idleMinutes: 0,
                    runtimeMinutes: 0,
                    idleRatio: 0,
                    state: hasEntry ? "mixed" : "empty",
                    estimated: true,
                    rangeLabel: `Hour ${index + 1}`,
                }));
            }

            const hasEvents = events.length > 0;
            const fallbackIdleHours = hasEvents ? 0 : Math.max(Number(metrics?.idleTime) || 0, 0);
            const fallbackIdleRatio =
                fallbackIdleHours > 0 && SHIFT_DURATION_HOURS > 0
                    ? Math.min(fallbackIdleHours / SHIFT_DURATION_HOURS, 1)
                    : 0;

            const slots = [];
            const startMs = shiftBounds.start.getTime();

            for (let index = 0; index < SHIFT_DURATION_HOURS; index += 1) {
                const slotStart = new Date(startMs + index * 60 * 60000);
                const slotEnd = new Date(startMs + (index + 1) * 60 * 60000);
                const slotDurationMinutes = Math.max((slotEnd.getTime() - slotStart.getTime()) / 60000, 0);

                let idleMinutes = 0;
                let estimated = false;

                if (hasEntry) {
                    if (hasEvents) {
                        idleMinutes = events.reduce((total, event) => {
                            return total + getEventIdleMinutesWithinWindow(event, slotStart, slotEnd);
                        }, 0);
                    } else if (fallbackIdleRatio > 0 && slotDurationMinutes > 0) {
                        idleMinutes = slotDurationMinutes * fallbackIdleRatio;
                        estimated = true;
                    }
                }

                idleMinutes = Math.min(Math.max(idleMinutes, 0), slotDurationMinutes);
                const runtimeMinutes = Math.max(slotDurationMinutes - idleMinutes, 0);
                const idleRatio = slotDurationMinutes > 0 ? idleMinutes / slotDurationMinutes : 0;

                let state = "active";
                if (!hasEntry) {
                    state = "empty";
                } else if (idleRatio >= 0.75) {
                    state = "idle";
                } else if (idleRatio <= 0.25) {
                    state = "active";
                } else {
                    state = "mixed";
                }

                slots.push({
                    idleMinutes,
                    runtimeMinutes,
                    idleRatio,
                    state,
                    estimated,
                    rangeLabel: formatPulseRange(slotStart, slotEnd),
                });
            }

            return slots;
        }

        function renderIdlePulseGrid(container, machineCodes, pulseDataByMachine, dateValue) {
            if (!container) {
                return;
            }

            const codes = Array.isArray(machineCodes) ? machineCodes : [];
            const referenceDate = dateValue || todayDateString;

            container.innerHTML = "";
            container.setAttribute("aria-rowcount", String(codes.length));
            container.setAttribute("aria-colcount", String(SHIFT_DURATION_HOURS));

            const fragment = document.createDocumentFragment();

            codes.forEach((code) => {
                const normalizedCode = String(code || "").toUpperCase();
                if (!normalizedCode) {
                    return;
                }

                const rowData = pulseDataByMachine.get(normalizedCode) || {};
                const machineName =
                    rowData.machineName || machineMetadata.get(normalizedCode)?.title || normalizedCode;

                const baseSlots =
                    Array.isArray(rowData.slots) && rowData.slots.length > 0
                        ? rowData.slots
                        : buildIdlePulseSlots([], referenceDate, { hasEntry: false });

                const slots = Array.from({ length: SHIFT_DURATION_HOURS }, (_, slotIndex) => {
                    const slot = baseSlots[slotIndex];
                    if (slot) {
                        return slot;
                    }
                    return {
                        idleMinutes: 0,
                        runtimeMinutes: 0,
                        idleRatio: 0,
                        state: rowData.metrics?.hasEntry ? "mixed" : "empty",
                        estimated: true,
                        rangeLabel: `Hour ${slotIndex + 1}`,
                    };
                });

                const row = document.createElement("div");
                row.className = "idle-pulse__row";
                row.setAttribute("role", "row");
                row.dataset.machineCode = normalizedCode;

                const label = document.createElement("span");
                label.className = "idle-pulse__machine";
                label.textContent = normalizedCode;
                label.title =
                    machineName === normalizedCode ? `Machine ${normalizedCode}` : `${normalizedCode} — ${machineName}`;
                row.appendChild(label);

                const slotsWrapper = document.createElement("div");
                slotsWrapper.className = "idle-pulse__slots";
                slotsWrapper.setAttribute("role", "presentation");

                slots.forEach((slot, index) => {
                    const cell = document.createElement("span");
                    cell.className = "idle-pulse__slot";
                    cell.setAttribute("role", "gridcell");
                    cell.dataset.state = slot?.state || "empty";
                    if (slot && Number.isFinite(slot.idleRatio)) {
                        cell.style.setProperty("--idle-ratio", slot.idleRatio.toFixed(3));
                    } else {
                        cell.style.setProperty("--idle-ratio", "0");
                    }

                    if (slot?.estimated) {
                        cell.dataset.estimated = "true";
                    } else {
                        cell.removeAttribute("data-estimated");
                    }

                    const runtimeMinutesRounded = Math.round(slot?.runtimeMinutes ?? 0);
                    const idleMinutesRounded = Math.round(slot?.idleMinutes ?? 0);
                    const parts = [];
                    if (slot?.rangeLabel) {
                        parts.push(slot.rangeLabel);
                    } else {
                        parts.push(`Hour ${index + 1}`);
                    }

                    if (slot?.state === "empty") {
                        parts.push("No runtime or idle records");
                    } else {
                        parts.push(`${runtimeMinutesRounded} min productive`);
                        if (idleMinutesRounded > 0) {
                            parts.push(`${idleMinutesRounded} min idle`);
                        }
                        if (slot?.estimated) {
                            parts.push("Estimated distribution");
                        }
                    }

                    const description = parts.join(" — ");
                    const accessibleMachineName =
                        machineName === normalizedCode ? machineName : `${normalizedCode} — ${machineName}`;

                    cell.title = description;
                    cell.setAttribute("aria-label", `${accessibleMachineName}: ${description}`);
                    slotsWrapper.appendChild(cell);
                });

                row.appendChild(slotsWrapper);
                fragment.appendChild(row);
            });

            container.appendChild(fragment);
        }

        function formatRangeLabel(startIso, endIso, referenceDate) {
            if (!startIso) return "this window";
            const startDate = parseDateFromIso(startIso);
            if (!startDate) return "this window";

            const formatTime = (date) => {
                const hours = String(date.getHours()).padStart(2, "0");
                const minutes = String(date.getMinutes()).padStart(2, "0");
                return `${hours}:${minutes}`;
            };

            const startDatePart = startIso.split("T")[0];
            const endDatePart = endIso ? endIso.split("T")[0] : null;
            const baseline = referenceDate || startDatePart;

            let startLabel = formatTime(startDate);
            if (startDatePart && baseline && startDatePart !== baseline) {
                startLabel = `${startDatePart} ${startLabel}`;
            }

            let endLabel = "ongoing";
            if (endIso) {
                const endDate = parseDateFromIso(endIso);
                if (endDate) {
                    endLabel = formatTime(endDate);
                    if (endDatePart && baseline && endDatePart !== baseline) {
                        endLabel = `${endDatePart} ${endLabel}`;
                    }
                }
            }

            return `${startLabel} – ${endLabel}`;
        }

        function formatIdleReasonLabel(primary, secondary) {
            const main = (primary || "").trim();
            const sub = (secondary || "").trim();
            if (main && sub) {
                return `${main} – ${sub}`;
            }
            return main || sub;
        }

        function formatConflictMessage(conflict, fallbackMessage, options = {}) {
            if (!conflict || typeof conflict !== "object") {
                return fallbackMessage;
            }

            const referenceDate = options.referenceDate || null;

            if (conflict.type === "idle_event") {
                const idle = conflict.idle_event || {};
                const range = formatRangeLabel(idle.start, idle.end, referenceDate);
                const reasonLabel = formatIdleReasonLabel(idle.reason, idle.secondary_reason);
                const reason = reasonLabel ? ` (${reasonLabel})` : "";
                return `Idle window ${range}${reason} already exists. Adjust or remove it before saving production.`;
            }

            if (conflict.type === "production_hour") {
                const production = conflict.production_hour || {};
                const range = formatRangeLabel(production.start, production.end, referenceDate);
                const hourNumber = Number(production.hour_no);
                const hourLabel = Number.isFinite(hourNumber)
                    ? `hour ${String(hourNumber).padStart(2, "0")}`
                    : "a recorded hour";
                const quantityValue = Number(production.quantity_tons);
                const quantityLabel = Number.isFinite(quantityValue)
                    ? ` (${quantityValue.toFixed(2)} tons)`
                    : "";
                return `Production ${hourLabel}${quantityLabel} already exists for ${range}. Clear it before logging idle time.`;
            }

            return fallbackMessage;
        }

        async function findProductionConflictForIdle(machineCode, dateValue, startIso, endIso) {
            if (!machineCode || !dateValue || !startIso) {
                return null;
            }

            const idleStart = parseDateFromIso(startIso);
            if (!idleStart) {
                return null;
            }

            let idleEnd = endIso ? parseDateFromIso(endIso) : null;
            if (!idleEnd) {
                idleEnd = new Date(idleStart.getTime() + 24 * 60 * 60 * 1000);
            }

            const params = new URLSearchParams({
                machine_code: machineCode,
                date: dateValue,
            });

            const data = await fetchJson(`/api/production/daily?${params.toString()}`);
            const entries = Array.isArray(data?.entries) ? data.entries : [];

            for (const entry of entries) {
                if (!entry?.id) continue;
                const windowDetails = getProductionHourWindowDetails(dateValue, entry.hour_no);
                if (!windowDetails) continue;

                if (
                    idleStart < windowDetails.endDate &&
                    idleEnd > windowDetails.startDate
                ) {
                    return {
                        type: "production_hour",
                        machine: data?.machine || null,
                        idle_window: {
                            start: startIso,
                            end: endIso,
                        },
                        production_hour: {
                            id: entry.id,
                            hour_no: entry.hour_no,
                            start: windowDetails.startIso,
                            end: windowDetails.endIso,
                            quantity_tons: entry.quantity_tons,
                        },
                    };
                }
            }

            return null;
        }

        async function initializeIdleAnalytics() {
            if (!idleEntryForm) return;

            if (idleInitialized) {
                await refreshIdleAnalytics();
                return;
            }

            idleInitialized = true;

            if (idleDateInput && !idleDateInput.value) {
                idleDateInput.value = todayDateString;
            }

            if (idleMachineSelect && !idleMachineSelect.value && idleMachineSelect.options.length > 0) {
                idleMachineSelect.value = idleMachineSelect.options[0].value;
            }

            if (idleEntryForm && canLogIdle) {
                idleEntryForm.addEventListener("submit", handleIdleFormSubmit);
            }

            if (idleReasonSelect) {
                idleReasonSelect.addEventListener("change", () => {
                    hideIdleMessages();
                    updateSecondaryReasonField("");
                });
            }

            if (idleMachineSelect) {
                idleMachineSelect.addEventListener("change", () => {
                    hideIdleMessages();
                    prefillIdleForm();
                });
            }

            if (idleDateInput) {
                idleDateInput.addEventListener("change", () => {
                    hideIdleMessages();
                    const monthKey = (idleDateInput.value || "").slice(0, 7);
                    const machineCodes = getTrackedMachineCodes();
                    invalidateIdleSummaryCache(monthKey, machineCodes);
                    refreshIdleAnalytics();
                });
            }

            if (idleEntryForm) {
                idleEntryForm.addEventListener("reset", () => {
                    setTimeout(() => {
                        prefillIdleForm();
                        refreshIdleAnalytics();
                    }, 0);
                });
            }

            updateSecondaryReasonField();

            await refreshIdleAnalytics();
        }

        function prefillIdleForm() {
            if (!idleEntryForm) return;
            const machineCode = idleMachineSelect?.value || "";
            const dateValue = idleDateInput?.value || todayDateString;
            const relevantEvents = idleEvents
                .filter((event) => {
                    const code = event?.asset?.code;
                    if (!code) return false;
                    const normalizedCode = code.toUpperCase();
                    const targetCode = machineCode.toUpperCase();
                    if (normalizedCode !== targetCode) return false;
                    const startDate = event.started_at ? String(event.started_at).slice(0, 10) : null;
                    const endDate = event.ended_at ? String(event.ended_at).slice(0, 10) : startDate;
                    return startDate === dateValue || endDate === dateValue;
                })
                .sort((a, b) => {
                    const first = a?.started_at ? new Date(a.started_at).getTime() : 0;
                    const second = b?.started_at ? new Date(b.started_at).getTime() : 0;
                    return second - first;
                });

            const latest = relevantEvents[0];

            if (idleStartTimeInput) {
                idleStartTimeInput.value = latest ? toTimeInputValue(latest.started_at) : IDLE_SHIFT_START;
            }
            if (idleEndTimeInput) {
                idleEndTimeInput.value = latest?.ended_at ? toTimeInputValue(latest.ended_at) : "";
            }
            if (idleReasonSelect) {
                idleReasonSelect.value = latest?.reason ?? "";
            }
            updateSecondaryReasonField(latest?.secondary_reason ?? "");
            if (idleNotesInput) {
                idleNotesInput.value = latest?.notes ?? "";
            }

            if (idleEntryNotice) {
                if (relevantEvents.length > 1) {
                    idleEntryNotice.textContent = `Already logged ${relevantEvents.length} idle events for ${machineCode} on ${formatDate(dateValue)}. Submitting the form will add another event.`;
                    idleEntryNotice.hidden = false;
                } else if (latest) {
                    const startTime = toTimeInputValue(latest.started_at) || "?";
                    const endTime = latest.ended_at ? toTimeInputValue(latest.ended_at) : "ongoing";
                    idleEntryNotice.textContent = `Latest record spans ${startTime} to ${endTime}.`;
                    idleEntryNotice.hidden = false;
                } else {
                    idleEntryNotice.hidden = true;
                    idleEntryNotice.textContent = "";
                }
            }
        }

        async function refreshIdleAnalytics() {
            if (!idleEntryForm) return;
            const dateValue = idleDateInput?.value || todayDateString;
            const machineCodes = getTrackedMachineCodes();

            try {
                const [summary, events] = await Promise.all([
                    fetchIdleSummary(dateValue, machineCodes),
                    fetchIdleEventsForDate(dateValue, machineCodes),
                ]);
                idleEvents = Array.isArray(events) ? events : [];
                applyIdleAnalytics(summary, idleEvents, dateValue, machineCodes);
                prefillIdleForm();
            } catch (error) {
                if (idleEntryError) {
                    idleEntryError.textContent = error.message || "Unable to load idle analytics.";
                    idleEntryError.hidden = false;
                }
            }
        }

        async function fetchIdleSummary(dateValue, machineCodes) {
            const monthKey = (dateValue || "").slice(0, 7);
            if (!monthKey) {
                return null;
            }
            const cacheKey = buildIdleSummaryCacheKey(monthKey, machineCodes);
            if (cacheKey && idleSummaryCache.has(cacheKey)) {
                return idleSummaryCache.get(cacheKey);
            }

            const params = new URLSearchParams({ period: monthKey });
            if (machineCodes.length > 0) {
                params.set("machine_codes", machineCodes.join(","));
            }
            params.set("shape", "ui");
            const summary = await fetchJson(`/api/production/monthly/idle-summary?${params.toString()}`);
            if (cacheKey) {
                idleSummaryCache.set(cacheKey, summary);
            }
            return summary;
        }

        async function fetchIdleEventsForDate(dateValue, machineCodes) {
            const params = new URLSearchParams({ start_date: dateValue, end_date: dateValue });
            if (machineCodes.length > 0) {
                params.set("machine_codes", machineCodes.join(","));
            }
            return fetchJson(`/api/machines/idle-events?${params.toString()}`);
        }

        function applyIdleAnalytics(summary, events, dateValue, machineCodes) {
            const requestedCodes = normalizeMachineCodes(machineCodes);
            const summaryCodes = normalizeMachineCodes(summary?.machine_codes || []);
            const cardCodes = normalizeMachineCodes(
                machineCards.map((card) => card.dataset.machineCard)
            );
            const trackedCodes =
                requestedCodes.length > 0
                    ? requestedCodes
                    : summaryCodes.length > 0
                    ? summaryCodes
                    : cardCodes;

            const metricsByMachine = new Map();
            const reasonStats = new Map();
            const eventsByMachine = new Map();
            const pulseDataByMachine = new Map();
            let totalRuntimeAll = 0;
            let totalIdle = 0;
            let totalExtended = 0;

            if (summary?.machines) {
                summary.machines.forEach((meta) => {
                    if (meta?.code && meta?.name) {
                        if (!machineMetadata.has(meta.code)) {
                            machineMetadata.set(meta.code, { title: meta.name });
                        }
                    }
                });
            }

            const dayEntry = summary?.day_entries?.find((entry) => entry.date === dateValue);

            events.forEach((event) => {
                const code = event?.asset?.code;
                if (!code) return;
                const normalizedCode = code.toUpperCase();
                const eventList = eventsByMachine.get(normalizedCode) || [];
                eventList.push(event);
                eventsByMachine.set(normalizedCode, eventList);

                const reasonLabel = formatIdleReasonLabel(event.reason, event.secondary_reason);
                if (reasonLabel) {
                    const durationHours = getEventIdleMinutesWithinShift(event, dateValue) / 60;
                    const stat = reasonStats.get(reasonLabel) || { hours: 0, count: 0 };
                    stat.hours += durationHours;
                    stat.count += 1;
                    reasonStats.set(reasonLabel, stat);
                }
            });

            const machineCardMap = new Map();
            machineCards.forEach((card) => {
                const code = card.dataset.machineCard;
                if (code) machineCardMap.set(code.toUpperCase(), card);
            });

            trackedCodes.forEach((code) => {
                const normalizedCode = code.toUpperCase();
                const machineEntry = dayEntry?.machines?.[normalizedCode] || {};
                const machineEvents = eventsByMachine.get(normalizedCode) || [];
                const prominentEvent = machineEvents
                    .slice()
                    .sort(
                        (a, b) =>
                            getEventIdleMinutesWithinShift(b, dateValue) -
                            getEventIdleMinutesWithinShift(a, dateValue)
                    )[0];

                const scheduledMinutes = SHIFT_DURATION_HOURS * 60;
                const eventIdleMinutes = machineEvents
                    .map((event) => getEventIdleMinutesWithinShift(event, dateValue))
                    .reduce((total, minutes) => total + minutes, 0);
                const clampedEventIdleMinutes = Math.min(Math.max(eventIdleMinutes, 0), scheduledMinutes);
                const eventIdleHoursRaw = clampedEventIdleMinutes / 60;

                const totalRuntimeHoursRaw = Math.max(Number(machineEntry.runtime_hours) || 0, 0);
                const fallbackIdleHoursRaw = Math.max(Number(machineEntry.idle_hours) || 0, 0);
                const idleHoursRaw =
                    clampedEventIdleMinutes > 0 ? eventIdleHoursRaw : fallbackIdleHoursRaw;
                const idleHoursCapped = Math.max(
                    Math.min(idleHoursRaw, SHIFT_DURATION_HOURS),
                    0
                );

                const shiftRuntimeHoursRaw = Math.min(totalRuntimeHoursRaw, SHIFT_DURATION_HOURS);
                const effectiveWithinShiftRaw = Math.max(
                    Math.min(shiftRuntimeHoursRaw, SHIFT_DURATION_HOURS - idleHoursCapped),
                    0
                );
                const extendedHoursRaw = Math.max(
                    totalRuntimeHoursRaw - effectiveWithinShiftRaw,
                    0
                );

                const primaryReason = (prominentEvent?.reason || "").trim();
                const secondaryReason = (prominentEvent?.secondary_reason || "").trim();
                const reasonLabel = formatIdleReasonLabel(primaryReason, secondaryReason);

                const prominentEventIdleHours = prominentEvent
                    ? Number(
                          (
                              getEventIdleMinutesWithinShift(prominentEvent, dateValue) /
                              60
                          ).toFixed(3)
                      )
                    : 0;

                const effectiveRuntime = Number(effectiveWithinShiftRaw.toFixed(3));
                const idleHours = Number(idleHoursCapped.toFixed(3));
                const extendedHours = Number(extendedHoursRaw.toFixed(3));
                const totalRuntime = Number(
                    (effectiveWithinShiftRaw + extendedHoursRaw).toFixed(3)
                );

                const metrics = {
                    effectiveRuntime,
                    idleTime: idleHours,
                    extendedRuntime: extendedHours,
                    totalRuntime,
                    utilisation: SHIFT_DURATION_HOURS
                        ? Math.min(effectiveWithinShiftRaw / SHIFT_DURATION_HOURS, 1)
                        : 0,
                    reason: reasonLabel,
                    reasonPrimary: primaryReason,
                    reasonSecondary: secondaryReason,
                    prominentEventId: prominentEvent?.id ?? null,
                    prominentEventIdleHours,
                    notes: prominentEvent?.notes || "",
                    hasEntry:
                        totalRuntime > 0 || idleHours > 0 || machineEvents.length > 0,
                    events: machineEvents,
                };

                metricsByMachine.set(normalizedCode, metrics);
                pulseDataByMachine.set(normalizedCode, {
                    slots: buildIdlePulseSlots(machineEvents, dateValue, metrics),
                    metrics,
                    machineName: machineMetadata.get(normalizedCode)?.title || code,
                });
                totalRuntimeAll += metrics.totalRuntime;
                totalIdle += metrics.idleTime;
                totalExtended += metrics.extendedRuntime;

                const card = machineCardMap.get(normalizedCode);
                if (card) {
                    updateMachineCard(card, code, metrics, machineEvents);
                }
            });

            if (idlePulseGrid) {
                renderIdlePulseGrid(idlePulseGrid, trackedCodes, pulseDataByMachine, dateValue);
            }

            if (idleStatRuntime) {
                idleStatRuntime.textContent = formatHours(totalRuntimeAll);
            }
            if (idleStatIdle) {
                idleStatIdle.textContent = formatHours(totalIdle);
            }
            if (idleStatExtended) {
                idleStatExtended.textContent = formatHours(totalExtended);
            }

            updateIdleInsights(
                metricsByMachine,
                reasonStats,
                totalIdle,
                totalExtended,
                trackedCodes
            );
        }

        function updateMachineCard(card, machineCode, metrics, machineEvents) {
            const runtimeEl = card.querySelector("[data-machine-runtime]");
            const idleEl = card.querySelector("[data-machine-idle]");
            const extendedEl = card.querySelector("[data-machine-extended]");
            const utilisationEl = card.querySelector("[data-machine-utilisation]");
            const reasonEl = card.querySelector("[data-machine-reason]");
            const noteEl = card.querySelector("[data-machine-note]");
            const statusEl = card.querySelector("[data-machine-status]");
            const progressEl = card.querySelector("[data-machine-progress]");

            if (runtimeEl) runtimeEl.textContent = formatHours(metrics.totalRuntime);
            if (idleEl) idleEl.textContent = formatHours(metrics.idleTime);
            if (extendedEl) extendedEl.textContent = formatHours(metrics.extendedRuntime);
            if (utilisationEl) utilisationEl.textContent = `${Math.round(metrics.utilisation * 100)}%`;

            const status = determineStatus(metrics.utilisation, metrics.idleTime, metrics.hasEntry);
            if (statusEl) {
                statusEl.textContent = status.label;
                statusEl.dataset.statusLevel = status.level;
            }

            if (progressEl) {
                progressEl.style.width = `${Math.min(100, Math.round(metrics.utilisation * 100))}%`;
            }

            if (reasonEl) {
                if (!metrics.hasEntry) {
                    reasonEl.textContent = "Awaiting downtime capture for this date.";
                } else if (metrics.idleTime <= 0.05) {
                    reasonEl.textContent = "Fully utilised within the 12-hour shift window.";
                } else if (metrics.reason) {
                    const prominentEvent =
                        machineEvents?.find((event) => event?.id === metrics.prominentEventId) ||
                        machineEvents?.find((event) => {
                            const eventPrimary = (event?.reason || "").trim();
                            const eventSecondary = (event?.secondary_reason || "").trim();
                            return (
                                eventPrimary === (metrics.reasonPrimary || "") &&
                                eventSecondary === (metrics.reasonSecondary || "")
                            );
                        }) ||
                        null;
                    const durationHours =
                        prominentEvent && metrics.prominentEventIdleHours > 0
                            ? metrics.prominentEventIdleHours
                            : metrics.idleTime;
                    reasonEl.textContent = `${metrics.reason} caused ${formatHours(durationHours)} of idle time.`;
                } else {
                    reasonEl.textContent = `Idle time of ${formatHours(metrics.idleTime)} recorded without a reason.`;
                }
            }

            if (noteEl) {
                const prominentEvent = machineEvents?.find((event) => event?.notes);
                noteEl.textContent = metrics.hasEntry ? prominentEvent?.notes || metrics.notes || "" : "";
            }

            if (machineCode && !machineMetadata.has(machineCode)) {
                machineMetadata.set(machineCode, { title: machineCode });
            }
        }

        function determineStatus(utilisation, idleTime, hasEntry) {
            if (!hasEntry) {
                return { label: "Awaiting data", level: "neutral" };
            }
            if (utilisation >= 0.9) {
                return { label: "On target", level: "positive" };
            }
            if (utilisation >= 0.75) {
                return { label: "Monitor", level: "warning" };
            }
            if (idleTime > 0) {
                return { label: "Idle risk", level: "alert" };
            }
            return { label: "Awaiting data", level: "neutral" };
        }

        function updateIdleInsights(metricsByMachine, reasonStats, totalIdle, totalExtended, machineCodes) {
            if (idleInsightsList) {
                idleInsightsList.innerHTML = "";
            }
            if (idleReasonPills) {
                idleReasonPills.innerHTML = "";
            }

            const insights = [];
            const metricsEntries = Array.from(metricsByMachine.entries());
            const recorded = metricsEntries.filter(([, metrics]) => metrics.hasEntry);
            const missingCount = machineCodes.length - recorded.length;
            const topMachine = recorded
                .slice()
                .sort((a, b) => b[1].idleTime - a[1].idleTime)[0];

            if (topMachine && topMachine[1].idleTime > 0.05) {
                const machineLabel = machineMetadata.get(topMachine[0])?.title || topMachine[0];
                const reasonText = topMachine[1].reason ? ` (${topMachine[1].reason})` : "";
                insights.push(`${machineLabel} lost ${formatHours(topMachine[1].idleTime)}${reasonText}. Align maintenance and materials to recover capacity.`);
            } else if (recorded.length) {
                insights.push("All tracked machines achieved the planned 12-hour shift runtime.");
            } else {
                insights.push("No idle records captured for this date. Log downtime to surface trends.");
            }

            if (missingCount > 0) {
                insights.push(`${missingCount} machine${missingCount > 1 ? "s" : ""} awaiting downtime capture.`);
            }

            if (totalExtended > 0.1) {
                insights.push(`Overtime delivered ${formatHours(totalExtended)} of additional output. Confirm labour and energy plans.`);
            }

            if (reasonStats.size > 0) {
                const reasonLeaders = Array.from(reasonStats.entries()).sort((a, b) => b[1].hours - a[1].hours);
                const [topReason, topStats] = reasonLeaders[0];
                insights.push(`${topReason} drove ${formatHours(topStats.hours)} across ${topStats.count} event${topStats.count > 1 ? "s" : ""}.`);
                reasonLeaders.forEach(([reason, stats]) => {
                    const chip = document.createElement("span");
                    chip.className = "reason-chip";
                    chip.textContent = `${reason} · ${formatHours(stats.hours)}`;
                    idleReasonPills?.appendChild(chip);
                });
            } else {
                const chip = document.createElement("span");
                chip.className = "reason-chip reason-chip--muted";
                chip.textContent = "No idle reasons captured";
                idleReasonPills?.appendChild(chip);
            }

            insights.slice(0, 3).forEach((message) => {
                if (!idleInsightsList) return;
                const item = document.createElement("li");
                item.textContent = message;
                idleInsightsList.appendChild(item);
            });
        }

        async function handleIdleFormSubmit(event) {
            event.preventDefault();
            hideIdleMessages();

            if (!canLogIdle) {
                return;
            }

            const machineCode = idleMachineSelect?.value || "";
            const dateValue = idleDateInput?.value || todayDateString;
            const startTime = idleStartTimeInput?.value || "";
            const endTime = idleEndTimeInput?.value || "";
            const reason = idleReasonSelect?.value || "";
            const secondaryReason = idleSecondaryReasonSelect?.value || "";
            const notes = idleNotesInput?.value?.trim() || "";

            if (!machineCode) {
                if (idleEntryError) {
                    idleEntryError.textContent = "Select a machine to continue.";
                    idleEntryError.hidden = false;
                }
                return;
            }

            if (!startTime) {
                if (idleEntryError) {
                    idleEntryError.textContent = "Provide the idle start time.";
                    idleEntryError.hidden = false;
                }
                return;
            }

            if (requiresSecondaryReason(reason) && !secondaryReason) {
                if (idleEntryError) {
                    idleEntryError.textContent = "Select a secondary idle reason.";
                    idleEntryError.hidden = false;
                }
                return;
            }

            const asset = assets.find(
                (item) => item?.code && item.code.toUpperCase() === machineCode.toUpperCase()
            );

            if (!asset) {
                if (idleEntryError) {
                    idleEntryError.textContent = "Select a machine from the registered assets before logging idle time.";
                    idleEntryError.hidden = false;
                }
                return;
            }

            const startDateTime = `${dateValue}T${startTime}`;
            let endDateTime = null;
            if (endTime) {
                let endDate = dateValue;
                const [startHour, startMinute] = startTime.split(":").map((value) => Number.parseInt(value, 10));
                const [endHour, endMinute] = endTime.split(":").map((value) => Number.parseInt(value, 10));
                if (
                    Number.isFinite(startHour) &&
                    Number.isFinite(startMinute) &&
                    Number.isFinite(endHour) &&
                    Number.isFinite(endMinute) &&
                    (endHour < startHour || (endHour === startHour && endMinute < startMinute))
                ) {
                    endDate = addDaysToDateString(dateValue, 1);
                }
                endDateTime = `${endDate}T${endTime}`;
            }

            try {
                const conflict = await findProductionConflictForIdle(
                    machineCode,
                    dateValue,
                    startDateTime,
                    endDateTime,
                );
                if (conflict) {
                    if (idleEntryError) {
                        const message = formatConflictMessage(
                            conflict,
                            "Idle window overlaps with recorded production.",
                            { referenceDate: dateValue },
                        );
                        idleEntryError.textContent = message;
                        idleEntryError.hidden = false;
                    }
                    return;
                }
            } catch (precheckError) {
                console.warn("Idle production pre-check failed", precheckError);
            }

            const payload = {
                asset_id: asset.id,
                analysis_date: dateValue,
                started_at: startDateTime,
                ended_at: endDateTime,
                reason: reason || null,
                secondary_reason: secondaryReason || null,
                notes: notes || null,
            };

            try {
                await fetchJson("/api/machines/idle-events", {
                    method: "POST",
                    body: JSON.stringify(payload),
                });
                if (idleEntrySuccess) {
                    const startLabel = startTime;
                    const endLabel = endTime || "ongoing";
                    idleEntrySuccess.textContent = `Recorded idle window ${startLabel} – ${endLabel} for ${machineCode}.`;
                    idleEntrySuccess.hidden = false;
                }
                const trackedCodes = getTrackedMachineCodes();
                const monthKey = (dateValue || "").slice(0, 7);
                invalidateIdleSummaryCache(monthKey, trackedCodes);
                await refreshIdleAnalytics();
            } catch (error) {
                if (idleEntryError) {
                    let message = error.message || "Unable to save idle record.";
                    if (error.status === 409 && error.payload?.conflict) {
                        message = formatConflictMessage(error.payload.conflict, message, {
                            referenceDate: dateValue,
                        });
                    }
                    idleEntryError.textContent = message;
                    idleEntryError.hidden = false;
                }
            }
        }

        function formatHours(value) {
            if (value == null || Number.isNaN(value)) return "0.0 h";
            const rounded = Math.round(value * 10) / 10;
            return `${rounded.toFixed(1)} h`;
        }

        function renderSuppliers(suppliers) {
            if (!suppliersTableBody) return;

            suppliersTableBody.innerHTML = "";
            if (!Array.isArray(suppliers) || suppliers.length === 0) {
                if (suppliersEmpty) suppliersEmpty.hidden = false;
                return;
            }
            if (suppliersEmpty) suppliersEmpty.hidden = true;
            suppliers.forEach((supplier) => {
                const row = document.createElement("tr");
                row.innerHTML = `
                    <td data-label="Name">${supplier.name}</td>
                    <td data-label="Contact">${supplier.contact_person || "—"}</td>
                    <td data-label="Phone">${supplier.phone || "—"}</td>
                    <td data-label="Email">${supplier.email || "—"}</td>
                    <td data-label="Services">${supplier.services_offered || "—"}</td>
                `;
                suppliersTableBody.appendChild(row);
            });
        }

        async function loadEmployees() {
            try {
                const members = await fetchJson("/api/team/members");
                const filtered = Array.isArray(members)
                    ? members
                          .slice()
                          .filter((member) => {
                              if (!member) return false;
                              const statusText = (member.status || "").toString().toLowerCase();
                              if (!statusText) return true;
                              return statusText === "active";
                          })
                          .sort((a, b) => {
                              const codeA = (a?.regNumber || a?.reg_number || "").toString();
                              const codeB = (b?.regNumber || b?.reg_number || "").toString();
                              if (codeA && codeB) {
                                  return codeA.localeCompare(codeB, undefined, { sensitivity: "base" });
                              }
                              const nameA = (a?.name || "").toString();
                              const nameB = (b?.name || "").toString();
                              return nameA.localeCompare(nameB, undefined, { sensitivity: "base" });
                          })
                    : [];
                activeEmployees = filtered;
            } catch (error) {
                console.error("Failed to load employees", error);
                activeEmployees = [];
            }
            updateInternalStaffEmployeeOptions();
        }

        async function loadSuppliers() {
            if (supplierError) {
                supplierError.hidden = true;
                supplierError.textContent = "";
            }
            try {
                const suppliers = await fetchJson("/api/machines/service-suppliers");
                const sortedSuppliers = Array.isArray(suppliers)
                    ? suppliers
                          .slice()
                          .sort((a, b) => (a?.name || "").localeCompare(b?.name || "", undefined, { sensitivity: "base" }))
                    : [];
                renderSuppliers(sortedSuppliers);
                serviceSuppliers = sortedSuppliers.filter((supplier) => {
                    if (!supplier) return false;
                    if (Object.prototype.hasOwnProperty.call(supplier, "is_active")) {
                        return Boolean(supplier.is_active);
                    }
                    return true;
                });
                updateOutsourcedSupplierOptions();
            } catch (error) {
                if (supplierError) {
                    supplierError.textContent = error.message || "Unable to load suppliers";
                    supplierError.hidden = false;
                }
                renderSuppliers([]);
                serviceSuppliers = [];
                updateOutsourcedSupplierOptions();
            }
        }

        refreshSuppliersButton?.addEventListener("click", loadSuppliers);

        if (canAddSuppliers && supplierForm) {
            supplierForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                if (supplierFormSuccess) supplierFormSuccess.hidden = true;
                if (supplierFormError) supplierFormError.hidden = true;
                const formData = new FormData(supplierForm);
                const payload = {
                    name: formData.get("name")?.trim(),
                    contact_person: formData.get("contact_person")?.trim() || null,
                    phone: formData.get("phone")?.trim() || null,
                    email: formData.get("email")?.trim() || null,
                    services_offered: formData.get("services_offered")?.trim() || null,
                    preferred_assets: formData.get("preferred_assets")?.trim() || null,
                    notes: formData.get("notes")?.trim() || null,
                };
                if (!payload.name && supplierFormError) {
                    supplierFormError.textContent = "Supplier name is required.";
                    supplierFormError.hidden = false;
                    return;
                }
                const submitButton = supplierForm.querySelector('button[type="submit"]');
                submitButton.disabled = true;
                try {
                    await fetchJson("/api/machines/service-suppliers", {
                        method: "POST",
                        body: JSON.stringify(payload),
                    });
                    supplierForm.reset();
                    if (supplierFormSuccess) supplierFormSuccess.hidden = false;
                    await loadSuppliers();
                } catch (error) {
                    if (supplierFormError) {
                        supplierFormError.textContent = error.message || "Unable to add supplier";
                        supplierFormError.hidden = false;
                    }
                } finally {
                    submitButton.disabled = false;
                }
            });
        }

        Promise.resolve(loadAssets()).catch(() => {});
        Promise.resolve(loadMaintenanceParts()).catch(() => {});
        Promise.resolve(loadJobs()).catch(() => {});
        Promise.resolve(initializeIdleAnalytics()).catch(() => {});
        Promise.resolve(loadEmployees()).catch(() => {});
        Promise.resolve(loadSuppliers()).catch(() => {});

    </script>
</body>
</html>
