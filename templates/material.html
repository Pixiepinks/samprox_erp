<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Material | SAMPROX ERP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}" />
</head>
<body>
    <div class="page">
        <header class="topbar">
            <div class="brand">
                <div class="brand__logo">S</div>
                <div class="brand__details">
                    <p class="brand__name">SAMPROX ERP</p>
                    <p class="brand__section">Material Control</p>
                </div>
            </div>
            <div class="topbar__actions">
                <a class="button button--ghost" href="{{ url_for('ui.mind_page') }}">Mind</a>
                <div class="user-summary">
                    <span class="user-summary__name" id="user-name"></span>
                    <span class="user-summary__role" id="user-role"></span>
                </div>
                <button type="button" class="button button--secondary" id="logout">Sign out</button>
            </div>
        </header>
        <nav class="subnav" aria-label="7M navigation">
            <a class="subnav__link" href="{{ url_for('ui.mind_page') }}">Mind</a>
            <a class="subnav__link" href="{{ url_for('ui.man_page') }}">Man</a>
            <a class="subnav__link" href="{{ url_for('ui.machines_page') }}">Machine</a>
            <a class="subnav__link subnav__link--active" href="{{ url_for('ui.material_page') }}">Material</a>
            <a class="subnav__link" href="{{ url_for('ui.market_page') }}">Market</a>
            <a class="subnav__link" href="{{ url_for('ui.manufacturing_page') }}">Manufacturing</a>
            <a class="subnav__link" href="{{ url_for('ui.money_page') }}">Money</a>
        </nav>
        <section class="section">
            <header class="section__header">
                <h1>Inventory & supply visibility</h1>
            </header>
            <p class="section__description">
                Keep production running by tracking raw materials, spare parts, and consumables. Review
                what is on hand, what is reserved for jobs, and what needs to be ordered next.
            </p>
            <div class="section__grid">
                <article class="tile">
                    <h2 class="tile__title">Stock snapshot</h2>
                    <p class="tile__description">
                        Monitor inventory aging and reorder thresholds to prevent stock-outs.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Supplier performance</h2>
                    <p class="tile__description">
                        Review supplier lead times and delivery quality to guide purchasing decisions.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Consumption trends</h2>
                    <p class="tile__description">
                        Analyze how materials are consumed across jobs to forecast future demand.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Pending requisitions</h2>
                    <p class="tile__description">
                        Follow up on open purchase requests and approvals so critical parts arrive on
                        time.
                    </p>
                </article>
            </div>
            <div class="material-receipts-card stock-status-card">
                <div class="material-receipts-card__header stock-status-card__header">
                    <div>
                        <h2 class="material-receipts-card__title">Stock Status</h2>
                        <p class="material-receipts-card__meta">
                            Review closing balances for each material as at the selected date.
                        </p>
                    </div>
                    <div class="stock-status-card__controls">
                        <label class="stock-status-card__label" for="stock-status-date">
                            Closing stock as at
                        </label>
                        <input
                            class="stock-status-card__input"
                            type="date"
                            id="stock-status-date"
                            name="stock-status-date"
                        />
                    </div>
                </div>
                <div class="stock-status-card__chart" id="stock-status-chart-container" hidden>
                    <canvas
                        id="stock-status-chart"
                        height="320"
                        aria-label="Stock status cylinder chart"
                        role="img"
                    ></canvas>
                </div>
                <p class="empty-state" id="stock-status-empty">Loading stock status…</p>
                <div class="table-wrapper" id="stock-status-table-wrapper" hidden>
                    <table class="data-table" id="stock-status-table">
                        <thead>
                            <tr>
                                <th scope="col">Item Name</th>
                                <th scope="col">Qty (Ton)</th>
                                <th scope="col">Unit Cost (Rs./Ton)</th>
                                <th scope="col">Value (Rs.)</th>
                            </tr>
                        </thead>
                        <tbody id="stock-status-table-body"></tbody>
                    </table>
                </div>
            </div>
            <div class="material-receipts-card supplier-registry-card">
                <div class="material-receipts-card__header">
                    <div>
                        <h2 class="material-receipts-card__title">Supplier registry</h2>
                        <p class="material-receipts-card__meta">
                            Review registered suppliers and keep their contact details at your fingertips.
                        </p>
                    </div>
                    <a class="button" href="{{ url_for('ui.material_mrn_new_page') }}">Register supplier</a>
                </div>
                <form class="material-receipts-card__search" id="supplier-search-form">
                    <label class="sr-only" for="supplier-search-input">Search suppliers</label>
                    <input
                        id="supplier-search-input"
                        type="search"
                        name="q"
                        placeholder="Search by supplier name, registration, or contact"
                        autocomplete="off"
                    />
                    <div class="material-receipts-card__actions">
                        <button type="submit" class="button button--secondary">Search</button>
                        <button type="button" class="button button--ghost" id="supplier-clear-button">Clear</button>
                    </div>
                </form>
                <p class="empty-state" id="supplier-empty-state">Loading suppliers…</p>
                <div class="table-wrapper" id="supplier-table-wrapper" hidden>
                    <table class="data-table" id="supplier-table">
                        <thead>
                            <tr>
                                <th scope="col">Supplier</th>
                                <th scope="col">Registration no.</th>
                                <th scope="col">Category</th>
                                <th scope="col">Primary phone</th>
                                <th scope="col">Credit period</th>
                            </tr>
                        </thead>
                        <tbody id="supplier-table-body"></tbody>
                    </table>
                </div>
            </div>
            <div class="material-receipts-card">
                <div class="material-receipts-card__header">
                    <div>
                        <h2 class="material-receipts-card__title">Material receipts</h2>
                        <p class="material-receipts-card__meta">
                            Review the latest material receipt notes recorded by your team.
                        </p>
                    </div>
                    <a class="button" href="{{ url_for('ui.material_mrn_new_page') }}">Record material receipt</a>
                </div>
                <form class="material-receipts-card__search" id="mrn-search-form">
                    <label class="sr-only" for="mrn-search-input">Search material receipts</label>
                    <input
                        id="mrn-search-input"
                        type="search"
                        name="q"
                        placeholder="Search by MRN number, supplier, or material"
                        autocomplete="off"
                    />
                    <div class="material-receipts-card__actions">
                        <button type="submit" class="button button--secondary">Search</button>
                        <button type="button" class="button button--ghost" id="mrn-clear-button">Clear</button>
                    </div>
                </form>
                <p class="empty-state" id="mrn-empty-state">Loading material receipts…</p>
                <div class="table-wrapper" id="mrn-table-wrapper" hidden>
                    <table class="data-table" id="mrn-table">
                        <thead>
                            <tr>
                                <th scope="col">MRN number</th>
                                <th scope="col">Date</th>
                                <th scope="col">Supplier</th>
                                <th scope="col">Material</th>
                                <th scope="col">Qty (Ton)</th>
                                <th scope="col">Amount</th>
                            </tr>
                        </thead>
                        <tbody id="mrn-table-body"></tbody>
                    </table>
                </div>
            </div>
            <div class="material-receipts-card" id="briquette-production-card">
                <div class="material-receipts-card__header">
                    <div>
                        <h2 class="material-receipts-card__title">Production Entry – Briquette Production</h2>
                        <p class="material-receipts-card__meta">
                            Monitor briquette output alongside the daily material mix and FIFO cost.
                        </p>
                    </div>
                </div>
                <p class="empty-state" id="briquette-production-empty">Loading briquette production…</p>
                <div class="table-wrapper" id="briquette-production-table-wrapper" hidden>
                    <table class="data-table" id="briquette-production-table">
                        <thead>
                            <tr>
                                <th scope="col" rowspan="2">Date</th>
                                <th scope="col" rowspan="2">Briquette Production (Ton)</th>
                                <th scope="col" colspan="5">Material Consumed (Ton)</th>
                                <th scope="col" rowspan="2">Unit Cost of Briquette (Kg)</th>
                                <th scope="col" rowspan="2">Total Material Cost</th>
                                <th scope="col" rowspan="2">Update Mix</th>
                            </tr>
                            <tr id="briquette-material-headings">
                                <th scope="col">Sawdust</th>
                                <th scope="col">Wood Shaving</th>
                                <th scope="col">Wood Powder</th>
                                <th scope="col">Peanut Husk</th>
                                <th scope="col">Fire Cut</th>
                            </tr>
                        </thead>
                        <tbody id="briquette-production-table-body"></tbody>
                    </table>
                </div>
            </div>
        </section>
    </div>
    <div class="modal" id="briquette-mix-modal" hidden aria-hidden="true">
        <div class="modal__overlay" data-modal-dismiss></div>
        <div class="modal__content" role="dialog" aria-modal="true" aria-labelledby="briquette-mix-title">
            <header class="modal__header modal__header--with-actions">
                <div>
                    <h2 class="modal__title" id="briquette-mix-title">Update mix</h2>
                    <p class="modal__subtitle" id="briquette-mix-subtitle">
                        Adjust material usage and let the system recalculate FIFO costs automatically.
                    </p>
                </div>
                <button type="button" class="modal__close" id="briquette-mix-close" aria-label="Close mix editor">
                    &times;
                </button>
            </header>
            <div class="modal__body">
                <form class="modal__form" id="briquette-mix-form">
                    <div class="modal__grid">
                        <label class="modal__field">
                            <span class="modal__label">Date</span>
                            <input id="briquette-mix-date" type="text" class="modal__input" readonly />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Dry factor</span>
                            <input
                                id="briquette-dry-factor"
                                name="dry_factor"
                                type="number"
                                step="0.0001"
                                min="0"
                                class="modal__input"
                                autocomplete="off"
                            />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Sawdust (Ton)</span>
                            <input id="briquette-sawdust" type="number" class="modal__input" readonly />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Wood Shaving (Ton)</span>
                            <input
                                id="briquette-wood-shaving"
                                name="wood_shaving_ton"
                                type="number"
                                step="0.001"
                                min="0"
                                class="modal__input"
                                autocomplete="off"
                                readonly
                            />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Wood Powder (Ton)</span>
                            <input
                                id="briquette-wood-powder"
                                name="wood_powder_ton"
                                type="number"
                                step="0.001"
                                min="0"
                                class="modal__input"
                                autocomplete="off"
                            />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Peanut Husk (Ton)</span>
                            <input
                                id="briquette-peanut-husk"
                                name="peanut_husk_ton"
                                type="number"
                                step="0.001"
                                min="0"
                                class="modal__input"
                                autocomplete="off"
                            />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Fire Cut (Ton)</span>
                            <input
                                id="briquette-fire-cut"
                                name="fire_cut_ton"
                                type="number"
                                step="0.001"
                                min="0"
                                class="modal__input"
                                autocomplete="off"
                            />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Dry Material (Ton)</span>
                            <input
                                id="briquette-dry-material"
                                type="number"
                                step="0.001"
                                class="modal__input"
                                readonly
                            />
                        </label>
                        <label class="modal__field">
                            <span class="modal__label">Dryer Actual Running Hours</span>
                            <input
                                id="briquette-dryer-actual-hours"
                                type="number"
                                step="0.1"
                                class="modal__input"
                                readonly
                            />
                        </label>
                    </div>
                    <div class="modal__field modal__field--full">
                        <span class="modal__label">Total briquette output</span>
                        <p class="modal__hint"><span id="briquette-output-kg">0.00</span> kg</p>
                    </div>
                    <div class="table-wrapper">
                        <table class="data-table data-table--compact" id="briquette-cost-table">
                            <thead>
                                <tr>
                                    <th scope="col">Material</th>
                                    <th scope="col">Qty (Kg)</th>
                                    <th scope="col">Qty (Ton)</th>
                                    <th scope="col">Purchase Price (Rs/Kg)</th>
                                    <th scope="col">Total Cost (Rs)</th>
                                </tr>
                            </thead>
                            <tbody id="briquette-cost-table-body"></tbody>
                        </table>
                    </div>
                    <div class="modal__field modal__field--full">
                        <p class="modal__label">Total material cost</p>
                        <p class="modal__hint" id="briquette-total-cost">Rs 0.00</p>
                    </div>
                    <div class="modal__field modal__field--full">
                        <p class="modal__label">Unit cost of briquette (per Kg)</p>
                        <p class="modal__hint" id="briquette-unit-cost">Rs 0.0000</p>
                    </div>
                    <p class="modal__feedback" id="briquette-mix-feedback" hidden></p>
                    <p class="modal__feedback modal__feedback--error" id="briquette-mix-error" hidden></p>
                    <div class="modal__actions">
                        <button type="button" class="button button--ghost" id="briquette-mix-cancel">Cancel</button>
                        <button type="submit" class="button" id="briquette-mix-save">Save mix</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script>
        const token = localStorage.getItem("samprox_token");
        const userRaw = localStorage.getItem("samprox_user");
        let user;

        try {
            user = userRaw ? JSON.parse(userRaw) : null;
        } catch (_) {
            user = null;
        }

        if (!token || !user) {
            window.location.href = "/";
        }

        if (user?.role === "maintenance_manager" && window.location.pathname !== "/machines") {
            window.location.replace("/machines");
        }

        const roleLabels = {
            admin: "Admin",
            production_manager: "Production Manager",
            maintenance_manager: "Maintenance Manager",
            finance_manager: "Finance Manager",
            technician: "Technician",
        };

        const userNameEl = document.getElementById("user-name");
        const userRoleEl = document.getElementById("user-role");
        const logoutButton = document.getElementById("logout");

        userNameEl.textContent = user?.name || "Unknown";
        userRoleEl.textContent = roleLabels[user?.role] || "";

        logoutButton.addEventListener("click", () => {
            localStorage.removeItem("samprox_token");
            localStorage.removeItem("samprox_user");
            window.location.href = "/";
        });

        const stockStatusTableBody = document.getElementById("stock-status-table-body");
        const stockStatusTableWrapper = document.getElementById("stock-status-table-wrapper");
        const stockStatusEmptyState = document.getElementById("stock-status-empty");
        const stockStatusDateInput = document.getElementById("stock-status-date");
        const stockStatusChartContainer = document.getElementById("stock-status-chart-container");
        const stockStatusChartCanvas = document.getElementById("stock-status-chart");
        const supplierTableBody = document.getElementById("supplier-table-body");
        const supplierTableWrapper = document.getElementById("supplier-table-wrapper");
        const supplierEmptyState = document.getElementById("supplier-empty-state");
        const supplierSearchForm = document.getElementById("supplier-search-form");
        const supplierSearchInput = document.getElementById("supplier-search-input");
        const supplierClearButton = document.getElementById("supplier-clear-button");

        const mrnTableBody = document.getElementById("mrn-table-body");
        const mrnTableWrapper = document.getElementById("mrn-table-wrapper");
        const mrnEmptyState = document.getElementById("mrn-empty-state");
        const mrnSearchForm = document.getElementById("mrn-search-form");
        const mrnSearchInput = document.getElementById("mrn-search-input");
        const mrnClearButton = document.getElementById("mrn-clear-button");
        const briquetteTableBody = document.getElementById("briquette-production-table-body");
        const briquetteTableWrapper = document.getElementById("briquette-production-table-wrapper");
        const briquetteEmptyState = document.getElementById("briquette-production-empty");
        const briquetteMaterialHeadings = document.getElementById("briquette-material-headings");
        const briquetteModal = document.getElementById("briquette-mix-modal");
        const briquetteModalForm = document.getElementById("briquette-mix-form");
        const briquetteModalDate = document.getElementById("briquette-mix-date");
        const briquetteDryFactorInput = document.getElementById("briquette-dry-factor");
        const briquetteSawdustInput = document.getElementById("briquette-sawdust");
        const briquetteWoodShavingInput = document.getElementById("briquette-wood-shaving");
        const briquetteWoodPowderInput = document.getElementById("briquette-wood-powder");
        const briquettePeanutHuskInput = document.getElementById("briquette-peanut-husk");
        const briquetteFireCutInput = document.getElementById("briquette-fire-cut");
        const briquetteDryMaterialInput = document.getElementById("briquette-dry-material");
        const briquetteDryerHoursInput = document.getElementById("briquette-dryer-actual-hours");
        const briquetteOutputKg = document.getElementById("briquette-output-kg");
        const briquetteCostTableBody = document.getElementById("briquette-cost-table-body");
        const briquetteTotalCost = document.getElementById("briquette-total-cost");
        const briquetteUnitCost = document.getElementById("briquette-unit-cost");
        const briquetteModalFeedback = document.getElementById("briquette-mix-feedback");
        const briquetteModalError = document.getElementById("briquette-mix-error");
        const briquetteModalClose = document.getElementById("briquette-mix-close");
        const briquetteModalCancel = document.getElementById("briquette-mix-cancel");
        const briquetteSaveButton = document.getElementById("briquette-mix-save");

        let briquetteMaterialOrder = [];
        let briquetteMaterialLabels = {};
        let briquetteModalDateValue = null;
        let briquetteDryerProductionTon = 0;
        let briquetteTotalOutputTon = 0;
        let briquetteComputedWoodShavingTon = 0;
        let briquetteComputedDryMaterialTon = 0;

        function formatNumber(value, fractionDigits) {
            const numeric = Number.parseFloat(value);
            if (Number.isNaN(numeric)) {
                return "—";
            }
            return numeric.toLocaleString(undefined, {
                minimumFractionDigits: fractionDigits,
                maximumFractionDigits: fractionDigits,
            });
        }

        const chartTonFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2,
        });

        const chartCurrencyFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2,
        });

        function formatChartTons(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return "0";
            }
            return chartTonFormatter.format(numeric);
        }

        function formatChartCurrency(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return null;
            }
            return chartCurrencyFormatter.format(numeric);
        }

        const STOCK_STATUS_CHART_KEYS = [
            "sawdust",
            "wood_shaving",
            "wood_powder",
            "peanut_husk",
            "fire_cut",
            "briquettes",
        ];

        let stockStatusChartInstance = null;
        let stockStatusChartPoints = [];

        function clamp(value, min, max) {
            if (!Number.isFinite(value)) {
                return min;
            }
            return Math.min(Math.max(value, min), max);
        }

        function computeCylinderGeometry(element, value, options = {}) {
            if (!element) {
                return null;
            }

            const props = typeof element.getProps === "function"
                ? element.getProps(["x", "y", "base", "width", "height"], true)
                : {};

            const x = Number.isFinite(props.x) ? props.x : element.x || 0;
            const y = Number.isFinite(props.y) ? props.y : element.y || 0;
            const base = Number.isFinite(props.base) ? props.base : element.base || 0;

            let width = Number.isFinite(props.width) ? props.width : element.width;
            if (!Number.isFinite(width) || width <= 0) {
                width = props.height;
            }
            if (!Number.isFinite(width) || width <= 0) {
                width = element._model?.width;
            }
            if (!Number.isFinite(width) || width <= 0) {
                return null;
            }

            const widthRatio = typeof options.widthRatio === "number" ? options.widthRatio : 1;
            const halfWidth = (width * widthRatio) / 2;
            if (!Number.isFinite(halfWidth) || halfWidth <= 0) {
                return null;
            }

            const top = Math.min(y, base);
            const bottom = Math.max(y, base);
            const height = bottom - top;
            if (!Number.isFinite(height) || height <= 0) {
                return null;
            }

            const capRatio = typeof options.capRatio === "number" ? options.capRatio : 0.3;
            const capRadius = Math.min(halfWidth, Math.max(height * capRatio, 2));
            if (!Number.isFinite(capRadius) || capRadius <= 0) {
                return null;
            }

            const orientation = value >= 0 ? 1 : -1;
            const headY = orientation > 0 ? top : bottom;
            const footY = orientation > 0 ? bottom : top;

            return {
                x,
                y,
                base,
                width,
                height,
                top,
                bottom,
                halfWidth,
                capRadius,
                orientation,
                headY,
                footY,
            };
        }

        function drawRoundedRect(ctx, x, y, width, height, radius) {
            const r = clamp(radius, 0, Math.min(width, height) / 2);
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + width - r, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + r);
            ctx.lineTo(x + width, y + height - r);
            ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
            ctx.lineTo(x + r, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawCylinderSegment(ctx, element, value, options = {}, geometry = null) {
            if (!ctx || !element) {
                return;
            }

            const geom = geometry || computeCylinderGeometry(element, value, options);
            if (!geom) {
                return;
            }

            const {
                x,
                base,
                top,
                bottom,
                halfWidth,
                capRadius,
                orientation,
                headY,
                footY,
            } = geom;

            const gradientStops = Array.isArray(options.gradientStops) && options.gradientStops.length
                ? options.gradientStops
                : [
                      { offset: 0, color: options.lightColor || "#f8fafc" },
                      { offset: 0.5, color: options.baseColor || "#cbd5f5" },
                      { offset: 1, color: options.shadowColor || "#94a3b8" },
                  ];

            const gradient = ctx.createLinearGradient(x - halfWidth, top, x + halfWidth, top);
            gradientStops.forEach((stop, index) => {
                const offset = typeof stop.offset === "number"
                    ? clamp(stop.offset, 0, 1)
                    : gradientStops.length > 1
                        ? index / (gradientStops.length - 1)
                        : 0;
                gradient.addColorStop(offset, stop.color || options.baseColor || "#94a3b8");
            });

            const firstStop = gradientStops[0] || {};
            const lastStop = gradientStops[gradientStops.length - 1] || {};
            const topCapColor = options.topCapColor || firstStop.color || options.lightColor || "#f8fafc";
            const bottomCapColor = options.bottomCapColor || lastStop.color || options.shadowColor || options.baseColor || "#94a3b8";
            const strokeColor = options.strokeColor || "rgba(15, 23, 42, 0.12)";
            const strokeWidth = typeof options.strokeWidth === "number" ? options.strokeWidth : 1;

            const shadowOpacity = typeof options.shadowOpacity === "number" ? options.shadowOpacity : 0.22;
            if (shadowOpacity > 0) {
                const shadowOffsetX = typeof options.shadowOffsetX === "number" ? options.shadowOffsetX : 0;
                const shadowOffsetY = typeof options.shadowOffsetY === "number"
                    ? options.shadowOffsetY
                    : capRadius * 0.75 * orientation;
                const shadowWidthRatio = typeof options.shadowWidthRatio === "number"
                    ? options.shadowWidthRatio
                    : 1.18;
                const shadowHeightRatio = typeof options.shadowHeightRatio === "number"
                    ? options.shadowHeightRatio
                    : 0.65;
                const shadowColor = options.shadowColor || "rgba(15, 23, 42, 0.35)";
                const shadowFadeColor = options.shadowFadeColor || "rgba(15, 23, 42, 0)";
                const shadowX = x + shadowOffsetX;
                const shadowY = base + shadowOffsetY;
                const shadowRadiusX = halfWidth * shadowWidthRatio;
                const shadowRadiusY = capRadius * shadowHeightRatio;

                ctx.save();
                const shadowGradient = ctx.createRadialGradient(
                    shadowX,
                    shadowY,
                    Math.max(shadowRadiusY * 0.25, 1),
                    shadowX,
                    shadowY,
                    Math.max(shadowRadiusX, shadowRadiusY),
                );
                shadowGradient.addColorStop(0, shadowColor);
                shadowGradient.addColorStop(1, shadowFadeColor);
                ctx.fillStyle = shadowGradient;
                ctx.beginPath();
                ctx.ellipse(shadowX, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
                ctx.globalAlpha = shadowOpacity;
                ctx.fill();
                ctx.restore();
            }

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x - halfWidth, top + capRadius);
            ctx.lineTo(x - halfWidth, bottom - capRadius);
            ctx.quadraticCurveTo(x - halfWidth, bottom, x, bottom);
            ctx.quadraticCurveTo(x + halfWidth, bottom, x + halfWidth, bottom - capRadius);
            ctx.lineTo(x + halfWidth, top + capRadius);
            ctx.quadraticCurveTo(x + halfWidth, top, x, top);
            ctx.quadraticCurveTo(x - halfWidth, top, x - halfWidth, top + capRadius);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            if (strokeWidth > 0) {
                ctx.lineWidth = strokeWidth;
                ctx.strokeStyle = strokeColor;
                ctx.stroke();
            }

            const headColor = orientation > 0 ? topCapColor : bottomCapColor;
            const footColor = orientation > 0 ? bottomCapColor : topCapColor;

            ctx.beginPath();
            ctx.ellipse(
                x,
                headY,
                halfWidth,
                capRadius,
                0,
                orientation > 0 ? Math.PI : 0,
                orientation > 0 ? 0 : Math.PI,
            );
            ctx.closePath();
            ctx.fillStyle = headColor;
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(
                x,
                footY,
                halfWidth,
                capRadius,
                0,
                orientation > 0 ? 0 : Math.PI,
                orientation > 0 ? Math.PI : 0,
            );
            ctx.closePath();
            ctx.fillStyle = footColor;
            ctx.fill();

            const glossIntensity = typeof options.glossIntensity === "number" ? options.glossIntensity : 0.45;
            const highlightWidthRatio = typeof options.highlightWidthRatio === "number"
                ? options.highlightWidthRatio
                : 0.42;
            if (glossIntensity > 0 && highlightWidthRatio > 0) {
                const highlightHalfWidth = halfWidth * clamp(highlightWidthRatio, 0.1, 0.95);
                const highlightTop = top + capRadius * 0.25;
                const highlightBottom = bottom - capRadius * 0.2;
                ctx.beginPath();
                ctx.moveTo(x - highlightHalfWidth, highlightTop);
                ctx.lineTo(x - highlightHalfWidth, highlightBottom);
                ctx.quadraticCurveTo(x - highlightHalfWidth, bottom, x, bottom);
                ctx.quadraticCurveTo(x + highlightHalfWidth, bottom, x + highlightHalfWidth, highlightBottom);
                ctx.lineTo(x + highlightHalfWidth, highlightTop);
                ctx.quadraticCurveTo(x + highlightHalfWidth, top, x, top);
                ctx.quadraticCurveTo(x - highlightHalfWidth, top, x - highlightHalfWidth, highlightTop);
                ctx.closePath();

                const highlightGradient = ctx.createLinearGradient(
                    x - highlightHalfWidth,
                    top,
                    x + highlightHalfWidth,
                    top,
                );
                highlightGradient.addColorStop(0, "rgba(255, 255, 255, 0)");
                highlightGradient.addColorStop(0.5, options.highlightColor || "rgba(255, 255, 255, 0.9)");
                highlightGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                ctx.fillStyle = highlightGradient;
                ctx.globalAlpha = glossIntensity;
                ctx.fill();
            }

            const topGlossIntensity = typeof options.topGlossIntensity === "number"
                ? options.topGlossIntensity
                : 0.65;
            if (topGlossIntensity > 0) {
                ctx.beginPath();
                ctx.ellipse(
                    x,
                    headY,
                    halfWidth,
                    capRadius,
                    0,
                    orientation > 0 ? Math.PI : 0,
                    orientation > 0 ? 0 : Math.PI,
                );
                ctx.closePath();
                const highlightY = headY - orientation * capRadius * 0.55;
                const radialGradient = ctx.createRadialGradient(
                    x,
                    highlightY,
                    Math.max(capRadius * 0.15, 1),
                    x,
                    headY,
                    Math.max(capRadius, halfWidth),
                );
                radialGradient.addColorStop(0, "rgba(255, 255, 255, 0.9)");
                radialGradient.addColorStop(0.6, "rgba(255, 255, 255, 0.15)");
                radialGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                ctx.fillStyle = radialGradient;
                ctx.globalAlpha = topGlossIntensity;
                ctx.fill();
            }

            const rimShadowIntensity = typeof options.rimShadowIntensity === "number"
                ? options.rimShadowIntensity
                : 0.35;
            if (rimShadowIntensity > 0) {
                const rimGradient = ctx.createLinearGradient(x, footY - capRadius, x, footY + capRadius);
                rimGradient.addColorStop(0, "rgba(15, 23, 42, 0)");
                rimGradient.addColorStop(0.5, `rgba(15, 23, 42, ${rimShadowIntensity})`);
                rimGradient.addColorStop(1, "rgba(15, 23, 42, 0)");
                ctx.beginPath();
                ctx.ellipse(
                    x,
                    footY,
                    halfWidth,
                    capRadius,
                    0,
                    orientation > 0 ? 0 : Math.PI,
                    orientation > 0 ? Math.PI : 0,
                );
                ctx.closePath();
                ctx.fillStyle = rimGradient;
                ctx.globalAlpha = 1;
                ctx.fill();
            }

            ctx.restore();
        }

        const cylinderBarPlugin = {
            id: "cylinderBarPlugin",
            afterDatasetsDraw(chart, _args, pluginOptions) {
                if (!chart || !chart.ctx) {
                    return;
                }

                const ctx = chart.ctx;
                const defaults = pluginOptions?.defaults || {};
                const pluginValueLabelDefaults = pluginOptions?.valueLabel || {};

                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    const meta = chart.getDatasetMeta(datasetIndex);
                    if (!meta || meta.hidden || dataset.hidden) {
                        return;
                    }

                    meta.data.forEach((element, dataIndex) => {
                        const value = Array.isArray(dataset.data)
                            ? dataset.data[dataIndex]
                            : null;
                        if (!Number.isFinite(value)) {
                            return;
                        }

                        const options = {
                            ...defaults,
                            ...(dataset.cylinder || {}),
                        };

                        const geometry = computeCylinderGeometry(element, value, options);
                        drawCylinderSegment(ctx, element, value, options, geometry);

                        let valueLabelOptions = null;
                        if (pluginValueLabelDefaults && pluginValueLabelDefaults !== true) {
                            valueLabelOptions = { ...pluginValueLabelDefaults };
                            if (valueLabelOptions.enabled === false) {
                                valueLabelOptions = null;
                            }
                        }

                        if (dataset.valueLabel) {
                            if (dataset.valueLabel.enabled === false) {
                                valueLabelOptions = null;
                            } else {
                                valueLabelOptions = {
                                    ...(valueLabelOptions || {}),
                                    ...dataset.valueLabel,
                                    enabled: true,
                                };
                            }
                        }

                        if (valueLabelOptions?.enabled && geometry) {
                            const formatter = typeof valueLabelOptions.formatter === "function"
                                ? valueLabelOptions.formatter
                                : (raw) => formatChartTons(Math.abs(raw));
                            const labelText = formatter(value, {
                                chart,
                                dataset,
                                datasetIndex,
                                dataIndex,
                                geometry,
                            });

                            if (labelText) {
                                const fontFamily = valueLabelOptions.fontFamily
                                    || "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
                                const fontWeight = valueLabelOptions.fontWeight || "600";
                                const fontSize = valueLabelOptions.fontSize || 12;
                                const paddingX = valueLabelOptions.paddingX ?? 8;
                                const paddingY = valueLabelOptions.paddingY ?? 4;
                                const borderRadius = valueLabelOptions.borderRadius ?? 6;
                                const offset = valueLabelOptions.offset ?? 16;
                                const textColor = valueLabelOptions.color || "#0f172a";
                                const backgroundColor = valueLabelOptions.backgroundColor;
                                const borderColor = valueLabelOptions.borderColor || "rgba(15, 23, 42, 0.08)";
                                const borderWidth = valueLabelOptions.borderWidth ?? 1;

                                ctx.save();
                                ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
                                ctx.textAlign = "center";
                                ctx.textBaseline = "middle";

                                const textMetrics = ctx.measureText(labelText);
                                const boxWidth = textMetrics.width + paddingX * 2;
                                const boxHeight = fontSize + paddingY * 2;
                                const targetY = geometry.headY;
                                const labelY = geometry.orientation > 0
                                    ? targetY - offset
                                    : targetY + offset;
                                const labelX = geometry.x;
                                const boxX = labelX - boxWidth / 2;
                                const boxY = labelY - boxHeight / 2;

                                if (backgroundColor) {
                                    ctx.fillStyle = backgroundColor;
                                    drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, borderRadius);
                                    ctx.fill();

                                    if (borderWidth > 0 && borderColor) {
                                        ctx.lineWidth = borderWidth;
                                        ctx.strokeStyle = borderColor;
                                        ctx.stroke();
                                    }
                                }

                                ctx.fillStyle = textColor;
                                ctx.fillText(labelText, labelX, labelY);
                                ctx.restore();
                            }
                        }
                    });
                });

                if (pluginOptions?.drawZeroLine === false) {
                    return;
                }

                const yScale = chart.scales?.y;
                if (!yScale) {
                    return;
                }
                const zeroPixel = yScale.getPixelForValue(0);
                if (!Number.isFinite(zeroPixel)) {
                    return;
                }

                ctx.save();
                ctx.beginPath();
                ctx.moveTo(chart.chartArea.left, zeroPixel);
                ctx.lineTo(chart.chartArea.right, zeroPixel);
                ctx.lineWidth = pluginOptions?.zeroLineWidth || 1.5;
                ctx.strokeStyle = pluginOptions?.zeroLineColor || "rgba(37, 99, 235, 0.6)";
                ctx.stroke();
                ctx.restore();
            },
        };

        function isoToday() {
            const today = new Date();
            const month = String(today.getMonth() + 1).padStart(2, "0");
            const day = String(today.getDate()).padStart(2, "0");
            return `${today.getFullYear()}-${month}-${day}`;
        }

        function renderStockStatusRows(items) {
            if (!stockStatusTableBody || !stockStatusTableWrapper || !stockStatusEmptyState) {
                return;
            }

            stockStatusTableBody.innerHTML = "";

            if (!Array.isArray(items) || items.length === 0) {
                stockStatusTableWrapper.hidden = true;
                stockStatusEmptyState.hidden = false;
                stockStatusEmptyState.textContent = "No stock data available for the selected date.";
                renderStockStatusChart([]);
                return;
            }

            items.forEach((item) => {
                const row = document.createElement("tr");
                if (item.key === "opening_total") {
                    row.classList.add("stock-status-table__opening-row");
                }

                const nameCell = document.createElement("td");
                nameCell.textContent = item.label || item.name || item.key || "—";
                row.appendChild(nameCell);

                const qtyCell = document.createElement("td");
                qtyCell.textContent = formatNumber(item.quantity_ton, 3);
                row.appendChild(qtyCell);

                const unitCostCell = document.createElement("td");
                unitCostCell.textContent = formatNumber(item.unit_cost_per_ton, 2);
                row.appendChild(unitCostCell);

                const valueCell = document.createElement("td");
                valueCell.textContent = formatNumber(item.value_rs, 2);
                row.appendChild(valueCell);

                stockStatusTableBody.appendChild(row);
            });

            stockStatusEmptyState.hidden = true;
            stockStatusTableWrapper.hidden = false;
        }

        function renderStockStatusChart(items) {
            if (!stockStatusChartCanvas) {
                return;
            }

            const relevantItems = Array.isArray(items)
                ? items.filter((item) => STOCK_STATUS_CHART_KEYS.includes(item.key))
                : [];

            if (relevantItems.length === 0) {
                if (stockStatusChartInstance) {
                    stockStatusChartInstance.destroy();
                    stockStatusChartInstance = null;
                }
                stockStatusChartPoints = [];
                if (stockStatusChartContainer) {
                    stockStatusChartContainer.hidden = true;
                }
                return;
            }

            const points = relevantItems.map((item) => {
                const metrics = item?.metrics || {};
                const key = item?.key || "";
                const isBriquette = key === "briquettes";
                const opening = Number(metrics.opening_balance ?? 0);
                const purchases = Number(metrics.purchases ?? 0);
                const production = Number(metrics.production ?? 0);
                const closing = Number(
                    metrics.closing_balance ?? item?.quantity_ton ?? 0,
                );
                const consumption = Number(metrics.consumption ?? 0);
                const sales = Number(metrics.sales ?? 0);

                const totalAvailableCandidate = Number(
                    metrics.total_available ??
                        (isBriquette ? opening + production : opening + purchases),
                );

                const totalAvailable = Number.isFinite(totalAvailableCandidate)
                    ? Math.max(totalAvailableCandidate, 0)
                    : 0;
                const closingBalance = Number.isFinite(closing) ? Math.max(closing, 0) : 0;
                const impactValueRaw = isBriquette ? sales : consumption;
                const impactValue = Number.isFinite(impactValueRaw)
                    ? Math.max(impactValueRaw, 0)
                    : 0;

                return {
                    key,
                    label: item?.label || item?.name || key,
                    totalAvailable,
                    closingBalance,
                    impactValue,
                    impactLabel: isBriquette ? "Sales (-)" : "Consumption (-)",
                    valueRs: Number(item?.value_rs ?? Number.NaN),
                };
            });

            const labels = points.map((point) => point.label);
            const totalData = points.map((point) => point.totalAvailable);
            const closingData = points.map((point) => point.closingBalance);
            const impactData = points.map((point) => -Math.abs(point.impactValue));

            const maxTotal = Math.max(...totalData, 0);
            const maxImpact = Math.max(...points.map((point) => point.impactValue), 0);
            const suggestedMax = maxTotal > 0 ? maxTotal * 1.1 : 1;
            const suggestedMin = maxImpact > 0 ? -maxImpact * 1.25 : -Math.max(1, suggestedMax * 0.25);

            const datasets = [
                {
                    label: "Total Available",
                    data: totalData,
                    backgroundColor: "rgba(0, 0, 0, 0)",
                    borderColor: "rgba(0, 0, 0, 0)",
                    borderWidth: 0,
                    grouped: false,
                    order: 0,
                    cylinder: {
                        widthRatio: 0.82,
                        capRatio: 0.28,
                        gradientStops: [
                            { offset: 0, color: "rgba(191, 219, 254, 0.95)" },
                            { offset: 0.25, color: "rgba(147, 197, 253, 0.98)" },
                            { offset: 0.55, color: "rgba(96, 165, 250, 0.98)" },
                            { offset: 0.85, color: "rgba(59, 130, 246, 0.98)" },
                            { offset: 1, color: "rgba(30, 64, 175, 0.98)" },
                        ],
                        topCapColor: "rgba(191, 219, 254, 0.98)",
                        bottomCapColor: "rgba(30, 64, 175, 0.98)",
                        strokeColor: "rgba(30, 64, 175, 0.28)",
                        strokeWidth: 1,
                        shadowOpacity: 0.24,
                        shadowColor: "rgba(30, 58, 138, 0.45)",
                        shadowFadeColor: "rgba(30, 64, 175, 0)",
                        shadowWidthRatio: 1.25,
                        shadowHeightRatio: 0.58,
                        glossIntensity: 0.35,
                        highlightWidthRatio: 0.4,
                        topGlossIntensity: 0.6,
                        rimShadowIntensity: 0.28,
                        highlightColor: "rgba(255, 255, 255, 0.85)",
                    },
                },
                {
                    label: "Closing Stock",
                    data: closingData,
                    backgroundColor: "rgba(0, 0, 0, 0)",
                    borderColor: "rgba(0, 0, 0, 0)",
                    borderWidth: 0,
                    grouped: false,
                    order: 1,
                    valueLabel: {
                        enabled: true,
                        formatter(value, context) {
                            const index = context?.dataIndex;
                            const point = typeof index === "number" ? stockStatusChartPoints[index] : null;
                            const tons = formatChartTons(Math.abs(value));
                            return point?.label ? `${point.label}: ${tons} t` : `${tons} t`;
                        },
                        backgroundColor: "rgba(254, 243, 199, 0.95)",
                        color: "rgba(113, 63, 18, 0.95)",
                        borderColor: "rgba(217, 119, 6, 0.35)",
                        borderWidth: 1,
                        offset: 24,
                        paddingX: 10,
                        paddingY: 4,
                        fontSize: 12,
                    },
                    cylinder: {
                        widthRatio: 0.6,
                        capRatio: 0.32,
                        gradientStops: [
                            { offset: 0, color: "rgba(254, 249, 195, 0.98)" },
                            { offset: 0.22, color: "rgba(253, 224, 71, 0.98)" },
                            { offset: 0.55, color: "rgba(251, 191, 36, 0.98)" },
                            { offset: 0.82, color: "rgba(217, 119, 6, 0.98)" },
                            { offset: 1, color: "rgba(120, 53, 15, 0.98)" },
                        ],
                        topCapColor: "rgba(254, 243, 199, 0.98)",
                        bottomCapColor: "rgba(120, 53, 15, 0.98)",
                        strokeColor: "rgba(124, 45, 18, 0.32)",
                        strokeWidth: 1,
                        shadowOpacity: 0.28,
                        shadowColor: "rgba(124, 45, 18, 0.4)",
                        shadowFadeColor: "rgba(124, 45, 18, 0)",
                        shadowWidthRatio: 1.18,
                        shadowHeightRatio: 0.6,
                        glossIntensity: 0.55,
                        highlightWidthRatio: 0.38,
                        highlightColor: "rgba(255, 255, 255, 0.95)",
                        topGlossIntensity: 0.8,
                        rimShadowIntensity: 0.32,
                    },
                },
                {
                    label: "Consumption or Sales (-)",
                    data: impactData,
                    backgroundColor: "rgba(0, 0, 0, 0)",
                    borderColor: "rgba(0, 0, 0, 0)",
                    borderWidth: 0,
                    grouped: false,
                    order: 2,
                    valueLabel: {
                        enabled: true,
                        formatter(value, context) {
                            const index = context?.dataIndex;
                            const point = typeof index === "number" ? stockStatusChartPoints[index] : null;
                            const tons = formatChartTons(Math.abs(value));
                            return point?.impactLabel ? `${point.impactLabel} ${tons} t` : `${tons} t`;
                        },
                        backgroundColor: "rgba(248, 113, 113, 0.92)",
                        color: "#fff",
                        borderColor: "rgba(127, 29, 29, 0.4)",
                        borderWidth: 1,
                        offset: 28,
                        paddingX: 10,
                        paddingY: 4,
                        fontSize: 12,
                    },
                    cylinder: {
                        widthRatio: 0.48,
                        capRatio: 0.34,
                        gradientStops: [
                            { offset: 0, color: "rgba(254, 202, 202, 0.95)" },
                            { offset: 0.25, color: "rgba(252, 165, 165, 0.97)" },
                            { offset: 0.55, color: "rgba(248, 113, 113, 0.98)" },
                            { offset: 0.82, color: "rgba(220, 38, 38, 0.98)" },
                            { offset: 1, color: "rgba(153, 27, 27, 0.98)" },
                        ],
                        topCapColor: "rgba(254, 202, 202, 0.98)",
                        bottomCapColor: "rgba(153, 27, 27, 0.98)",
                        strokeColor: "rgba(127, 29, 29, 0.3)",
                        strokeWidth: 1,
                        shadowOpacity: 0.24,
                        shadowColor: "rgba(127, 29, 29, 0.38)",
                        shadowFadeColor: "rgba(127, 29, 29, 0)",
                        shadowWidthRatio: 1.1,
                        shadowHeightRatio: 0.58,
                        glossIntensity: 0.48,
                        highlightWidthRatio: 0.36,
                        highlightColor: "rgba(255, 255, 255, 0.9)",
                        topGlossIntensity: 0.7,
                        rimShadowIntensity: 0.34,
                    },
                },
            ];

            const chartConfig = {
                type: "bar",
                data: {
                    labels,
                    datasets,
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    clip: false,
                    animation: {
                        duration: 900,
                        easing: "easeOutCubic",
                    },
                    animations: {
                        x: {
                            duration: 650,
                            easing: "easeOutCubic",
                        },
                        y: {
                            duration: 900,
                            easing: "easeOutCubic",
                        },
                    },
                    layout: {
                        padding: {
                            top: 16,
                            right: 8,
                            bottom: 24,
                            left: 8,
                        },
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false,
                                drawBorder: false,
                            },
                            ticks: {
                                maxRotation: 0,
                                minRotation: 0,
                                font: {
                                    family: "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                                },
                            },
                        },
                        y: {
                            beginAtZero: true,
                            suggestedMax,
                            suggestedMin,
                            grid: {
                                drawBorder: false,
                                color: (context) =>
                                    context.tick.value === 0
                                        ? "rgba(37, 99, 235, 0.45)"
                                        : "rgba(148, 163, 184, 0.2)",
                                lineWidth: (context) => (context.tick.value === 0 ? 2 : 1),
                                drawTicks: false,
                            },
                            ticks: {
                                font: {
                                    family: "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                                },
                                callback(value) {
                                    const numeric = Number(value);
                                    if (!Number.isFinite(numeric)) {
                                        return value;
                                    }
                                    const digits = Math.abs(numeric) >= 10 ? 0 : 2;
                                    return formatNumber(numeric, digits);
                                },
                            },
                        },
                    },
                    plugins: {
                        legend: {
                            labels: {
                                usePointStyle: true,
                                pointStyle: "rectRounded",
                                boxWidth: 12,
                                padding: 16,
                                font: {
                                    family: "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                                },
                            },
                        },
                        tooltip: {
                            backgroundColor: "rgba(15, 23, 42, 0.92)",
                            borderColor: "rgba(148, 163, 184, 0.35)",
                            borderWidth: 1,
                            titleFont: {
                                family: "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                                weight: "600",
                            },
                            bodyFont: {
                                family: "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                            },
                            callbacks: {
                                title(context) {
                                    const index = context?.[0]?.dataIndex;
                                    if (typeof index !== "number") {
                                        return "";
                                    }
                                    return stockStatusChartPoints[index]?.label || "";
                                },
                                label(context) {
                                    const datasetLabel = context?.dataset?.label || "";
                                    const rawValue = Number(context?.raw ?? 0);
                                    const index = context?.dataIndex;
                                    const point = typeof index === "number" ? stockStatusChartPoints[index] : null;

                                    if (datasetLabel === "Consumption or Sales (-)" && point) {
                                        return `${point.impactLabel}: ${formatChartTons(Math.abs(rawValue))} tons`;
                                    }

                                    return `${datasetLabel}: ${formatChartTons(Math.abs(rawValue))} tons`;
                                },
                                afterBody(context) {
                                    const index = context?.[0]?.dataIndex;
                                    if (typeof index !== "number") {
                                        return "";
                                    }
                                    const valueText = formatChartCurrency(stockStatusChartPoints[index]?.valueRs);
                                    if (!valueText) {
                                        return "";
                                    }
                                    return `Stock value: Rs. ${valueText}`;
                                },
                            },
                        },
                        cylinderBarPlugin: {
                            zeroLineColor: "rgba(37, 99, 235, 0.6)",
                            zeroLineWidth: 1.5,
                            valueLabel: {
                                fontFamily:
                                    "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                                fontWeight: "600",
                                borderRadius: 8,
                                paddingX: 8,
                                paddingY: 4,
                                color: "#0f172a",
                            },
                        },
                    },
                    interaction: {
                        intersect: false,
                        mode: "nearest",
                    },
                },
                plugins: [cylinderBarPlugin],
            };

            if (stockStatusChartInstance) {
                stockStatusChartInstance.destroy();
            }

            stockStatusChartPoints = points;
            stockStatusChartInstance = new Chart(stockStatusChartCanvas, chartConfig);

            if (stockStatusChartContainer) {
                stockStatusChartContainer.hidden = false;
            }
        }

        async function loadStockStatus(asOf) {
            if (!stockStatusEmptyState || !stockStatusTableBody) {
                return;
            }

            stockStatusEmptyState.hidden = false;
            stockStatusEmptyState.textContent = "Loading stock status…";
            if (stockStatusTableWrapper) {
                stockStatusTableWrapper.hidden = true;
            }

            try {
                const url = new URL("/api/material/stock-status", window.location.origin);
                if (asOf) {
                    url.searchParams.set("as_of", asOf);
                }
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error("Failed to load stock status");
                }
                const data = await response.json();
                const items = Array.isArray(data.items) ? data.items : [];
                renderStockStatusRows(items);
                renderStockStatusChart(items);
                if (stockStatusDateInput && data.as_of) {
                    stockStatusDateInput.value = data.as_of;
                }
            } catch (error) {
                console.error(error);
                stockStatusEmptyState.hidden = false;
                stockStatusEmptyState.textContent =
                    "Unable to load stock status right now. Please try again.";
                renderStockStatusChart([]);
            }
        }

        if (stockStatusDateInput) {
            const defaultDate = isoToday();
            if (!stockStatusDateInput.value) {
                stockStatusDateInput.value = defaultDate;
            }
            stockStatusDateInput.addEventListener("change", () => {
                const value = stockStatusDateInput.value || defaultDate;
                loadStockStatus(value);
            });
            loadStockStatus(stockStatusDateInput.value);
        } else {
            loadStockStatus(isoToday());
        }

        function renderSupplierRows(items) {
            if (!supplierTableBody || !supplierTableWrapper || !supplierEmptyState) {
                return;
            }

            supplierTableBody.innerHTML = "";

            if (!items || items.length === 0) {
                supplierTableWrapper.hidden = true;
                supplierEmptyState.hidden = false;
                supplierEmptyState.textContent = "No suppliers registered yet.";
                return;
            }

            items.forEach((item) => {
                const row = document.createElement("tr");

                const nameCell = document.createElement("td");
                nameCell.textContent = item.name || "—";
                row.appendChild(nameCell);

                const regCell = document.createElement("td");
                regCell.textContent = item.supplierRegNo || "—";
                row.appendChild(regCell);

                const categoryCell = document.createElement("td");
                categoryCell.textContent = item.category || "—";
                row.appendChild(categoryCell);

                const phoneCell = document.createElement("td");
                phoneCell.textContent = item.primaryPhone || item.phone || "—";
                row.appendChild(phoneCell);

                const creditCell = document.createElement("td");
                creditCell.textContent = item.creditPeriod || "—";
                row.appendChild(creditCell);

                supplierTableBody.appendChild(row);
            });

            supplierEmptyState.hidden = true;
            supplierTableWrapper.hidden = false;
        }

        async function loadSuppliers(query = "") {
            if (!supplierTableBody || !supplierEmptyState) {
                return;
            }

            supplierEmptyState.hidden = false;
            supplierEmptyState.textContent = "Loading suppliers…";
            if (supplierTableWrapper) {
                supplierTableWrapper.hidden = true;
            }

            try {
                const url = new URL("/api/material/suppliers", window.location.origin);
                url.searchParams.set("limit", "15");
                if (query && query.trim()) {
                    url.searchParams.set("search", query.trim());
                }
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error("Failed to load suppliers");
                }
                const data = await response.json();
                if (!Array.isArray(data)) {
                    renderSupplierRows([]);
                    return;
                }
                renderSupplierRows(data);
            } catch (error) {
                console.error(error);
                supplierEmptyState.hidden = false;
                supplierEmptyState.textContent =
                    "Unable to load suppliers right now. Please try again.";
            }
        }

        function formatDate(value) {
            if (!value) {
                return "—";
            }
            const parts = value.split("-");
            if (parts.length !== 3) {
                return value;
            }
            const [year, month, day] = parts.map((part) => Number.parseInt(part, 10));
            if (Number.isNaN(year) || Number.isNaN(month) || Number.isNaN(day)) {
                return value;
            }
            const dateObject = new Date(year, month - 1, day);
            return dateObject.toLocaleDateString(undefined, {
                year: "numeric",
                month: "short",
                day: "numeric",
            });
        }

        function renderBriquetteMaterialHeadings(order, labels) {
            if (!briquetteMaterialHeadings) {
                return;
            }

            const fragment = document.createDocumentFragment();
            if (Array.isArray(order) && order.length) {
                order.forEach((key) => {
                    const th = document.createElement("th");
                    th.scope = "col";
                    th.textContent = labels?.[key] || key;
                    fragment.appendChild(th);
                });
            } else {
                ["Sawdust", "Wood Shaving", "Wood Powder", "Peanut Husk", "Fire Cut"].forEach((label) => {
                    const th = document.createElement("th");
                    th.scope = "col";
                    th.textContent = label;
                    fragment.appendChild(th);
                });
            }

            briquetteMaterialHeadings.innerHTML = "";
            briquetteMaterialHeadings.appendChild(fragment);
        }

        function renderBriquetteCostBreakdown(rows) {
            if (!briquetteCostTableBody) {
                return;
            }

            briquetteCostTableBody.innerHTML = "";
            if (!Array.isArray(rows) || rows.length === 0) {
                const emptyRow = document.createElement("tr");
                const cell = document.createElement("td");
                cell.colSpan = 5;
                cell.textContent = "No cost data available.";
                emptyRow.appendChild(cell);
                briquetteCostTableBody.appendChild(emptyRow);
                return;
            }

            rows.forEach((row) => {
                const tr = document.createElement("tr");
                const materialCell = document.createElement("td");
                materialCell.textContent = row.label || "—";
                tr.appendChild(materialCell);

                const qtyKgCell = document.createElement("td");
                qtyKgCell.textContent = formatNumber(row.quantity_kg, 3);
                tr.appendChild(qtyKgCell);

                const qtyTonCell = document.createElement("td");
                qtyTonCell.textContent = formatNumber(row.quantity_ton, 3);
                tr.appendChild(qtyTonCell);

                const unitPriceCell = document.createElement("td");
                unitPriceCell.textContent = formatNumber(row.unit_price, 4);
                tr.appendChild(unitPriceCell);

                const totalCostCell = document.createElement("td");
                totalCostCell.textContent = formatNumber(row.total_cost, 2);
                tr.appendChild(totalCostCell);

                briquetteCostTableBody.appendChild(tr);
            });
        }

        function clearBriquetteModalFeedback() {
            if (briquetteModalFeedback) {
                briquetteModalFeedback.hidden = true;
                briquetteModalFeedback.textContent = "";
                briquetteModalFeedback.classList.remove("modal__feedback--success");
            }
            if (briquetteModalError) {
                briquetteModalError.hidden = true;
                briquetteModalError.textContent = "";
            }
        }

        function setBriquetteModalFeedback(message, { isError = false } = {}) {
            if (isError) {
                if (briquetteModalError) {
                    briquetteModalError.hidden = false;
                    briquetteModalError.textContent = message;
                }
                if (briquetteModalFeedback) {
                    briquetteModalFeedback.hidden = true;
                    briquetteModalFeedback.textContent = "";
                    briquetteModalFeedback.classList.remove("modal__feedback--success");
                }
                return;
            }

            if (briquetteModalFeedback) {
                briquetteModalFeedback.hidden = false;
                briquetteModalFeedback.textContent = message;
                briquetteModalFeedback.classList.add("modal__feedback--success");
            }
            if (briquetteModalError) {
                briquetteModalError.hidden = true;
                briquetteModalError.textContent = "";
            }
        }

        function closeBriquetteModal() {
            if (!briquetteModal) {
                return;
            }
            briquetteModal.classList.remove("modal--open");
            briquetteModal.setAttribute("hidden", "");
            briquetteModal.setAttribute("aria-hidden", "true");
            document.body.classList.remove("modal-open");
            briquetteModalDateValue = null;
            briquetteDryerProductionTon = 0;
            briquetteTotalOutputTon = 0;
            briquetteComputedWoodShavingTon = 0;
            briquetteComputedDryMaterialTon = 0;
            if (briquetteModalForm) {
                briquetteModalForm.reset();
            }
            clearBriquetteModalFeedback();
        }

        function parseTonInput(input) {
            if (!input) {
                return 0;
            }
            const numeric = Number.parseFloat(input.value);
            return Number.isFinite(numeric) ? numeric : 0;
        }

        function updateDerivedMaterialValues() {
            const woodPowder = parseTonInput(briquetteWoodPowderInput);
            const peanutHusk = parseTonInput(briquettePeanutHuskInput);
            const dryerTons = Number.isFinite(briquetteDryerProductionTon)
                ? briquetteDryerProductionTon
                : 0;
            const totalOutput = Number.isFinite(briquetteTotalOutputTon)
                ? briquetteTotalOutputTon
                : 0;

            const woodShavingRaw = totalOutput - dryerTons - woodPowder - peanutHusk;
            if (Number.isFinite(woodShavingRaw)) {
                briquetteComputedWoodShavingTon = Number(woodShavingRaw.toFixed(3));
                if (briquetteWoodShavingInput) {
                    briquetteWoodShavingInput.value = briquetteComputedWoodShavingTon.toFixed(3);
                }
            } else {
                briquetteComputedWoodShavingTon = 0;
                if (briquetteWoodShavingInput) {
                    briquetteWoodShavingInput.value = "0.000";
                }
            }

            const dryMaterialRaw = dryerTons + woodShavingRaw + woodPowder + peanutHusk;
            if (Number.isFinite(dryMaterialRaw)) {
                briquetteComputedDryMaterialTon = Number(dryMaterialRaw.toFixed(3));
                if (briquetteDryMaterialInput) {
                    briquetteDryMaterialInput.value = briquetteComputedDryMaterialTon.toFixed(3);
                }
            } else {
                briquetteComputedDryMaterialTon = 0;
                if (briquetteDryMaterialInput) {
                    briquetteDryMaterialInput.value = "0.000";
                }
            }
        }

        function updateSawdustPreview() {
            if (!briquetteDryFactorInput || !briquetteSawdustInput) {
                return;
            }
            const dryFactor = Number.parseFloat(briquetteDryFactorInput.value || "0");
            if (!Number.isFinite(dryFactor) || dryFactor <= 0) {
                briquetteSawdustInput.value = "0.000";
                return;
            }
            const sawdustTons = Math.max(0, briquetteDryerProductionTon / dryFactor);
            briquetteSawdustInput.value = sawdustTons.toFixed(3);
        }

        function populateBriquetteModal(data) {
            if (!data) {
                return;
            }
            if (briquetteModalDate) {
                briquetteModalDate.value = formatDate(data.date) || data.date || "—";
            }
            if (typeof data.dry_factor === "number" && briquetteDryFactorInput) {
                briquetteDryFactorInput.value = data.dry_factor.toFixed(4);
            } else if (briquetteDryFactorInput) {
                briquetteDryFactorInput.value = "0.0000";
            }
            const dryerValue = Number(data.dryer_production_ton);
            briquetteDryerProductionTon = Number.isFinite(dryerValue) ? dryerValue : 0;

            const totalOutputTon = Number(data.briquette_production_ton);
            briquetteTotalOutputTon = Number.isFinite(totalOutputTon) ? totalOutputTon : 0;

            if (briquetteOutputKg) {
                briquetteOutputKg.textContent = formatNumber(data.briquette_output_kg, 2);
            }

            if (briquetteDryerHoursInput) {
                const hoursValue = Number(data.dryer_actual_running_hours);
                if (Number.isFinite(hoursValue)) {
                    briquetteDryerHoursInput.value = hoursValue.toFixed(1);
                } else {
                    briquetteDryerHoursInput.value = "0.0";
                }
            }

            const materials = data.materials || {};
            if (briquetteWoodShavingInput) {
                const value = Number(data.wood_shaving_ton ?? materials.wood_shaving);
                const numeric = Number.isFinite(value) ? value : 0;
                briquetteWoodShavingInput.value = numeric.toFixed(3);
            }
            if (briquetteWoodPowderInput) {
                const value = Number.parseFloat(materials.wood_powder) || 0;
                briquetteWoodPowderInput.value = value.toFixed(3);
            }
            if (briquettePeanutHuskInput) {
                const value = Number.parseFloat(materials.peanut_husk) || 0;
                briquettePeanutHuskInput.value = value.toFixed(3);
            }
            if (briquetteFireCutInput) {
                const value = Number.parseFloat(materials.fire_cut) || 0;
                briquetteFireCutInput.value = value.toFixed(3);
            }
            if (briquetteDryMaterialInput) {
                const value = Number(data.dry_material_ton);
                const numeric = Number.isFinite(value) ? value : 0;
                briquetteDryMaterialInput.value = numeric.toFixed(3);
            }
            if (briquetteSawdustInput) {
                const sawdustValue = Number.parseFloat(data.sawdust_ton) || 0;
                briquetteSawdustInput.value = sawdustValue.toFixed(3);
            }

            if (briquetteTotalCost) {
                briquetteTotalCost.textContent = `Rs ${formatNumber(data.total_material_cost, 2)}`;
            }
            if (briquetteUnitCost) {
                briquetteUnitCost.textContent = `Rs ${formatNumber(data.unit_cost_per_kg, 4)}`;
            }

            renderBriquetteCostBreakdown(data.cost_breakdown);
        }

        async function fetchBriquetteMix(dateIso) {
            if (!dateIso) {
                return;
            }
            clearBriquetteModalFeedback();
            if (briquetteSaveButton) {
                briquetteSaveButton.disabled = true;
            }
            try {
                const response = await fetch(`/api/material/briquette-production/${dateIso}`);
                if (!response.ok) {
                    throw new Error("Unable to load mix details.");
                }
                const data = await response.json();
                populateBriquetteModal(data);
                if (Array.isArray(data.material_order)) {
                    briquetteMaterialOrder = data.material_order;
                }
                if (data.material_labels) {
                    briquetteMaterialLabels = data.material_labels;
                }
                renderBriquetteMaterialHeadings(briquetteMaterialOrder, briquetteMaterialLabels);
                updateSawdustPreview();
            if (briquetteSaveButton) {
                briquetteSaveButton.disabled = false;
            }
            updateDerivedMaterialValues();
        } catch (error) {
            console.error(error);
            setBriquetteModalFeedback("Unable to load mix details. Please try again.", { isError: true });
                if (briquetteSaveButton) {
                    briquetteSaveButton.disabled = false;
                }
            }
        }

        function openBriquetteModal(dateIso) {
            if (!briquetteModal || !dateIso) {
                return;
            }
            briquetteModalDateValue = dateIso;
            briquetteModal.removeAttribute("hidden");
            briquetteModal.setAttribute("aria-hidden", "false");
            briquetteModal.classList.add("modal--open");
            document.body.classList.add("modal-open");
            if (briquetteSaveButton) {
                briquetteSaveButton.disabled = true;
            }
            clearBriquetteModalFeedback();
            fetchBriquetteMix(dateIso);
        }

        function renderBriquetteRows(entries) {
            if (!briquetteTableBody || !briquetteTableWrapper || !briquetteEmptyState) {
                return;
            }

            briquetteTableBody.innerHTML = "";

            if (!Array.isArray(entries) || entries.length === 0) {
                briquetteTableWrapper.hidden = true;
                briquetteEmptyState.hidden = false;
                briquetteEmptyState.textContent = "No briquette production entries recorded yet.";
                return;
            }

            entries.forEach((entry) => {
                const tr = document.createElement("tr");
                const dateCell = document.createElement("td");
                dateCell.textContent = formatDate(entry.date) || entry.date || "—";
                tr.appendChild(dateCell);

                const productionCell = document.createElement("td");
                productionCell.textContent = formatNumber(entry.briquette_production_ton, 3);
                tr.appendChild(productionCell);

                if (!Array.isArray(briquetteMaterialOrder) || briquetteMaterialOrder.length === 0) {
                    briquetteMaterialOrder = Object.keys(entry.materials || {});
                }

                briquetteMaterialOrder.forEach((key) => {
                    const cell = document.createElement("td");
                    const value = (entry.materials && entry.materials[key]) || 0;
                    cell.textContent = formatNumber(value, 3);
                    tr.appendChild(cell);
                });

                const unitCostCell = document.createElement("td");
                unitCostCell.textContent = formatNumber(entry.unit_cost_per_kg, 4);
                tr.appendChild(unitCostCell);

                const totalCostCell = document.createElement("td");
                totalCostCell.textContent = formatNumber(entry.total_material_cost, 2);
                tr.appendChild(totalCostCell);

                const actionCell = document.createElement("td");
                const actionButton = document.createElement("button");
                actionButton.type = "button";
                actionButton.className = "button button--secondary";
                actionButton.textContent = entry.has_mix ? "Edit mix" : "Update mix";
                actionButton.dataset.mixDate = entry.date;
                actionCell.appendChild(actionButton);
                tr.appendChild(actionCell);

                briquetteTableBody.appendChild(tr);
            });

            briquetteEmptyState.hidden = true;
            briquetteTableWrapper.hidden = false;
        }

        async function loadBriquetteProductionEntries() {
            if (!briquetteEmptyState) {
                return;
            }

            briquetteEmptyState.hidden = false;
            briquetteEmptyState.textContent = "Loading briquette production…";
            if (briquetteTableWrapper) {
                briquetteTableWrapper.hidden = true;
            }

            try {
                const response = await fetch("/api/material/briquette-production");
                if (!response.ok) {
                    throw new Error("Failed to load briquette production entries.");
                }
                const data = await response.json();
                if (Array.isArray(data.material_order)) {
                    briquetteMaterialOrder = data.material_order;
                }
                if (data.material_labels) {
                    briquetteMaterialLabels = data.material_labels;
                }
                renderBriquetteMaterialHeadings(briquetteMaterialOrder, briquetteMaterialLabels);
                renderBriquetteRows(data.entries || []);
            } catch (error) {
                console.error(error);
                if (briquetteEmptyState) {
                    briquetteEmptyState.hidden = false;
                    briquetteEmptyState.textContent = "Unable to load briquette production right now.";
                }
            }
        }

        if (supplierSearchForm) {
            supplierSearchForm.addEventListener("submit", (event) => {
                event.preventDefault();
                const query = supplierSearchInput ? supplierSearchInput.value : "";
                loadSuppliers(query);
            });
        }

        if (supplierClearButton) {
            supplierClearButton.addEventListener("click", () => {
                if (supplierSearchInput) {
                    supplierSearchInput.value = "";
                }
                loadSuppliers("");
            });
        }

        if (supplierSearchInput) {
            supplierSearchInput.addEventListener("input", () => {
                if (supplierSearchInput.value.trim() === "") {
                    loadSuppliers("");
                }
            });
        }

        function renderMrnRows(items) {
            if (!mrnTableBody || !mrnTableWrapper || !mrnEmptyState) {
                return;
            }

            mrnTableBody.innerHTML = "";

            if (!items || items.length === 0) {
                mrnTableWrapper.hidden = true;
                mrnEmptyState.hidden = false;
                mrnEmptyState.textContent = "No material receipts recorded yet.";
                return;
            }

            items.forEach((item) => {
                const row = document.createElement("tr");

                const mrnCell = document.createElement("td");
                const mrnLink = document.createElement("a");
                mrnLink.className = "data-table__link";
                mrnLink.href = `/material/mrn/${item.id}`;
                mrnLink.textContent = item.mrn_no;
                mrnCell.appendChild(mrnLink);
                row.appendChild(mrnCell);

                const dateCell = document.createElement("td");
                dateCell.textContent = formatDate(item.date);
                row.appendChild(dateCell);

                const supplierCell = document.createElement("td");
                supplierCell.textContent =
                    (item.supplier && item.supplier.name) || item.vehicle_no || "—";
                row.appendChild(supplierCell);

                const materialCell = document.createElement("td");
                let materialSummary = "—";
                if (Array.isArray(item.items) && item.items.length > 0) {
                    const firstItem = item.items[0];
                    const firstName = (firstItem.item && firstItem.item.name) || firstItem.name || "—";
                    if (item.items.length === 1) {
                        materialSummary = firstName;
                    } else {
                        materialSummary = `${firstName} + ${item.items.length - 1} more`;
                    }
                }
                materialCell.textContent = materialSummary;
                row.appendChild(materialCell);

                const qtyCell = document.createElement("td");
                qtyCell.textContent = formatNumber(item.qty_ton, 3);
                row.appendChild(qtyCell);

                const amountCell = document.createElement("td");
                amountCell.textContent = formatNumber(item.amount, 2);
                row.appendChild(amountCell);

                mrnTableBody.appendChild(row);
            });

            mrnEmptyState.hidden = true;
            mrnTableWrapper.hidden = false;
        }

        async function loadMrns(query = "") {
            if (!mrnTableBody || !mrnEmptyState) {
                return;
            }

            mrnEmptyState.hidden = false;
            mrnEmptyState.textContent = "Loading material receipts…";
            if (mrnTableWrapper) {
                mrnTableWrapper.hidden = true;
            }

            try {
                const url = new URL("/api/material/mrn", window.location.origin);
                if (query && query.trim()) {
                    url.searchParams.set("q", query.trim());
                }
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error("Failed to load MRNs");
                }
                const data = await response.json();
                if (!Array.isArray(data)) {
                    renderMrnRows([]);
                    return;
                }
                renderMrnRows(data);
            } catch (error) {
                console.error(error);
                mrnEmptyState.hidden = false;
                mrnEmptyState.textContent =
                    "Unable to load material receipts right now. Please try again.";
            }
        }

        if (mrnSearchForm) {
            mrnSearchForm.addEventListener("submit", (event) => {
                event.preventDefault();
                const query = mrnSearchInput ? mrnSearchInput.value : "";
                loadMrns(query);
            });
        }

        if (mrnClearButton) {
            mrnClearButton.addEventListener("click", () => {
                if (mrnSearchInput) {
                    mrnSearchInput.value = "";
                }
                loadMrns("");
            });
        }

        if (mrnSearchInput) {
            mrnSearchInput.addEventListener("input", () => {
                if (mrnSearchInput.value.trim() === "") {
                    loadMrns("");
                }
            });
        }

        if (briquetteTableBody) {
            briquetteTableBody.addEventListener("click", (event) => {
                const button = event.target.closest("button[data-mix-date]");
                if (!button) {
                    return;
                }
                const dateIso = button.dataset.mixDate;
                openBriquetteModal(dateIso);
            });
        }

        if (briquetteModalClose) {
            briquetteModalClose.addEventListener("click", () => {
                closeBriquetteModal();
            });
        }

        if (briquetteModalCancel) {
            briquetteModalCancel.addEventListener("click", () => {
                closeBriquetteModal();
            });
        }

        if (briquetteModal) {
            briquetteModal.addEventListener("click", (event) => {
                if (event.target && event.target.dataset && "modalDismiss" in event.target.dataset) {
                    closeBriquetteModal();
                }
            });
        }

        document.addEventListener("keydown", (event) => {
            if (event.key === "Escape" && briquetteModal && !briquetteModal.hasAttribute("hidden")) {
                closeBriquetteModal();
            }
        });

        if (briquetteDryFactorInput) {
            briquetteDryFactorInput.addEventListener("input", updateSawdustPreview);
        }

        if (briquetteWoodPowderInput) {
            briquetteWoodPowderInput.addEventListener("input", () => {
                updateDerivedMaterialValues();
            });
        }

        if (briquettePeanutHuskInput) {
            briquettePeanutHuskInput.addEventListener("input", () => {
                updateDerivedMaterialValues();
            });
        }

        if (briquetteModalForm) {
            briquetteModalForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                if (!briquetteModalDateValue) {
                    setBriquetteModalFeedback("No date selected.", { isError: true });
                    return;
                }

                if (briquetteSaveButton) {
                    briquetteSaveButton.disabled = true;
                }
                clearBriquetteModalFeedback();

                updateDerivedMaterialValues();
                if (Number.isFinite(briquetteComputedWoodShavingTon)) {
                    if (Math.round(briquetteComputedWoodShavingTon * 1000) < 0) {
                        setBriquetteModalFeedback(
                            "Invalid mix: Wood shaving quantity cannot be negative. Please check inputs.",
                            { isError: true },
                        );
                        if (briquetteSaveButton) {
                            briquetteSaveButton.disabled = false;
                        }
                        return;
                    }
                }

                const woodShavingForPayload = Number.isFinite(briquetteComputedWoodShavingTon)
                    ? briquetteComputedWoodShavingTon.toFixed(3)
                    : briquetteWoodShavingInput
                    ? (() => {
                          const fallbackValue = Number.parseFloat(
                              briquetteWoodShavingInput.value || "0",
                          );
                          return Number.isFinite(fallbackValue)
                              ? fallbackValue.toFixed(3)
                              : "0.000";
                      })()
                    : "0.000";

                const payload = {
                    dry_factor: briquetteDryFactorInput ? briquetteDryFactorInput.value : null,
                    wood_shaving_ton: woodShavingForPayload,
                    wood_powder_ton: briquetteWoodPowderInput ? briquetteWoodPowderInput.value : null,
                    peanut_husk_ton: briquettePeanutHuskInput ? briquettePeanutHuskInput.value : null,
                    fire_cut_ton: briquetteFireCutInput ? briquetteFireCutInput.value : null,
                };

                try {
                    const response = await fetch(`/api/material/briquette-production/${briquetteModalDateValue}`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(payload),
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const message = errorData?.msg || "Unable to save mix details.";
                        throw new Error(message);
                    }

                    const data = await response.json();
                    populateBriquetteModal(data);
                    setBriquetteModalFeedback("Mix updated successfully.");
                    loadBriquetteProductionEntries();
                } catch (error) {
                    console.error(error);
                    setBriquetteModalFeedback(error.message || "Unable to save mix details.", { isError: true });
                } finally {
                    if (briquetteSaveButton) {
                        briquetteSaveButton.disabled = false;
                    }
                }
            });
        }

        loadSuppliers("");
        loadMrns("");
        loadBriquetteProductionEntries();
    </script>
</body>
</html>
