<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Manufacturing | SAMPROX ERP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}" />
</head>
<body>
    <div class="page">
        <header class="topbar">
            <div class="brand">
                <div class="brand__logo">S</div>
                <div class="brand__details">
                    <p class="brand__name">SAMPROX ERP</p>
                    <p class="brand__section">Manufacturing Operations</p>
                </div>
            </div>
            <div class="topbar__actions">
                <a class="button button--ghost" href="{{ url_for('ui.mind_page') }}">Mind</a>
                <div class="user-summary">
                    <span class="user-summary__name" id="user-name"></span>
                    <span class="user-summary__role" id="user-role"></span>
                </div>
                <button type="button" class="button button--secondary" id="logout">Sign out</button>
            </div>
        </header>
        <nav class="subnav" aria-label="7M navigation">
            <a class="subnav__link" href="{{ url_for('ui.mind_page') }}">Mind</a>
            <a class="subnav__link" href="{{ url_for('ui.man_page') }}">Man</a>
            <a class="subnav__link" href="{{ url_for('ui.machines_page') }}">Machine</a>
            <a class="subnav__link" href="{{ url_for('ui.material_page') }}">Material</a>
            <a class="subnav__link" href="{{ url_for('ui.market_page') }}">Market</a>
            <a class="subnav__link subnav__link--active" href="{{ url_for('ui.manufacturing_page') }}">Manufacturing</a>
            <a class="subnav__link" href="{{ url_for('ui.money_page') }}">Money</a>
        </nav>
        <section class="section">
            <header class="section__header">
                <h1>Production flow coordination</h1>
            </header>
            <p class="section__description">
                Oversee the end-to-end production process, from work order release to final quality
                checks. Align capacity, resources, and schedules so every shift meets delivery
                commitments without sacrificing quality.
            </p>
            <div class="section__grid">
                <article class="tile">
                    <h2 class="tile__title">Work order control</h2>
                    <p class="tile__description">
                        Track live work orders, their routing steps, and current status to remove
                        bottlenecks before they impact throughput.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Capacity planning</h2>
                    <p class="tile__description">
                        Balance machine availability and staffing across shifts to keep utilization high
                        while maintaining buffer for urgent jobs.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Quality checkpoints</h2>
                    <p class="tile__description">
                        Coordinate in-process inspections, capture deviations, and escalate corrective
                        actions to protect outgoing quality.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Production analytics</h2>
                    <p class="tile__description">
                        Analyze yield, cycle times, and first-pass success to drive continuous
                        improvement initiatives across lines.
                    </p>
                </article>
            </div>
            <div class="production-card" aria-live="polite">
                <header class="production-card__header">
                    <div>
                        <h2>Daily production sheet</h2>
                        <p>Capture hourly output in tons for each manufacturing asset.</p>
                    </div>
                    <div class="production-summary">
                        <span class="production-summary__label">Total (tons)</span>
                        <span class="production-summary__value" id="production-total">0.00</span>
                    </div>
                </header>
                <div class="production-card__body">
                    <div class="production-totals" aria-live="polite">
                        <div class="production-totals__row">
                            <span class="production-totals__title">Today</span>
                            <div class="production-totals__metrics">
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">Total MCH-0001 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-today-mch-0001"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">Total MCH-0002 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-today-mch-0002"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">Total (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-today-total"
                                    >0.00</span>
                                </div>
                            </div>
                        </div>
                        <div class="production-totals__row">
                            <span class="production-totals__title">Month to Date</span>
                            <div class="production-totals__metrics">
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">MTD MCH-0001 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-mtd-mch-0001"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">MTD MCH-0002 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-mtd-mch-0002"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">MTD Total (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-mtd-total"
                                    >0.00</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <form class="production-form" id="production-form" novalidate>
                        <div class="production-form__grid">
                            <div class="production-input">
                                <label for="production-date">Date <span class="required">*</span></label>
                                <input id="production-date" name="date" type="date" required />
                            </div>
                            <div class="production-input">
                                <label for="production-machine">Machine ID <span class="required">*</span></label>
                                <select id="production-machine" name="machine_code" required>
                                    <option value="" disabled selected>Select machine</option>
                                </select>
                            </div>
                            <div class="production-input">
                                <label for="production-hour">Hour no. <span class="required">*</span></label>
                                <select id="production-hour" name="hour_no" required>
                                    {% for hour in range(1, 25) %}
                                    <option value="{{ hour }}">{{ "%02d" % hour }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                            <div class="production-input">
                                <label for="production-qty">Production qty (tons) <span class="required">*</span></label>
                                <input
                                    id="production-qty"
                                    name="quantity_tons"
                                    type="number"
                                    min="0"
                                    step="0.01"
                                    placeholder="0.00"
                                    required
                                />
                            </div>
                        </div>
                        <div class="production-actions">
                            <button type="submit" class="button" id="production-submit">Save hour</button>
                        </div>
                        <p class="production-feedback production-feedback--success" id="production-success" hidden>
                            Production updated successfully.
                        </p>
                        <p class="production-feedback production-feedback--error" id="production-error" hidden></p>
                    </form>
                    <div class="production-table-wrapper">
                        <table class="production-table">
                            <thead>
                                <tr>
                                    <th scope="col">Hour</th>
                                    <th scope="col">MCH-0001 (tons)</th>
                                    <th scope="col">MCH-0002 (tons)</th>
                                    <th scope="col">Hour total (tons)</th>
                                    <th scope="col">MCH-0003 (tons)</th>
                                    <th scope="col">Last updated</th>
                                </tr>
                            </thead>
                            <tbody id="production-table-body">
                                <tr id="production-empty-row">
                                    <td colspan="6" class="production-table__empty">
                                        No production records are available for this date.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="production-card forecast-card" id="forecast-card" aria-live="polite">
                <header class="production-card__header forecast-card__header">
                    <div>
                        <h2>Monthly production forecast</h2>
                        <p>Plan daily tons by machine while staying aware of Sri Lankan holidays.</p>
                    </div>
                    <div class="forecast-summary">
                        <span class="forecast-summary__label">Month total (tons)</span>
                        <span class="forecast-summary__value" id="forecast-total">0.00</span>
                    </div>
                </header>
                <div class="forecast-controls">
                    <div class="forecast-control">
                        <label for="forecast-machine">Machine ID <span class="required">*</span></label>
                        <select id="forecast-machine" name="forecast_machine" required disabled>
                            <option value="" disabled selected>Loading machines…</option>
                        </select>
                    </div>
                    <div class="forecast-month-nav" role="group" aria-label="Change month">
                        <button type="button" class="forecast-month-nav__button" id="forecast-prev-month" aria-label="Previous month" disabled>
                            &lsaquo;
                        </button>
                        <span class="forecast-month-nav__label" id="forecast-month-label"></span>
                        <button type="button" class="forecast-month-nav__button" id="forecast-next-month" aria-label="Next month" disabled>
                            &rsaquo;
                        </button>
                    </div>
                </div>
                <div class="forecast-layout">
                    <div class="forecast-left-panel">
                        <div class="forecast-calendar">
                            <table class="forecast-calendar__table">
                                <thead class="forecast-calendar__head">
                                    <tr>
                                        <th scope="col">Mon</th>
                                        <th scope="col">Tue</th>
                                        <th scope="col">Wed</th>
                                        <th scope="col">Thu</th>
                                        <th scope="col">Fri</th>
                                        <th scope="col">Sat</th>
                                        <th scope="col">Sun</th>
                                    </tr>
                                </thead>
                                <tbody class="forecast-calendar__body" id="forecast-calendar-body">
                                    <tr>
                                        <td colspan="7" class="forecast-calendar__empty">Select a machine to manage forecasts.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <article class="forecast-overview-card forecast-overview-card--idle">
                            <h4 class="forecast-overview-card__heading">Idle hours tracker</h4>
                            <p class="forecast-overview-card__note">
                                Target runtime
                                <span class="forecast-overview-card__note-value" id="idle-summary-target-hours">11.00</span>
                                <span class="forecast-overview-card__note-unit">hrs/day</span>
                            </p>
                            <div class="idle-summary__header">
                                <p class="idle-summary__period" id="idle-summary-period">—</p>
                                <p class="idle-summary__hint">Values show idle hours per machine.</p>
                            </div>
                            <div class="idle-summary__table-wrapper">
                                <table class="idle-summary__table">
                                    <thead>
                                        <tr id="idle-summary-head-row">
                                            <th scope="col">Day</th>
                                        </tr>
                                    </thead>
                                    <tbody id="idle-summary-body">
                                        <tr id="idle-summary-empty">
                                            <td colspan="1">Idle summary will appear here.</td>
                                        </tr>
                                    </tbody>
                                    <tfoot>
                                        <tr class="idle-summary__totals" id="idle-summary-totals-row">
                                            <th scope="row">Total idle</th>
                                        </tr>
                                    </tfoot>
                                </table>
                            </div>
                            <p class="idle-summary__error" id="idle-summary-error" hidden></p>
                        </article>
                    </div>
                    <div class="forecast-detail">
                        <form class="forecast-form" id="forecast-form" novalidate>
                            <input type="hidden" id="forecast-date" name="date" />
                            <div class="forecast-form__row">
                                <p class="forecast-form__label">Selected day</p>
                                <p class="forecast-form__value" id="forecast-date-display">—</p>
                            </div>
                            <div class="forecast-form__row">
                                <label for="forecast-hours">Forecasted production hours <span class="required">*</span></label>
                                <input
                                    id="forecast-hours"
                                    name="forecast_hours"
                                    type="number"
                                    min="0"
                                    step="0.25"
                                    placeholder="0.00"
                                    required
                                    disabled
                                />
                            </div>
                            <div class="forecast-form__row">
                                <label for="forecast-average">Average hourly production (tons) <span class="required">*</span></label>
                                <input
                                    id="forecast-average"
                                    name="average_hourly_production"
                                    type="number"
                                    min="0"
                                    step="0.01"
                                    placeholder="0.00"
                                    required
                                    disabled
                                />
                            </div>
                            <div class="forecast-form__row">
                                <label for="forecast-qty">Forecast qty (tons)</label>
                                <input
                                    id="forecast-qty"
                                    name="forecast_tons"
                                    type="number"
                                    min="0"
                                    step="0.01"
                                    placeholder="0.00"
                                    disabled
                                    readonly
                                />
                            </div>
                            <p class="forecast-holiday" id="forecast-holiday-note" hidden></p>
                            <div class="forecast-actions">
                                <button type="submit" class="button" id="forecast-submit" disabled>Save forecast</button>
                            </div>
                            <p class="forecast-feedback forecast-feedback--success" id="forecast-success" hidden>
                                Forecast updated successfully.
                            </p>
                            <p class="forecast-feedback forecast-feedback--error" id="forecast-error" hidden></p>
                        </form>
                        <section
                            class="forecast-overview"
                            id="forecast-overview"
                            aria-labelledby="forecast-overview-title"
                            aria-live="polite"
                        >
                            <h3 class="forecast-overview__title" id="forecast-overview-title">
                                Forecast summary
                            </h3>
                            <p class="forecast-overview__subtitle">
                                Track monthly output at a glance and compare productivity windows.
                            </p>
                            <div class="forecast-overview__grid">
                                <article class="forecast-overview-card forecast-overview-card--first">
                                    <h4 class="forecast-overview-card__heading">First 10 days</h4>
                                    <p class="forecast-overview-card__value">
                                        <span id="forecast-summary-first-ten">0.00</span>
                                        <span class="forecast-overview-card__unit">tons</span>
                                    </p>
                                    <ul
                                        class="forecast-overview-card__breakdown"
                                        id="forecast-summary-first-ten-breakdown"
                                    >
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0001"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0001
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0002"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0002
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                    </ul>
                                </article>
                                <article class="forecast-overview-card forecast-overview-card--middle">
                                    <h4 class="forecast-overview-card__heading">Middle 10 days</h4>
                                    <p class="forecast-overview-card__value">
                                        <span id="forecast-summary-middle-ten">0.00</span>
                                        <span class="forecast-overview-card__unit">tons</span>
                                    </p>
                                    <ul
                                        class="forecast-overview-card__breakdown"
                                        id="forecast-summary-middle-ten-breakdown"
                                    >
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0001"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0001
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0002"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0002
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                    </ul>
                                </article>
                                <article class="forecast-overview-card forecast-overview-card--last">
                                    <h4 class="forecast-overview-card__heading">Last days</h4>
                                    <p class="forecast-overview-card__value">
                                        <span id="forecast-summary-last-days">0.00</span>
                                        <span class="forecast-overview-card__unit">tons</span>
                                    </p>
                                    <ul
                                        class="forecast-overview-card__breakdown"
                                        id="forecast-summary-last-days-breakdown"
                                    >
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0001"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0001
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0002"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0002
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                    </ul>
                                    <p class="forecast-overview-card__hint">21st to month end</p>
                                </article>
                                <article class="forecast-overview-card forecast-overview-card--briquette">
                                    <h4 class="forecast-overview-card__heading">Briquette production</h4>
                                    <p class="forecast-overview-card__value">
                                        <span id="forecast-summary-briquette">0.00</span>
                                        <span class="forecast-overview-card__unit">tons</span>
                                    </p>
                                    <ul
                                        class="forecast-overview-card__breakdown"
                                        id="forecast-summary-briquette-breakdown"
                                    >
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0001"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0001
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                        <li
                                            class="forecast-overview-card__breakdown-item"
                                            data-machine="MCH-0002"
                                        >
                                            <span class="forecast-overview-card__breakdown-label">
                                                MCH-0002
                                            </span>
                                            <span class="forecast-overview-card__breakdown-value">0.00</span>
                                        </li>
                                    </ul>
                                    <p class="forecast-overview-card__hint">MCH-0001 + MCH-0002 only</p>
                                </article>
                                <article class="forecast-overview-card forecast-overview-card--dryer">
                                    <h4 class="forecast-overview-card__heading">Dryer production</h4>
                                    <p class="forecast-overview-card__value">
                                        <span id="forecast-summary-dryer">0.00</span>
                                        <span class="forecast-overview-card__unit">tons</span>
                                    </p>
                                    <p class="forecast-overview-card__note">
                                        Avg hourly output
                                        <span class="forecast-overview-card__note-value" id="forecast-summary-dryer-average"
                                            >0.00</span
                                        >
                                        <span class="forecast-overview-card__note-unit">tons/hr</span>
                                    </p>
                                </article>
                                <article class="forecast-overview-card forecast-overview-card--hourly">
                                    <h4 class="forecast-overview-card__heading">Hourly output</h4>
                                    <p class="forecast-overview-card__value">
                                        <span id="forecast-summary-hourly-output">0.00</span>
                                        <span class="forecast-overview-card__unit">tons/hr</span>
                                    </p>
                                    <ul
                                        class="forecast-overview-card__micro-breakdown"
                                        id="forecast-summary-hourly-output-breakdown"
                                    >
                                        <li class="forecast-overview-card__micro-item" data-machine="MCH-0001">
                                            <span class="forecast-overview-card__micro-label">MCH-0001</span>
                                            <span class="forecast-overview-card__micro-value">0.00</span>
                                        </li>
                                        <li class="forecast-overview-card__micro-item" data-machine="MCH-0002">
                                            <span class="forecast-overview-card__micro-label">MCH-0002</span>
                                            <span class="forecast-overview-card__micro-value">0.00</span>
                                        </li>
                                    </ul>
                                </article>
                                <article class="forecast-overview-card forecast-overview-card--hours">
                                    <h4 class="forecast-overview-card__heading">Machine hours</h4>
                                    <ul class="forecast-overview-card__micro-breakdown" id="forecast-summary-machine-hours">
                                        <li class="forecast-overview-card__micro-item" data-machine="MCH-0001">
                                            <span class="forecast-overview-card__micro-label">MCH-0001</span>
                                            <span class="forecast-overview-card__micro-value">0.00</span>
                                        </li>
                                        <li class="forecast-overview-card__micro-item" data-machine="MCH-0002">
                                            <span class="forecast-overview-card__micro-label">MCH-0002</span>
                                            <span class="forecast-overview-card__micro-value">0.00</span>
                                        </li>
                                        <li class="forecast-overview-card__micro-item" data-machine="MCH-0003">
                                            <span class="forecast-overview-card__micro-label">MCH-0003</span>
                                            <span class="forecast-overview-card__micro-value">0.00</span>
                                        </li>
                                    </ul>
                                    <p class="forecast-overview-card__note">Total scheduled hours captured per machine.</p>
                                </article>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>
    </div>
    <script>
        const token = localStorage.getItem("samprox_token");
        const userRaw = localStorage.getItem("samprox_user");
        let user;

        try {
            user = userRaw ? JSON.parse(userRaw) : null;
        } catch (_) {
            user = null;
        }

        if (!token || !user) {
            window.location.href = "/";
        }

        const roleLabels = {
            admin: "Admin",
            production_manager: "Production Manager",
            maintenance_manager: "Maintenance Manager",
            technician: "Technician",
        };

        const userNameEl = document.getElementById("user-name");
        const userRoleEl = document.getElementById("user-role");
        const logoutButton = document.getElementById("logout");

        userNameEl.textContent = user?.name || "Unknown";
        userRoleEl.textContent = roleLabels[user?.role] || "";

        logoutButton.addEventListener("click", () => {
            localStorage.removeItem("samprox_token");
            localStorage.removeItem("samprox_user");
            window.location.href = "/";
        });

        const machineSelect = document.getElementById("production-machine");
        const dateInput = document.getElementById("production-date");
        const hourSelect = document.getElementById("production-hour");
        const quantityInput = document.getElementById("production-qty");
        const productionForm = document.getElementById("production-form");
        const productionSuccess = document.getElementById("production-success");
        const productionError = document.getElementById("production-error");
        const productionTableBody = document.getElementById("production-table-body");
        const productionEmptyRow = document.getElementById("production-empty-row");
        const productionTotal = document.getElementById("production-total");
        const productionSubmit = document.getElementById("production-submit");

        const forecastMachineSelect = document.getElementById("forecast-machine");
        const forecastMonthLabel = document.getElementById("forecast-month-label");
        const forecastPrevMonth = document.getElementById("forecast-prev-month");
        const forecastNextMonth = document.getElementById("forecast-next-month");
        const forecastCalendarBody = document.getElementById("forecast-calendar-body");
        const forecastForm = document.getElementById("forecast-form");
        const forecastDateInput = document.getElementById("forecast-date");
        const forecastDateDisplay = document.getElementById("forecast-date-display");
        const forecastHoursInput = document.getElementById("forecast-hours");
        const forecastAverageInput = document.getElementById("forecast-average");
        const forecastQtyInput = document.getElementById("forecast-qty");
        const forecastSubmit = document.getElementById("forecast-submit");
        const forecastSuccess = document.getElementById("forecast-success");
        const forecastError = document.getElementById("forecast-error");
        const forecastHolidayNote = document.getElementById("forecast-holiday-note");
        const forecastTotal = document.getElementById("forecast-total");
        const forecastSummaryElements = {
            firstTen: document.getElementById("forecast-summary-first-ten"),
            middleTen: document.getElementById("forecast-summary-middle-ten"),
            lastDays: document.getElementById("forecast-summary-last-days"),
            briquette: document.getElementById("forecast-summary-briquette"),
            hourlyOutput: document.getElementById("forecast-summary-hourly-output"),
            dryerTotal: document.getElementById("forecast-summary-dryer"),
            dryerAverage: document.getElementById("forecast-summary-dryer-average"),
        };
        const forecastSummaryBreakdowns = {
            firstTen: getForecastBreakdownElements("forecast-summary-first-ten-breakdown"),
            middleTen: getForecastBreakdownElements(
                "forecast-summary-middle-ten-breakdown",
            ),
            lastDays: getForecastBreakdownElements("forecast-summary-last-days-breakdown"),
            briquette: getForecastBreakdownElements(
                "forecast-summary-briquette-breakdown",
            ),
        };
        const hourlyOutputBreakdownElements = getForecastBreakdownElements(
            "forecast-summary-hourly-output-breakdown",
        );
        const machineHourElements = getForecastBreakdownElements(
            "forecast-summary-machine-hours",
        );

        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, "0");
        const dd = String(today.getDate()).padStart(2, "0");
        dateInput.value = `${yyyy}-${mm}-${dd}`;

        const authHeaders = {
            Authorization: `Bearer ${token}`,
        };

        let machinesCache = [];

        function normalizeMachineCodeKey(code) {
            if (typeof code !== "string") {
                return "";
            }

            const trimmed = code.trim().toUpperCase();
            const match = trimmed.match(/^([A-Z]+)-0*(\d+)$/);
            if (!match) {
                return trimmed;
            }

            return `${match[1]}-${Number(match[2])}`;
        }

        function addDaysToDateString(dateString, days) {
            if (!dateString) return dateString;
            const parts = dateString.split("-");
            if (parts.length !== 3) return dateString;
            const [yearRaw, monthRaw, dayRaw] = parts;
            const year = Number.parseInt(yearRaw, 10);
            const month = Number.parseInt(monthRaw, 10);
            const day = Number.parseInt(dayRaw, 10);
            if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
                return dateString;
            }
            const utcDate = new Date(Date.UTC(year, month - 1, day));
            if (Number.isNaN(utcDate.getTime())) {
                return dateString;
            }
            utcDate.setUTCDate(utcDate.getUTCDate() + days);
            const nextYear = String(utcDate.getUTCFullYear()).padStart(4, "0");
            const nextMonth = String(utcDate.getUTCMonth() + 1).padStart(2, "0");
            const nextDay = String(utcDate.getUTCDate()).padStart(2, "0");
            return `${nextYear}-${nextMonth}-${nextDay}`;
        }

        function buildDateTimeString(dateString, hour, minute = 0) {
            if (!dateString) return null;
            const parts = dateString.split("-");
            if (parts.length !== 3) return null;
            const [yearRaw, monthRaw, dayRaw] = parts;
            const year = Number.parseInt(yearRaw, 10);
            const month = Number.parseInt(monthRaw, 10);
            const day = Number.parseInt(dayRaw, 10);
            if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
                return null;
            }
            const safeHour = Math.max(0, Math.min(Number.parseInt(hour, 10), 23));
            const safeMinute = Math.max(0, Math.min(Number.parseInt(minute, 10), 59));
            const y = String(year).padStart(4, "0");
            const m = String(month).padStart(2, "0");
            const d = String(day).padStart(2, "0");
            const h = String(safeHour).padStart(2, "0");
            const min = String(safeMinute).padStart(2, "0");
            return `${y}-${m}-${d}T${h}:${min}:00`;
        }

        function getProductionHourWindowDetails(dateValue, hourNo) {
            const hourNumber = Number(hourNo);
            if (!Number.isFinite(hourNumber) || hourNumber < 1 || hourNumber > 24) {
                return null;
            }

            const startHour = Math.max(0, Math.min(hourNumber - 1, 23));
            const startIso = buildDateTimeString(dateValue, startHour);
            if (!startIso) return null;

            const endIso =
                hourNumber >= 24
                    ? buildDateTimeString(addDaysToDateString(dateValue, 1), 0)
                    : buildDateTimeString(dateValue, startHour + 1);
            if (!endIso) return null;

            const startDate = new Date(startIso);
            const endDate = new Date(endIso);
            if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
                return null;
            }

            return { startIso, endIso, startDate, endDate };
        }

        function parseDateFromIso(value) {
            if (!value) return null;
            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) {
                return null;
            }
            return parsed;
        }

        function formatRangeLabel(startIso, endIso, referenceDate) {
            if (!startIso) return "this time window";
            const startDate = parseDateFromIso(startIso);
            if (!startDate) return "this time window";

            const formatTime = (date) => {
                const hours = String(date.getHours()).padStart(2, "0");
                const minutes = String(date.getMinutes()).padStart(2, "0");
                return `${hours}:${minutes}`;
            };

            const startDatePart = startIso.split("T")[0];
            const endDatePart = endIso ? endIso.split("T")[0] : null;
            const baseline = referenceDate || startDatePart;

            let startLabel = formatTime(startDate);
            if (startDatePart && baseline && startDatePart !== baseline) {
                startLabel = `${startDatePart} ${startLabel}`;
            }

            let endLabel = "ongoing";
            if (endIso) {
                const endDate = parseDateFromIso(endIso);
                if (endDate) {
                    endLabel = formatTime(endDate);
                    if (endDatePart && baseline && endDatePart !== baseline) {
                        endLabel = `${endDatePart} ${endLabel}`;
                    }
                }
            }

            return `${startLabel} – ${endLabel}`;
        }

        function formatConflictMessage(conflict, fallbackMessage, options = {}) {
            if (!conflict || typeof conflict !== "object") {
                return fallbackMessage;
            }

            const referenceDate = options.referenceDate || null;

            if (conflict.type === "idle_event") {
                const idle = conflict.idle_event || {};
                const range = formatRangeLabel(idle.start, idle.end, referenceDate);
                const reason = idle.reason ? ` (${idle.reason})` : "";
                return `Idle window ${range}${reason} is already logged. Adjust or remove it before recording production.`;
            }

            if (conflict.type === "production_hour") {
                const production = conflict.production_hour || {};
                const range = formatRangeLabel(production.start, production.end, referenceDate);
                const hourNumber = Number(production.hour_no);
                const hourLabel = Number.isFinite(hourNumber)
                    ? `hour ${String(hourNumber).padStart(2, "0")}`
                    : "a recorded hour";
                const quantityValue = Number(production.quantity_tons);
                const quantityLabel = Number.isFinite(quantityValue)
                    ? ` (${quantityValue.toFixed(2)} tons)`
                    : "";
                return `Production ${hourLabel}${quantityLabel} already exists for ${range}. Clear it before logging idle time.`;
            }

            return fallbackMessage;
        }

        async function findIdleConflictForProduction(machineCode, dateValue, hourNo) {
            const windowDetails = getProductionHourWindowDetails(dateValue, hourNo);
            if (!machineCode || !dateValue || !windowDetails) {
                return null;
            }

            const params = new URLSearchParams({
                machine_codes: machineCode,
                start_date: dateValue,
                end_date: dateValue,
            });

            const response = await fetch(`/api/machines/idle-events?${params.toString()}`, {
                headers: authHeaders,
            });

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error(`Unable to load idle events (${response.status})`);
            }

            const events = await response.json().catch(() => []);
            if (!Array.isArray(events)) {
                return null;
            }

            for (const event of events) {
                const eventStart = parseDateFromIso(event?.started_at);
                if (!eventStart) {
                    continue;
                }

                let eventEnd = parseDateFromIso(event?.ended_at);
                if (!eventEnd) {
                    eventEnd = new Date(eventStart.getTime() + 24 * 60 * 60 * 1000);
                }

                if (eventStart < windowDetails.endDate && eventEnd > windowDetails.startDate) {
                    return {
                        type: "idle_event",
                        machine: event?.asset || null,
                        hour: {
                            hour_no: hourNo,
                            start: windowDetails.startIso,
                            end: windowDetails.endIso,
                        },
                        idle_event: {
                            id: event?.id ?? null,
                            start: event?.started_at ?? null,
                            end: event?.ended_at ?? null,
                            reason: event?.reason ?? null,
                        },
                    };
                }
            }

            return null;
        }

        const SUMMARY_MACHINE_CODES = ["MCH-0001", "MCH-0002"];
        const SUMMARY_EXTRA_MACHINE_CODES = ["MCH-0003"];
        const SUMMARY_ALL_MACHINE_CODES = [
            ...SUMMARY_MACHINE_CODES,
            ...SUMMARY_EXTRA_MACHINE_CODES,
        ];
        const SUMMARY_MACHINE_NORMALIZED_CODES = SUMMARY_ALL_MACHINE_CODES.map((code) =>
            normalizeMachineCodeKey(code),
        ).filter((value) => value.length > 0);
        const MACHINE_HOUR_CODES = ["MCH-0001", "MCH-0002", "MCH-0003"];
        const MACHINE_HOUR_NORMALIZED_CODES = MACHINE_HOUR_CODES.map((code) =>
            normalizeMachineCodeKey(code),
        ).filter((value) => value.length > 0);
        const DEFAULT_IDLE_SUMMARY_MACHINE_CODES = [
            "MCH-0001",
            "MCH-0002",
            "MCH-0003",
        ];
        const IDLE_SCHEDULED_HOURS_PER_DAY = 11;
        const DRYER_MACHINE_CODE = "MCH-0003";
        const DRYER_MACHINE_NORMALIZED_CODE = normalizeMachineCodeKey(DRYER_MACHINE_CODE);
        let idleSummaryMachineCodes = DEFAULT_IDLE_SUMMARY_MACHINE_CODES.slice();
        const forecastState = {
            anchorDate: new Date(today.getFullYear(), today.getMonth(), 1),
            selectedDate: new Date(today.getFullYear(), today.getMonth(), today.getDate()),
            preferredDay: today.getDate(),
            machineCode: "",
            entries: new Map(),
            holidaysByYear: new Map(),
            total: 0,
            overview: createEmptyForecastOverview(),
        };

        function getActiveMachineCodes() {
            if (!Array.isArray(machinesCache)) {
                return [];
            }
            return machinesCache
                .map((machine) => machine?.code)
                .filter((code) => typeof code === "string" && code.trim().length > 0);
        }

        function normalizeMachineCodeForClass(code) {
            return (code || "").toLowerCase().replace(/[^a-z0-9]+/g, "-");
        }

        function getForecastBreakdownElements(containerId) {
            const container = document.getElementById(containerId);
            if (!container) {
                return {};
            }

            const elements = {};
            container.querySelectorAll("[data-machine]").forEach((item) => {
                const machineAttr = item.getAttribute("data-machine");
                const normalized = normalizeMachineCodeKey(machineAttr);
                if (!normalized) {
                    return;
                }

                const valueElement = item.querySelector(
                    ".forecast-overview-card__breakdown-value, .forecast-overview-card__micro-value",
                );
                if (valueElement) {
                    elements[normalized] = valueElement;
                }
            });

            return elements;
        }

        function formatHourLabel(hourNumber) {
            const value = Number(hourNumber);
            if (!Number.isFinite(value) || value < 1 || value > 24) {
                return "";
            }

            const startHour = value - 1;
            const endHour = value % 24;

            const formatPart = (hour) => {
                const hour12 = hour % 12 === 0 ? 12 : hour % 12;
                const period = hour < 12 ? "am" : "pm";
                return `${hour12}.00 ${period}`;
            };

            return `${formatPart(startHour)} - ${formatPart(endHour)}`;
        }

        const HOUR_LABELS = {};
        for (let hour = 1; hour <= 24; hour += 1) {
            const label = formatHourLabel(hour);
            if (label) {
                HOUR_LABELS[hour] = label;
            }
        }

        if (hourSelect) {
            Array.from(hourSelect.options).forEach((option) => {
                const optionValue = Number(option.value);
                if (!Number.isFinite(optionValue)) {
                    return;
                }

                const label = HOUR_LABELS[optionValue];
                if (label) {
                    option.textContent = label;
                }
            });
        }

        function createEmptyContributions() {
            const contributions = {};
            SUMMARY_MACHINE_NORMALIZED_CODES.forEach((code) => {
                contributions[code] = 0;
            });
            return contributions;
        }

        function createEmptyMachineTotals(codes) {
            const totals = {};
            (codes || []).forEach((code) => {
                totals[code] = 0;
            });
            return totals;
        }

        function createEmptyRangeSummary() {
            return {
                total: 0,
                contributions: createEmptyContributions(),
            };
        }

        function ensureForecastEntry(dateIso) {
            if (!dateIso) {
                return null;
            }
            if (!forecastState.entries.has(dateIso)) {
                forecastState.entries.set(dateIso, {
                    machines: {},
                    hours: {},
                    averageHourlyProduction: {},
                    total: 0,
                });
            }
            const entry = forecastState.entries.get(dateIso);
            if (entry && !entry.machines) {
                entry.machines = {};
            }
            if (entry && !entry.hours) {
                entry.hours = {};
            }
            if (entry && !entry.averageHourlyProduction) {
                entry.averageHourlyProduction = {};
            }
            return entry;
        }

        function getMachineForecastValue(dateIso, machineCode) {
            if (!dateIso || !machineCode) {
                return 0;
            }
            const entry = forecastState.entries.get(dateIso);
            if (!entry || !entry.machines) {
                return 0;
            }
            const value = Number(entry.machines[machineCode]);
            return Number.isFinite(value) ? value : 0;
        }

        function getMachineForecastHours(dateIso, machineCode) {
            if (!dateIso || !machineCode) {
                return 0;
            }
            const entry = forecastState.entries.get(dateIso);
            if (!entry || !entry.hours) {
                return 0;
            }
            const value = Number(entry.hours[machineCode]);
            return Number.isFinite(value) ? value : 0;
        }

        function getMachineAverageHourlyProduction(dateIso, machineCode) {
            if (!dateIso || !machineCode) {
                return 0;
            }
            const entry = forecastState.entries.get(dateIso);
            if (!entry || !entry.averageHourlyProduction) {
                return 0;
            }
            const value = Number(entry.averageHourlyProduction[machineCode]);
            return Number.isFinite(value) ? value : 0;
        }

        function updateEntryTotal(entry, machineCodes) {
            if (!entry) {
                return;
            }
            const codes = Array.isArray(machineCodes) && machineCodes.length > 0
                ? machineCodes
                : getActiveMachineCodes();

            const normalizedActiveCodes = Array.isArray(codes)
                ? codes
                      .map((code) => normalizeMachineCodeKey(code))
                      .filter((value) => value.length > 0)
                : [];
            const activeCodeSet = new Set(normalizedActiveCodes);

            entry.machines = entry.machines || {};

            Object.keys(entry.machines).forEach((code) => {
                const number = Number(entry.machines[code]);
                entry.machines[code] = Number.isFinite(number)
                    ? Number(number.toFixed(3))
                    : 0;
            });

            if (activeCodeSet.size > 0) {
                codes.forEach((code) => {
                    if (!Object.prototype.hasOwnProperty.call(entry.machines, code)) {
                        entry.machines[code] = 0;
                    }
                });
            }

            const limitToActive = activeCodeSet.size > 0;

            let total = 0;
            Object.entries(entry.machines).forEach(([code, value]) => {
                const normalizedCode = normalizeMachineCodeKey(code);
                if (limitToActive && !activeCodeSet.has(normalizedCode)) {
                    return;
                }
                const number = Number(value);
                if (Number.isFinite(number)) {
                    total += number;
                }
            });

            entry.total = Number.isFinite(total) ? Number(total.toFixed(3)) : 0;
        }

        function createEmptyForecastOverview() {
            return {
                monthTotal: 0,
                firstTen: createEmptyRangeSummary(),
                middleTen: createEmptyRangeSummary(),
                lastDays: createEmptyRangeSummary(),
                briquette: createEmptyRangeSummary(),
                totalHours: 0,
                hourlyOutput: 0,
                hourlyOutputMachines: createEmptyMachineTotals(
                    SUMMARY_MACHINE_NORMALIZED_CODES,
                ),
                machineHours: createEmptyMachineTotals(MACHINE_HOUR_NORMALIZED_CODES),
                dryer: {
                    total: 0,
                    average: 0,
                },
            };
        }

        function roundToThree(value) {
            const number = Number(value);
            return Number.isFinite(number) ? Number(number.toFixed(3)) : 0;
        }

        function sumForecastMachineValues(machines, { limitSet = null, predicate = null } = {}) {
            if (!machines || typeof machines !== "object") {
                return 0;
            }

            const hasLimit = limitSet instanceof Set && limitSet.size > 0;
            const hasPredicate = typeof predicate === "function";

            return Object.entries(machines).reduce((accumulator, [code, rawValue]) => {
                const normalizedCode = normalizeMachineCodeKey(code);
                if (hasLimit && !limitSet.has(normalizedCode)) {
                    return accumulator;
                }

                const number = Number(rawValue);
                if (!Number.isFinite(number)) {
                    return accumulator;
                }

                if (hasPredicate && !predicate(normalizedCode, number)) {
                    return accumulator;
                }

                return accumulator + number;
            }, 0);
        }

        function addRangeValues(rangeSummary, contributions) {
            if (!rangeSummary || !contributions) {
                return;
            }

            SUMMARY_MACHINE_NORMALIZED_CODES.forEach((code) => {
                const value = Number(contributions?.[code] ?? 0);
                if (!Number.isFinite(value)) {
                    return;
                }
                rangeSummary.contributions[code] += value;
                rangeSummary.total += value;
            });
        }

        function finalizeRangeSummary(rangeSummary) {
            if (!rangeSummary) {
                return;
            }

            rangeSummary.total = roundToThree(rangeSummary.total);
            SUMMARY_MACHINE_NORMALIZED_CODES.forEach((code) => {
                rangeSummary.contributions[code] = roundToThree(
                    rangeSummary.contributions[code],
                );
            });
        }

        function sumForecastHours(hours, limitSet) {
            if (!hours || typeof hours !== "object") {
                return 0;
            }

            const hasLimit = limitSet instanceof Set && limitSet.size > 0;

            return Object.entries(hours).reduce((accumulator, [code, rawValue]) => {
                const normalizedCode = normalizeMachineCodeKey(code);
                if (hasLimit && !limitSet.has(normalizedCode)) {
                    return accumulator;
                }

                const number = Number(rawValue);
                return Number.isFinite(number) ? accumulator + number : accumulator;
            }, 0);
        }

        function calculateForecastOverview() {
            const overview = createEmptyForecastOverview();

            if (!(forecastState.entries instanceof Map) || forecastState.entries.size === 0) {
                return overview;
            }

            const anchorYear = forecastState.anchorDate.getFullYear();
            const anchorMonth = forecastState.anchorDate.getMonth();

            const activeCodes = getActiveMachineCodes();
            const normalizedActiveCodes = Array.isArray(activeCodes)
                ? activeCodes
                      .map((code) => normalizeMachineCodeKey(code))
                      .filter((value) => value.length > 0)
                : [];
            const limitSet = normalizedActiveCodes.length > 0
                ? new Set(normalizedActiveCodes)
                : null;

            let monthTotal = 0;
            let totalHours = 0;
            const machineProductionTotals = createEmptyMachineTotals(
                MACHINE_HOUR_NORMALIZED_CODES,
            );
            const machineHourTotals = createEmptyMachineTotals(MACHINE_HOUR_NORMALIZED_CODES);

            forecastState.entries.forEach((entry, dateIso) => {
                const date = parseISODate(dateIso);
                if (!date || date.getFullYear() !== anchorYear || date.getMonth() !== anchorMonth) {
                    return;
                }

                const machines = entry?.machines || {};
                const hours = entry?.hours || {};

                const dayTotal = sumForecastMachineValues(machines, { limitSet });
                monthTotal += dayTotal;

                const normalizedMachines = {};
                Object.entries(machines).forEach(([code, rawValue]) => {
                    const normalizedCode = normalizeMachineCodeKey(code);
                    if (!normalizedCode) {
                        return;
                    }
                    const number = Number(rawValue);
                    if (!Number.isFinite(number)) {
                        return;
                    }
                    normalizedMachines[normalizedCode] =
                        (normalizedMachines[normalizedCode] || 0) + number;
                });

                const contributions = {};
                SUMMARY_MACHINE_NORMALIZED_CODES.forEach((code) => {
                    contributions[code] = normalizedMachines[code] || 0;
                });

                MACHINE_HOUR_NORMALIZED_CODES.forEach((code) => {
                    const value = normalizedMachines[code] || 0;
                    if (Number.isFinite(value)) {
                        machineProductionTotals[code] += value;
                    }
                });

                const day = date.getDate();
                if (day <= 10) {
                    addRangeValues(overview.firstTen, contributions);
                } else if (day <= 20) {
                    addRangeValues(overview.middleTen, contributions);
                } else {
                    addRangeValues(overview.lastDays, contributions);
                }

                addRangeValues(overview.briquette, contributions);

                const normalizedHours = {};
                Object.entries(hours).forEach(([code, rawValue]) => {
                    const normalizedCode = normalizeMachineCodeKey(code);
                    if (!normalizedCode) {
                        return;
                    }
                    const number = Number(rawValue);
                    if (!Number.isFinite(number)) {
                        return;
                    }
                    normalizedHours[normalizedCode] =
                        (normalizedHours[normalizedCode] || 0) + number;
                });

                MACHINE_HOUR_NORMALIZED_CODES.forEach((code) => {
                    const value = normalizedHours[code] || 0;
                    if (Number.isFinite(value)) {
                        machineHourTotals[code] += value;
                    }
                });

                totalHours += sumForecastHours(hours, limitSet);
            });

            const hourlyOutput = totalHours > 0 ? monthTotal / totalHours : 0;

            overview.monthTotal = roundToThree(monthTotal);
            overview.totalHours = roundToThree(totalHours);
            overview.hourlyOutput = roundToThree(hourlyOutput);

            const hourlyBreakdown = createEmptyMachineTotals(
                SUMMARY_MACHINE_NORMALIZED_CODES,
            );
            SUMMARY_MACHINE_NORMALIZED_CODES.forEach((code) => {
                const production = machineProductionTotals[code] || 0;
                const hoursTotal = machineHourTotals[code] || 0;
                const average = hoursTotal > 0 ? production / hoursTotal : 0;
                hourlyBreakdown[code] = roundToThree(average);
            });

            const machineHours = createEmptyMachineTotals(MACHINE_HOUR_NORMALIZED_CODES);
            MACHINE_HOUR_NORMALIZED_CODES.forEach((code) => {
                machineHours[code] = roundToThree(machineHourTotals[code] || 0);
            });

            const dryerTotal = machineProductionTotals[DRYER_MACHINE_NORMALIZED_CODE] || 0;
            const dryerHours = machineHourTotals[DRYER_MACHINE_NORMALIZED_CODE] || 0;
            const dryerAverage = dryerHours > 0 ? dryerTotal / dryerHours : 0;

            overview.hourlyOutputMachines = hourlyBreakdown;
            overview.machineHours = machineHours;
            overview.dryer = {
                total: roundToThree(dryerTotal),
                average: roundToThree(dryerAverage),
            };

            finalizeRangeSummary(overview.firstTen);
            finalizeRangeSummary(overview.middleTen);
            finalizeRangeSummary(overview.lastDays);
            finalizeRangeSummary(overview.briquette);

            return overview;
        }

        function updateForecastOverviewUI() {
            const overview = forecastState.overview || createEmptyForecastOverview();

            updateRangeCard("firstTen", overview.firstTen);
            updateRangeCard("middleTen", overview.middleTen);
            updateRangeCard("lastDays", overview.lastDays);
            updateRangeCard("briquette", overview.briquette);
            updateTotalElement(forecastSummaryElements.hourlyOutput, overview.hourlyOutput);
            updateTotalElement(
                forecastSummaryElements.dryerTotal,
                overview?.dryer?.total ?? 0,
            );
            updateTotalElement(
                forecastSummaryElements.dryerAverage,
                overview?.dryer?.average ?? 0,
            );
            updateBreakdownValues(hourlyOutputBreakdownElements, overview.hourlyOutputMachines);
            updateBreakdownValues(machineHourElements, overview.machineHours);
        }

        function updateRangeCard(rangeKey, summary) {
            if (!rangeKey) {
                return;
            }

            const rangeSummary = summary || createEmptyRangeSummary();
            const totalElement = forecastSummaryElements[rangeKey];
            if (totalElement) {
                updateTotalElement(totalElement, rangeSummary.total);
            }

            const breakdownElements = forecastSummaryBreakdowns[rangeKey] || {};
            Object.entries(breakdownElements).forEach(([code, element]) => {
                if (!element) {
                    return;
                }
                const value = rangeSummary.contributions?.[code];
                updateTotalElement(element, value ?? 0);
            });
        }

        function updateBreakdownValues(elementMap, values) {
            if (!elementMap) {
                return;
            }

            Object.entries(elementMap).forEach(([code, element]) => {
                if (!element) {
                    return;
                }
                const value = values?.[code];
                updateTotalElement(element, value ?? 0);
            });
        }

        function showMessage(element, message = "") {
            if (!element) return;
            if (message) {
                element.textContent = message;
                element.hidden = false;
            } else {
                element.hidden = true;
            }
        }

        function clearFeedback() {
            showMessage(productionSuccess);
            showMessage(productionError);
        }

        function setFormDisabled(disabled) {
            productionSubmit.disabled = disabled;
            dateInput.disabled = disabled;
            machineSelect.disabled = disabled;
            hourSelect.disabled = disabled;
            quantityInput.disabled = disabled;
        }

        function clearForecastFeedback() {
            showMessage(forecastSuccess);
            showMessage(forecastError);
        }

        function formatPeriodFromDate(date) {
            if (!(date instanceof Date) || Number.isNaN(date.valueOf())) {
                return "";
            }

            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");

            return `${year}-${month}`;
        }

        function formatDateISO(date) {
            if (!(date instanceof Date) || Number.isNaN(date.valueOf())) {
                return "";
            }

            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");

            return `${year}-${month}-${day}`;
        }

        function parseISODate(dateIso) {
            if (typeof dateIso !== "string") {
                return null;
            }

            const [yearStr, monthStr, dayStr] = dateIso.split("-");
            const year = Number(yearStr);
            const month = Number(monthStr);
            const day = Number(dayStr);

            if (
                !Number.isFinite(year) ||
                !Number.isFinite(month) ||
                !Number.isFinite(day)
            ) {
                return null;
            }

            const parsed = new Date(year, month - 1, day);

            if (Number.isNaN(parsed.valueOf())) {
                return null;
            }

            return parsed;
        }

        function updateForecastMonthLabel() {
            if (!forecastMonthLabel) {
                return;
            }
            const localeLabel = forecastState.anchorDate.toLocaleDateString(undefined, {
                month: "long",
                year: "numeric",
            });
            forecastMonthLabel.textContent = localeLabel;
        }

        function ensureForecastNavState() {
            const disabled = !forecastState.machineCode;
            if (forecastPrevMonth) {
                forecastPrevMonth.disabled = disabled;
            }
            if (forecastNextMonth) {
                forecastNextMonth.disabled = disabled;
            }
        }

        function ensureForecastFormState() {
            const hasMachine = Boolean(forecastState.machineCode);
            const hasDate = Boolean(forecastState.selectedDate);
            if (forecastHoursInput) {
                forecastHoursInput.disabled = !hasMachine || !hasDate;
            }
            if (forecastAverageInput) {
                forecastAverageInput.disabled = !hasMachine || !hasDate;
            }
            if (forecastQtyInput) {
                forecastQtyInput.disabled = !hasMachine || !hasDate;
            }
            if (forecastSubmit) {
                forecastSubmit.disabled = !hasMachine || !hasDate;
            }
        }

        function setForecastFormDisabled(disabled) {
            if (forecastHoursInput) {
                forecastHoursInput.disabled = disabled;
            }
            if (forecastAverageInput) {
                forecastAverageInput.disabled = disabled;
            }
            if (forecastQtyInput) {
                forecastQtyInput.disabled = disabled;
            }
            if (forecastSubmit) {
                forecastSubmit.disabled = disabled;
            }
        }

        function renderForecastEmptyState(message) {
            if (!forecastCalendarBody) {
                return;
            }
            forecastCalendarBody.innerHTML = "";
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 7;
            td.className = "forecast-calendar__empty";
            td.textContent = message;
            tr.appendChild(td);
            forecastCalendarBody.appendChild(tr);
        }

        function getHolidayForDate(dateIso) {
            if (!dateIso) {
                return null;
            }
            const year = Number(dateIso.slice(0, 4));
            if (!Number.isFinite(year)) {
                return null;
            }
            const yearMap = forecastState.holidaysByYear.get(year);
            return yearMap ? yearMap.get(dateIso) : null;
        }

        async function ensureHolidaysForYear(year) {
            if (!Number.isFinite(year)) {
                return;
            }
            if (forecastState.holidaysByYear.has(year)) {
                return;
            }
            try {
                const response = await fetch(`/api/production/forecast/holidays?year=${year}`, {
                    headers: authHeaders,
                });
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Unable to load Sri Lanka holidays for this year.");
                }
                const data = await response.json();
                const list = Array.isArray(data?.holidays) ? data.holidays : [];
                const map = new Map();
                list.forEach((item) => {
                    if (item?.date && item?.name) {
                        map.set(item.date, item.name);
                    }
                });
                forecastState.holidaysByYear.set(year, map);
            } catch (error) {
                forecastState.holidaysByYear.set(year, new Map());
                showMessage(
                    forecastError,
                    error?.message || "Unable to load Sri Lanka holidays for this year.",
                );
            }
        }

        function recalculateForecastTotal() {
            const overview = calculateForecastOverview();
            forecastState.overview = overview;
            const monthTotal = overview?.monthTotal ?? 0;
            forecastState.total = Number.isFinite(monthTotal)
                ? Number(monthTotal.toFixed(3))
                : 0;
        }

        function updateForecastTotalElement() {
            if (forecastTotal) {
                updateTotalElement(forecastTotal, forecastState.total);
            }
            updateForecastOverviewUI();
        }

        function ensureSelectedDateInAnchorMonth() {
            const year = forecastState.anchorDate.getFullYear();
            const month = forecastState.anchorDate.getMonth();
            const monthDays = new Date(year, month + 1, 0).getDate();
            let candidate = forecastState.selectedDate;
            if (!(candidate instanceof Date) || Number.isNaN(candidate.valueOf())) {
                candidate = new Date(year, month, Math.min(forecastState.preferredDay, monthDays));
            }
            if (candidate.getFullYear() !== year || candidate.getMonth() !== month) {
                const day = Math.min(forecastState.preferredDay, monthDays);
                candidate = new Date(year, month, day);
            }
            forecastState.selectedDate = candidate;
            forecastState.preferredDay = candidate.getDate();
        }

        function updateForecastSelectionUI() {
            const selectedDate = forecastState.selectedDate;
            const iso =
                selectedDate &&
                selectedDate instanceof Date &&
                !Number.isNaN(selectedDate.valueOf())
                    ? formatDateISO(selectedDate)
                    : "";

            if (forecastDateInput) {
                forecastDateInput.value = iso;
            }
            if (forecastDateDisplay) {
                if (iso) {
                    const displayDate = parseISODate(iso);
                    forecastDateDisplay.textContent = displayDate
                        ? displayDate.toLocaleDateString(undefined, {
                              weekday: "long",
                              month: "long",
                              day: "numeric",
                              year: "numeric",
                          })
                        : "—";
                } else {
                    forecastDateDisplay.textContent = "—";
                }
            }

            const selectedMachineCode = forecastState.machineCode;
            const hasSelection = Boolean(iso && selectedMachineCode);
            const forecastValue = hasSelection
                ? getMachineForecastValue(iso, selectedMachineCode)
                : 0;
            const forecastHours = hasSelection
                ? getMachineForecastHours(iso, selectedMachineCode)
                : 0;
            const forecastAverage = hasSelection
                ? getMachineAverageHourlyProduction(iso, selectedMachineCode)
                : 0;

            if (forecastHoursInput) {
                if (!hasSelection) {
                    forecastHoursInput.value = "";
                } else {
                    forecastHoursInput.value = formatQuantity(forecastHours || 0);
                }
            }

            if (forecastAverageInput) {
                if (!hasSelection) {
                    forecastAverageInput.value = "";
                } else {
                    forecastAverageInput.value = formatQuantity(forecastAverage || 0);
                }
            }

            if (forecastQtyInput) {
                if (!hasSelection) {
                    forecastQtyInput.value = "";
                } else {
                    forecastQtyInput.value = formatQuantity(forecastValue || 0);
                }
            }

            if (hasSelection) {
                updateComputedForecastQuantity();
            }

            if (forecastHolidayNote) {
                const holidayName = getHolidayForDate(iso);
                if (holidayName) {
                    forecastHolidayNote.hidden = false;
                    forecastHolidayNote.textContent = `${holidayName} · Sri Lanka holiday`;
                } else {
                    forecastHolidayNote.hidden = true;
                    forecastHolidayNote.textContent = "";
                }
            }

            if (forecastCalendarBody) {
                const buttons = forecastCalendarBody.querySelectorAll(".forecast-calendar__day");
                buttons.forEach((button) => {
                    if (button.dataset.date === iso) {
                        button.classList.add("forecast-calendar__day--selected");
                        button.setAttribute("aria-pressed", "true");
                    } else {
                        button.classList.remove("forecast-calendar__day--selected");
                        button.setAttribute("aria-pressed", "false");
                    }
                });
            }

            ensureForecastFormState();
        }

        function renderForecastCalendar() {
            if (!forecastCalendarBody) {
                return;
            }

            const machineCodes = getActiveMachineCodes();
            if (machineCodes.length === 0) {
                renderForecastEmptyState("Add a machine to begin forecasting.");
                return;
            }

            forecastCalendarBody.innerHTML = "";

            const year = forecastState.anchorDate.getFullYear();
            const month = forecastState.anchorDate.getMonth();
            const monthDays = new Date(year, month + 1, 0).getDate();
            const firstDay = new Date(year, month, 1);
            const firstWeekday = (firstDay.getDay() + 6) % 7; // Monday as first column

            let dayCounter = 1 - firstWeekday;

            for (let week = 0; week < 6; week += 1) {
                const tr = document.createElement("tr");
                tr.className = "forecast-calendar__row";

                for (let weekday = 0; weekday < 7; weekday += 1, dayCounter += 1) {
                    const td = document.createElement("td");
                    td.className = "forecast-calendar__cell";

                    if (dayCounter < 1 || dayCounter > monthDays) {
                        td.classList.add("forecast-calendar__cell--muted");
                        tr.appendChild(td);
                        continue;
                    }

                    const currentDate = new Date(year, month, dayCounter);
                    const iso = formatDateISO(currentDate);

                    const entry = ensureForecastEntry(iso);
                    updateEntryTotal(entry, machineCodes);

                    const button = document.createElement("button");
                    button.type = "button";
                    button.className = "forecast-calendar__day";
                    button.dataset.date = iso;

                    const dateLabel = currentDate.toLocaleDateString(undefined, {
                        weekday: "long",
                        month: "long",
                        day: "numeric",
                    });
                    const machineSummaries = machineCodes.map((code) => {
                        const value = Number(entry?.machines?.[code] ?? 0);
                        return `${code} ${formatQuantity(value)} tons`;
                    });
                    const summaryText = machineSummaries.join(", ");
                    const ariaLabel = `${dateLabel} forecast ${
                        summaryText ? `${summaryText}, ` : ""
                    }total ${formatQuantity(entry?.total ?? 0)} tons`;
                    button.setAttribute("aria-label", ariaLabel);
                    button.setAttribute("aria-pressed", "false");

                    const weekdayValue = currentDate.getDay();
                    if (weekdayValue === 0 || weekdayValue === 6) {
                        button.classList.add("forecast-calendar__day--weekend");
                    }

                    const holidayName = getHolidayForDate(iso);
                    if (holidayName) {
                        button.classList.add("forecast-calendar__day--holiday");
                        button.title = `${holidayName} (Sri Lanka holiday)`;
                    }

                    const dayNumber = document.createElement("span");
                    dayNumber.className = "forecast-calendar__date";
                    dayNumber.textContent = String(dayCounter);
                    button.appendChild(dayNumber);

                    const entriesContainer = document.createElement("div");
                    entriesContainer.className = "forecast-calendar__entries";

                    machineCodes.forEach((code) => {
                        const entryRow = document.createElement("div");
                        entryRow.className = "forecast-calendar__entry";

                        const labelSpan = document.createElement("span");
                        labelSpan.className = "forecast-calendar__entry-label";
                        labelSpan.textContent = code;
                        entryRow.appendChild(labelSpan);

                        const valueSpan = document.createElement("span");
                        const machineClass = normalizeMachineCodeForClass(code);
                        valueSpan.className = `forecast-calendar__entry-value forecast-calendar__entry-value--machine-${machineClass}`;
                        const rawValue = Number(entry?.machines?.[code] ?? 0);
                        valueSpan.textContent = `${formatQuantity(rawValue)} Ton`;
                        entryRow.appendChild(valueSpan);

                        entriesContainer.appendChild(entryRow);
                    });

                    const totalRow = document.createElement("div");
                    totalRow.className = "forecast-calendar__entry forecast-calendar__entry--total";

                    const totalLabel = document.createElement("span");
                    totalLabel.className = "forecast-calendar__entry-label forecast-calendar__entry-label--total";
                    totalLabel.textContent = "Total";
                    totalRow.appendChild(totalLabel);

                    const totalValue = document.createElement("span");
                    totalValue.className = "forecast-calendar__entry-value forecast-calendar__entry-value--total";
                    totalValue.textContent = `${formatQuantity(entry?.total ?? 0)} Ton`;
                    totalRow.appendChild(totalValue);

                    entriesContainer.appendChild(totalRow);

                    button.appendChild(entriesContainer);

                    if (holidayName) {
                        const holidayBadge = document.createElement("span");
                        holidayBadge.className = "forecast-calendar__holiday";
                        holidayBadge.textContent = holidayName;
                        button.appendChild(holidayBadge);
                    }

                    td.appendChild(button);
                    tr.appendChild(td);
                }

                forecastCalendarBody.appendChild(tr);
            }

            updateForecastSelectionUI();
        }

        function setSelectedForecastDate(dateIso) {
            if (!dateIso) {
                return;
            }
            const candidate = parseISODate(dateIso);
            if (!(candidate instanceof Date) || Number.isNaN(candidate.valueOf())) {
                return;
            }
            forecastState.selectedDate = candidate;
            forecastState.preferredDay = candidate.getDate();
            updateForecastSelectionUI();
        }

        const totalsTodayTotal = document.getElementById("production-today-total");
        const totalsMtdTotal = document.getElementById("production-mtd-total");
        const totalsTodayMachineElements = {};
        const totalsMtdMachineElements = {};

        SUMMARY_MACHINE_CODES.forEach((code) => {
            const normalized = code.toLowerCase();
            totalsTodayMachineElements[code] = document.getElementById(
                `production-today-${normalized}`,
            );
            totalsMtdMachineElements[code] = document.getElementById(
                `production-mtd-${normalized}`,
            );
        });

        let latestSummary = null;

        const idleSummaryTargetHours = document.getElementById("idle-summary-target-hours");
        const idleSummaryPeriodElement = document.getElementById("idle-summary-period");
        const idleSummaryBody = document.getElementById("idle-summary-body");
        const idleSummaryEmptyRow = document.getElementById("idle-summary-empty");
        const idleSummaryHeadRow = document.getElementById("idle-summary-head-row");
        const idleSummaryTotalsRow = document.getElementById("idle-summary-totals-row");
        const idleSummaryError = document.getElementById("idle-summary-error");
        const idleSummaryTotals = new Map();

        function formatQuantity(value) {
            const number = Number(value);
            return Number.isFinite(number) ? number.toFixed(2) : "0.00";
        }

        function parseNumberInputValue(input) {
            if (!input) {
                return null;
            }
            const rawValue = String(input.value ?? "").trim();
            if (rawValue.length === 0) {
                return null;
            }
            const number = Number(rawValue);
            return Number.isFinite(number) ? number : null;
        }

        function updateComputedForecastQuantity() {
            if (!forecastQtyInput) {
                return;
            }

            const hoursValue = parseNumberInputValue(forecastHoursInput);
            const averageValue = parseNumberInputValue(forecastAverageInput);

            if (hoursValue === null || averageValue === null) {
                forecastQtyInput.value = "";
                return;
            }

            const quantity = hoursValue * averageValue;
            if (Number.isFinite(quantity)) {
                forecastQtyInput.value = formatQuantity(quantity);
            }
        }

        function sumMachineTotals(machines) {
            if (!machines || typeof machines !== "object") {
                return 0;
            }

            return SUMMARY_MACHINE_CODES.reduce((accumulator, code) => {
                const value = Number(machines?.[code] ?? 0);
                return Number.isFinite(value) ? accumulator + value : accumulator;
            }, 0);
        }

        function updateTotalElement(element, value) {
            if (!element) return;
            const number = Number(value ?? 0);
            element.textContent = formatQuantity(number);
        }

        function sanitizeIdleMachineCodes(codes) {
            if (!Array.isArray(codes)) {
                return [];
            }
            const seen = new Set();
            const sanitized = [];
            codes.forEach((code) => {
                if (typeof code !== "string") {
                    return;
                }
                const trimmed = code.trim();
                if (!trimmed) {
                    return;
                }
                const upper = trimmed.toUpperCase();
                const key = upper.toLowerCase();
                if (seen.has(key)) {
                    return;
                }
                seen.add(key);
                sanitized.push(upper);
            });
            return sanitized;
        }

        function ensureIdleSummaryColumns(machineCodes) {
            const sanitized = sanitizeIdleMachineCodes(machineCodes);
            const finalCodes =
                sanitized.length > 0
                    ? sanitized
                    : DEFAULT_IDLE_SUMMARY_MACHINE_CODES.slice();

            idleSummaryMachineCodes = finalCodes;
            idleSummaryTotals.clear();

            if (idleSummaryHeadRow) {
                while (idleSummaryHeadRow.children.length > 1) {
                    idleSummaryHeadRow.removeChild(idleSummaryHeadRow.lastElementChild);
                }
                finalCodes.forEach((code) => {
                    const th = document.createElement("th");
                    th.scope = "col";
                    th.textContent = code;
                    idleSummaryHeadRow.appendChild(th);
                });
            }

            if (idleSummaryTotalsRow) {
                while (idleSummaryTotalsRow.children.length > 1) {
                    idleSummaryTotalsRow.removeChild(
                        idleSummaryTotalsRow.lastElementChild,
                    );
                }
                finalCodes.forEach((code) => {
                    const td = document.createElement("td");
                    td.dataset.machineCode = code;
                    td.textContent = "0.00";
                    idleSummaryTotalsRow.appendChild(td);
                    idleSummaryTotals.set(code, td);
                });
            }

            if (idleSummaryEmptyRow) {
                const emptyCell = idleSummaryEmptyRow.querySelector("td");
                if (emptyCell) {
                    emptyCell.colSpan = finalCodes.length + 1;
                }
            }
        }

        function renderTotals(data) {
            const totals = data?.totals || {};
            const todayTotals = totals.today || {};
            const mtdTotals = totals.mtd || {};
            const todayMachines = todayTotals.machines || {};
            const mtdMachines = mtdTotals.machines || {};

            SUMMARY_MACHINE_CODES.forEach((code) => {
                updateTotalElement(
                    totalsTodayMachineElements[code],
                    todayMachines[code],
                );
                updateTotalElement(
                    totalsMtdMachineElements[code],
                    mtdMachines[code],
                );
            });

            const todayTotal = sumMachineTotals(todayMachines);
            const mtdTotal = sumMachineTotals(mtdMachines);

            updateTotalElement(totalsTodayTotal, todayTotal);
            updateTotalElement(totalsMtdTotal, mtdTotal);
        }

        function updateIdleSummaryTotals(totals) {
            idleSummaryMachineCodes.forEach((code) => {
                const element = idleSummaryTotals.get(code);
                if (!element) {
                    return;
                }
                const value = Number(totals?.[code]?.idle_hours ?? 0);
                element.textContent = formatQuantity(value);
                if (value > 0.01) {
                    element.classList.add("idle-summary__value--alert");
                } else {
                    element.classList.remove("idle-summary__value--alert");
                }
            });
        }

        function renderIdleSummary(data) {
            ensureIdleSummaryColumns(data?.machine_codes);
            if (idleSummaryTargetHours) {
                const target = Number(
                    data?.scheduled_hours_per_day ?? IDLE_SCHEDULED_HOURS_PER_DAY,
                );
                idleSummaryTargetHours.textContent = formatQuantity(target);
            }

            if (idleSummaryPeriodElement) {
                idleSummaryPeriodElement.textContent = data?.label || "—";
            }

            if (idleSummaryError) {
                idleSummaryError.hidden = true;
                idleSummaryError.textContent = "";
            }

            updateIdleSummaryTotals(data?.totals || {});

            if (!idleSummaryBody) {
                return;
            }

            idleSummaryBody.innerHTML = "";

            if (idleSummaryEmptyRow) {
                idleSummaryEmptyRow.hidden = true;
            }

            const days = Array.isArray(data?.day_entries) ? data.day_entries : [];
            if (days.length === 0) {
                if (idleSummaryEmptyRow) {
                    const cell = idleSummaryEmptyRow.querySelector("td");
                    if (cell) {
                        cell.textContent = "No idle time recorded for this month.";
                    }
                    idleSummaryEmptyRow.hidden = false;
                    idleSummaryBody.appendChild(idleSummaryEmptyRow);
                }
                return;
            }

            days.forEach((dayEntry) => {
                const row = document.createElement("tr");
                row.className = "idle-summary__row";
                if (dayEntry?.date) {
                    row.dataset.date = dayEntry.date;
                }

                const dayCell = document.createElement("th");
                dayCell.scope = "row";
                dayCell.textContent = String(dayEntry?.day ?? "");
                row.appendChild(dayCell);

                idleSummaryMachineCodes.forEach((code) => {
                    const machineData = dayEntry?.machines?.[code];
                    const idleHours = Number(machineData?.idle_hours ?? 0);
                    const runtimeHours = Number(
                        machineData?.runtime_hours ?? IDLE_SCHEDULED_HOURS_PER_DAY,
                    );

                    const cell = document.createElement("td");
                    cell.textContent = formatQuantity(idleHours);
                    if (idleHours > 0.01) {
                        cell.classList.add("idle-summary__value--alert");
                    }
                    cell.title = `Idle ${formatQuantity(idleHours)} hrs • Runtime ${formatQuantity(runtimeHours)} hrs`;
                    row.appendChild(cell);
                });

                idleSummaryBody.appendChild(row);
            });
        }

        function renderSummary(data) {
            productionTableBody.innerHTML = "";
            productionEmptyRow.hidden = true;
            const emptyCell = productionEmptyRow.querySelector("td");
            if (emptyCell) {
                emptyCell.textContent = "No production records are available for this date.";
            }

            const hoursMap = new Map();
            if (data && Array.isArray(data.hours)) {
                data.hours.forEach((hour) => {
                    const hourNumber = Number(hour?.hour_no);
                    if (Number.isFinite(hourNumber)) {
                        hoursMap.set(hourNumber, hour);
                    }
                });
            }

            let fallbackSummaryTotal = 0;

            for (let hour = 1; hour <= 24; hour += 1) {
                const hourData = hoursMap.get(hour) || {};
                const machinesMap = hourData.machines || {};

                const tr = document.createElement("tr");
                tr.dataset.hour = String(hour);

                const hourCell = document.createElement("th");
                hourCell.scope = "row";
                hourCell.textContent = HOUR_LABELS[hour] || String(hour).padStart(2, "0");
                tr.appendChild(hourCell);

                SUMMARY_MACHINE_CODES.forEach((code) => {
                    const machineCell = document.createElement("td");
                    machineCell.dataset.machineCode = code;
                    const machineData = machinesMap[code];
                    const quantity = Number(machineData?.quantity_tons ?? 0);
                    machineCell.textContent = formatQuantity(quantity);
                    machineCell.dataset.quantity = Number.isFinite(quantity) ? quantity : 0;
                    if (Number.isFinite(quantity)) {
                        fallbackSummaryTotal += quantity;
                    }
                    tr.appendChild(machineCell);
                });

                const totalCell = document.createElement("td");
                const hourTotal = Number(hourData.hour_total_tons ?? 0);
                totalCell.textContent = formatQuantity(hourTotal);
                tr.appendChild(totalCell);

                SUMMARY_EXTRA_MACHINE_CODES.forEach((code) => {
                    const machineCell = document.createElement("td");
                    machineCell.dataset.machineCode = code;
                    const machineData = machinesMap[code];
                    const quantity = Number(machineData?.quantity_tons ?? 0);
                    machineCell.textContent = formatQuantity(quantity);
                    machineCell.dataset.quantity = Number.isFinite(quantity) ? quantity : 0;
                    tr.appendChild(machineCell);
                });

                const updatedCell = document.createElement("td");
                const updatedValue = hourData.last_updated;
                if (updatedValue) {
                    const updatedDate = new Date(updatedValue);
                    if (!Number.isNaN(updatedDate.valueOf())) {
                        updatedCell.textContent = updatedDate.toLocaleTimeString("en-LK", {
                            hour: "2-digit",
                            minute: "2-digit",
                            hour12: true,
                            timeZone: "Asia/Colombo",
                        });
                    } else {
                        updatedCell.textContent = "—";
                    }
                } else {
                    updatedCell.textContent = "—";
                }
                tr.appendChild(updatedCell);

                productionTableBody.appendChild(tr);
            }

            const todayMachinesTotals = data?.totals?.today?.machines || {};
            const hasTodayTotals =
                todayMachinesTotals &&
                typeof todayMachinesTotals === "object" &&
                Object.keys(todayMachinesTotals).length > 0;

            const summaryTotal = hasTodayTotals
                ? sumMachineTotals(todayMachinesTotals)
                : fallbackSummaryTotal;

            productionTotal.textContent = formatQuantity(summaryTotal);
            renderTotals(data);
        }

        function updateQuantityFieldFromSummary() {
            const machineCode = machineSelect.value;
            const hourValue = Number(hourSelect.value);

            if (!machineCode || !Number.isFinite(hourValue)) {
                quantityInput.value = "";
                return;
            }

            if (!latestSummary || !Array.isArray(latestSummary.hours)) {
                quantityInput.value = formatQuantity(0);
                return;
            }

            const hourData = latestSummary.hours.find(
                (hour) => Number(hour?.hour_no) === hourValue,
            );
            const machineData = hourData?.machines?.[machineCode];
            const quantity = Number(machineData?.quantity_tons ?? 0);
            quantityInput.value = formatQuantity(quantity);
        }

        async function loadIdleSummary() {
            if (!idleSummaryBody) {
                return;
            }

            if (idleSummaryError) {
                idleSummaryError.hidden = true;
                idleSummaryError.textContent = "";
            }

            if (idleSummaryBody && idleSummaryEmptyRow) {
                idleSummaryBody.innerHTML = "";
                idleSummaryEmptyRow.hidden = false;
                const cell = idleSummaryEmptyRow.querySelector("td");
                if (cell) {
                    cell.textContent = "Loading idle hours…";
                }
                idleSummaryBody.appendChild(idleSummaryEmptyRow);
            }

            const params = new URLSearchParams();
            const period = formatPeriodFromDate(forecastState.anchorDate);
            if (period) {
                params.set("period", period);
            }
            if (idleSummaryMachineCodes.length > 0) {
                params.set("machine_codes", idleSummaryMachineCodes.join(","));
            }

            params.set("shape", "ui");

            try {
                const response = await fetch(
                    `/api/production/monthly/idle-summary?${params.toString()}`,
                    {
                        headers: authHeaders,
                    },
                );
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Unable to load idle summary.");
                }

                const data = await response.json();
                renderIdleSummary(data);
            } catch (error) {
                updateIdleSummaryTotals({});
                if (idleSummaryTargetHours) {
                    idleSummaryTargetHours.textContent = formatQuantity(
                        IDLE_SCHEDULED_HOURS_PER_DAY,
                    );
                }
                if (idleSummaryPeriodElement) {
                    idleSummaryPeriodElement.textContent = "—";
                }
                if (idleSummaryBody && idleSummaryEmptyRow) {
                    idleSummaryBody.innerHTML = "";
                    idleSummaryEmptyRow.hidden = false;
                    const cell = idleSummaryEmptyRow.querySelector("td");
                    if (cell) {
                        cell.textContent = "Idle summary unavailable.";
                    }
                    idleSummaryBody.appendChild(idleSummaryEmptyRow);
                }
                if (idleSummaryError) {
                    idleSummaryError.hidden = false;
                    idleSummaryError.textContent = error.message || "Unable to load idle summary.";
                }
            }
        }

        async function loadProductionSummary() {
            showMessage(productionError);

            const params = new URLSearchParams();
            if (dateInput.value) {
                params.set("date", dateInput.value);
            }
            if (SUMMARY_ALL_MACHINE_CODES.length > 0) {
                params.set("machine_codes", SUMMARY_ALL_MACHINE_CODES.join(","));
            }

            try {
                const response = await fetch(`/api/production/daily/summary?${params.toString()}`, {
                    headers: authHeaders,
                });
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Failed to load production summary.");
                }

                const data = await response.json();
                latestSummary = data;
                renderSummary(data);
                updateQuantityFieldFromSummary();
            } catch (error) {
                latestSummary = null;
                productionTotal.textContent = "0.00";
                productionTableBody.innerHTML = "";
                productionEmptyRow.hidden = false;
                const emptyCell = productionEmptyRow.querySelector("td");
                if (emptyCell) {
                    emptyCell.textContent = "Unable to load production summary.";
                }
                productionTableBody.appendChild(productionEmptyRow);
                renderTotals(null);
                showMessage(
                    productionError,
                    error.message || "Unable to load production summary.",
                );
            }
        }

        function populateProductionMachineSelect(machines) {
            machineSelect.innerHTML = "";
            if (!Array.isArray(machines) || machines.length === 0) {
                const option = document.createElement("option");
                option.textContent = "No machines available";
                option.value = "";
                machineSelect.appendChild(option);
                machineSelect.disabled = true;
                return;
            }

            machines.forEach((machine, index) => {
                const option = document.createElement("option");
                option.value = machine.code;
                option.textContent = `${machine.code} — ${machine.name}`;
                if (index === 0) {
                    option.selected = true;
                }
                machineSelect.appendChild(option);
            });
            machineSelect.disabled = false;
        }

        function populateForecastMachineSelect(machines) {
            if (!forecastMachineSelect) {
                return;
            }

            const previousSelection = forecastMachineSelect.value;
            forecastMachineSelect.innerHTML = "";

            if (!Array.isArray(machines) || machines.length === 0) {
                const option = document.createElement("option");
                option.textContent = "No machines available";
                option.value = "";
                forecastMachineSelect.appendChild(option);
                forecastMachineSelect.disabled = true;
                forecastState.machineCode = "";
                ensureForecastNavState();
                ensureForecastFormState();
                renderForecastEmptyState("Add a machine to begin forecasting.");
                forecastState.entries = new Map();
                forecastState.total = 0;
                forecastState.overview = createEmptyForecastOverview();
                updateForecastTotalElement();
                return;
            }

            let selection = previousSelection;
            const options = machines.map((machine) => {
                const option = document.createElement("option");
                option.value = machine.code;
                option.textContent = `${machine.code} — ${machine.name}`;
                return option;
            });

            options.forEach((option) => {
                forecastMachineSelect.appendChild(option);
            });

            if (!selection || !machines.some((machine) => machine.code === selection)) {
                selection = machines[0]?.code || "";
            }

            forecastMachineSelect.value = selection || "";
            forecastMachineSelect.disabled = false;
            forecastState.machineCode = selection || "";
            ensureForecastNavState();
            ensureForecastFormState();
        }

        async function fetchMachines() {
            try {
                const response = await fetch("/api/machines/assets", { headers: authHeaders });
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Failed to load machines");
                }

                const machines = await response.json();
                machinesCache = Array.isArray(machines) ? machines : [];
                ensureIdleSummaryColumns(getActiveMachineCodes());
                populateProductionMachineSelect(machinesCache);
                populateForecastMachineSelect(machinesCache);
                await loadProductionSummary();
                await loadForecastData();
            } catch (error) {
                renderTotals(null);
                showMessage(productionError, error.message || "Unable to load machines");
                populateForecastMachineSelect([]);
                ensureIdleSummaryColumns([]);
            }
        }

        async function loadForecastData() {
            updateForecastMonthLabel();
            ensureForecastNavState();
            loadIdleSummary();

            const machineCodes = getActiveMachineCodes();
            if (machineCodes.length === 0) {
                forecastState.entries = new Map();
                forecastState.total = 0;
                forecastState.selectedDate = null;
                forecastState.overview = createEmptyForecastOverview();
                updateForecastTotalElement();
                renderForecastEmptyState("Add a machine to begin forecasting.");
                ensureForecastFormState();
                return;
            }

            const year = forecastState.anchorDate.getFullYear();
            await ensureHolidaysForYear(year);

            const period = `${forecastState.anchorDate.getFullYear()}-${String(
                forecastState.anchorDate.getMonth() + 1,
            ).padStart(2, "0")}`;
            const monthDays = new Date(year, forecastState.anchorDate.getMonth() + 1, 0).getDate();

            try {
                const entriesMap = new Map();

                for (const code of machineCodes) {
                    const params = new URLSearchParams();
                    params.set("period", period);
                    params.set("machine_code", code);

                    const response = await fetch(
                        `/api/production/forecast?${params.toString()}`,
                        {
                            headers: authHeaders,
                        },
                    );
                    if (response.status === 401) {
                        logoutButton.click();
                        return;
                    }
                    if (!response.ok) {
                        throw new Error("Unable to load production forecast.");
                    }

                    const data = await response.json();
                    const entriesList = Array.isArray(data?.entries) ? data.entries : [];
                    entriesList.forEach((entry) => {
                        if (!entry || !entry.date) {
                            return;
                        }
                        const value = Number(entry.forecast_tons ?? 0);
                        const normalized = Number.isFinite(value)
                            ? Number(value.toFixed(3))
                            : 0;
                        const hoursValue = Number(entry.forecast_hours ?? 0);
                        const normalizedHours = Number.isFinite(hoursValue)
                            ? Number(hoursValue.toFixed(3))
                            : 0;
                        const averageValue = Number(
                            entry.average_hourly_production ?? 0,
                        );
                        const normalizedAverage = Number.isFinite(averageValue)
                            ? Number(averageValue.toFixed(3))
                            : 0;

                        let target = entriesMap.get(entry.date);
                        if (!target) {
                            target = {
                                machines: {},
                                hours: {},
                                averageHourlyProduction: {},
                                total: 0,
                            };
                            entriesMap.set(entry.date, target);
                        } else {
                            target.machines = target.machines || {};
                            target.hours = target.hours || {};
                            target.averageHourlyProduction =
                                target.averageHourlyProduction || {};
                        }
                        target.machines[code] = normalized;
                        target.hours[code] = normalizedHours;
                        target.averageHourlyProduction[code] = normalizedAverage;
                    });
                }

                for (let day = 1; day <= monthDays; day += 1) {
                    const iso = formatDateISO(
                        new Date(
                            forecastState.anchorDate.getFullYear(),
                            forecastState.anchorDate.getMonth(),
                            day,
                        ),
                    );
                    let target = entriesMap.get(iso);
                    if (!target) {
                        target = {
                            machines: {},
                            hours: {},
                            averageHourlyProduction: {},
                            total: 0,
                        };
                        entriesMap.set(iso, target);
                    } else {
                        target.machines = target.machines || {};
                        target.hours = target.hours || {};
                        target.averageHourlyProduction =
                            target.averageHourlyProduction || {};
                    }
                    updateEntryTotal(target, machineCodes);
                }

                forecastState.entries = entriesMap;
                recalculateForecastTotal();
                ensureSelectedDateInAnchorMonth();
                renderForecastCalendar();
                updateForecastTotalElement();
                ensureForecastFormState();
            } catch (error) {
                forecastState.entries = new Map();
                forecastState.total = 0;
                forecastState.selectedDate = null;
                forecastState.overview = createEmptyForecastOverview();
                renderForecastEmptyState(error.message || "Unable to load production forecast.");
                updateForecastTotalElement();
                ensureForecastFormState();
                showMessage(
                    forecastError,
                    error.message || "Unable to load production forecast.",
                );
            }
        }

        function changeForecastMonth(step) {
            if (!Number.isFinite(step) || step === 0) {
                return;
            }
            const anchor = forecastState.anchorDate;
            forecastState.anchorDate = new Date(
                anchor.getFullYear(),
                anchor.getMonth() + step,
                1,
            );
            ensureSelectedDateInAnchorMonth();
            clearForecastFeedback();
            loadForecastData();
        }

        productionForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            clearFeedback();

            const machineCode = machineSelect.value;
            const dateValue = dateInput.value;
            const hourValue = hourSelect.value;
            const quantityValue = quantityInput.value;

            if (!machineCode || !dateValue || !hourValue) {
                showMessage(productionError, "Please complete all required fields.");
                return;
            }

            const hourNumber = Number(hourValue);
            if (Number.isFinite(hourNumber)) {
                try {
                    const conflict = await findIdleConflictForProduction(
                        machineCode,
                        dateValue,
                        hourNumber,
                    );
                    if (conflict) {
                        const message = formatConflictMessage(
                            conflict,
                            "Selected production hour overlaps with logged idle time.",
                            { referenceDate: dateValue },
                        );
                        showMessage(productionError, message);
                        return;
                    }
                } catch (precheckError) {
                    console.warn("Production idle pre-check failed", precheckError);
                }
            }

            setFormDisabled(true);

            try {
                const response = await fetch("/api/production/daily", {
                    method: "POST",
                    headers: {
                        ...authHeaders,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        machine_code: machineCode,
                        date: dateValue,
                        hour_no: Number(hourValue),
                        quantity_tons: quantityValue ? Number(quantityValue) : 0,
                    }),
                });

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                const payload = await response.json().catch(() => ({}));

                if (!response.ok) {
                    let message = payload?.msg || "Unable to save production.";
                    if (response.status === 409 && payload?.conflict) {
                        message = formatConflictMessage(payload.conflict, message, {
                            referenceDate: dateValue,
                        });
                    }
                    showMessage(productionError, message);
                    return;
                }

                showMessage(productionSuccess, "Production updated successfully.");
                await loadProductionSummary();
            } catch (error) {
                showMessage(productionError, error.message || "Unable to save production.");
            } finally {
                setFormDisabled(false);
            }
        });

        if (forecastForm) {
            forecastForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                clearForecastFeedback();

                const machineCode = forecastState.machineCode;
                const dateValue = forecastDateInput?.value;

                if (!machineCode || !dateValue) {
                    showMessage(
                        forecastError,
                        "Select a machine and day before saving a forecast.",
                    );
                    return;
                }

                const hoursValue = parseNumberInputValue(forecastHoursInput);
                if (hoursValue === null) {
                    showMessage(
                        forecastError,
                        "Enter forecasted production hours.",
                    );
                    return;
                }

                if (hoursValue < 0) {
                    showMessage(
                        forecastError,
                        "Forecasted production hours cannot be negative.",
                    );
                    return;
                }

                const averageValue = parseNumberInputValue(forecastAverageInput);
                if (averageValue === null) {
                    showMessage(
                        forecastError,
                        "Enter average hourly production.",
                    );
                    return;
                }

                if (averageValue < 0) {
                    showMessage(
                        forecastError,
                        "Average hourly production cannot be negative.",
                    );
                    return;
                }

                const computedForecast = hoursValue * averageValue;
                if (!Number.isFinite(computedForecast)) {
                    showMessage(
                        forecastError,
                        "Enter valid numbers for hours and production.",
                    );
                    return;
                }

                const normalizedHours = Number(hoursValue.toFixed(3));
                const normalizedAverage = Number(averageValue.toFixed(3));
                const normalizedForecast = Number(computedForecast.toFixed(3));

                if (forecastQtyInput) {
                    forecastQtyInput.value = formatQuantity(normalizedForecast);
                }

                setForecastFormDisabled(true);

                try {
                    const response = await fetch("/api/production/forecast", {
                        method: "POST",
                        headers: {
                            ...authHeaders,
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            machine_code: machineCode,
                            date: dateValue,
                            forecast_hours: normalizedHours,
                            average_hourly_production: normalizedAverage,
                            forecast_tons: normalizedForecast,
                        }),
                    });

                    if (response.status === 401) {
                        logoutButton.click();
                        return;
                    }

                    const payload = await response.json().catch(() => ({}));
                    if (!response.ok) {
                        const message = payload?.msg || "Unable to save forecast.";
                        showMessage(forecastError, message);
                        return;
                    }

                    const savedValue = Number(
                        payload?.forecast_tons ?? normalizedForecast,
                    );
                    const savedHoursValue = Number(
                        payload?.forecast_hours ?? normalizedHours,
                    );
                    const savedAverageValue = Number(
                        payload?.average_hourly_production ?? normalizedAverage,
                    );

                    if (Number.isFinite(savedValue)) {
                        const normalizedQuantity = Number(savedValue.toFixed(3));
                        const normalizedSavedHours = Number.isFinite(savedHoursValue)
                            ? Number(savedHoursValue.toFixed(3))
                            : 0;
                        const normalizedSavedAverage = Number.isFinite(
                            savedAverageValue,
                        )
                            ? Number(savedAverageValue.toFixed(3))
                            : 0;

                        const entry = ensureForecastEntry(dateValue);
                        if (entry) {
                            entry.machines = entry.machines || {};
                            entry.hours = entry.hours || {};
                            entry.averageHourlyProduction =
                                entry.averageHourlyProduction || {};
                            entry.machines[machineCode] = normalizedQuantity;
                            entry.hours[machineCode] = normalizedSavedHours;
                            entry.averageHourlyProduction[machineCode] =
                                normalizedSavedAverage;
                            updateEntryTotal(entry);
                        }
                        recalculateForecastTotal();
                        updateForecastTotalElement();
                    }

                    showMessage(forecastSuccess, "Forecast updated successfully.");
                    renderForecastCalendar();
                } catch (error) {
                    showMessage(forecastError, error.message || "Unable to save forecast.");
                } finally {
                    setForecastFormDisabled(false);
                    ensureForecastFormState();
                }
            });
        }

        if (forecastHoursInput) {
            forecastHoursInput.addEventListener("input", () => {
                clearForecastFeedback();
                updateComputedForecastQuantity();
            });
        }

        if (forecastAverageInput) {
            forecastAverageInput.addEventListener("input", () => {
                clearForecastFeedback();
                updateComputedForecastQuantity();
            });
        }

        machineSelect.addEventListener("change", () => {
            clearFeedback();
            updateQuantityFieldFromSummary();
        });

        hourSelect.addEventListener("change", () => {
            clearFeedback();
            updateQuantityFieldFromSummary();
        });

        dateInput.addEventListener("change", () => {
            clearFeedback();
            loadProductionSummary();
        });

        productionTableBody.addEventListener("click", (event) => {
            const machineCell = event.target.closest("td[data-machine-code]");
            if (machineCell) {
                const row = machineCell.closest("tr[data-hour]");
                if (row?.dataset.hour) {
                    hourSelect.value = String(Number(row.dataset.hour));
                }

                const machineCode = machineCell.dataset.machineCode;
                const option = Array.from(machineSelect.options).find(
                    (opt) => opt.value === machineCode,
                );
                if (option) {
                    machineSelect.value = machineCode;
                }

                const qty = Number(machineCell.dataset.quantity ?? 0);
                quantityInput.value = formatQuantity(qty);
                clearFeedback();
                return;
            }

            const row = event.target.closest("tr[data-hour]");
            if (!row || !row.dataset.hour) {
                return;
            }

            hourSelect.value = String(Number(row.dataset.hour));
            updateQuantityFieldFromSummary();
            clearFeedback();
        });

        if (forecastMachineSelect) {
            forecastMachineSelect.addEventListener("change", () => {
                clearForecastFeedback();
                forecastState.machineCode = forecastMachineSelect.value || "";
                ensureSelectedDateInAnchorMonth();
                loadForecastData();
            });
        }

        if (forecastPrevMonth) {
            forecastPrevMonth.addEventListener("click", () => {
                changeForecastMonth(-1);
            });
        }

        if (forecastNextMonth) {
            forecastNextMonth.addEventListener("click", () => {
                changeForecastMonth(1);
            });
        }

        if (forecastCalendarBody) {
            forecastCalendarBody.addEventListener("click", (event) => {
                const button = event.target.closest(".forecast-calendar__day");
                if (!button || !button.dataset.date) {
                    return;
                }
                event.preventDefault();
                clearForecastFeedback();
                setSelectedForecastDate(button.dataset.date);
            });

            forecastCalendarBody.addEventListener("keydown", (event) => {
                if (event.key !== "Enter" && event.key !== " ") {
                    return;
                }
                const button = event.target.closest(".forecast-calendar__day");
                if (!button || !button.dataset.date) {
                    return;
                }
                event.preventDefault();
                clearForecastFeedback();
                setSelectedForecastDate(button.dataset.date);
            });
        }

        ensureIdleSummaryColumns(idleSummaryMachineCodes);
        updateForecastMonthLabel();
        updateForecastTotalElement();
        renderForecastEmptyState("Select a machine to manage forecasts.");
        fetchMachines();
    </script>
</body>
</html>
