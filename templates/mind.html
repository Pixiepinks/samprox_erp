<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mind | SAMPROX ERP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}" />
</head>
<body>
    <div class="page">
        <header class="topbar">
            <div class="brand">
                <div class="brand__logo">S</div>
                <div class="brand__details">
                    <p class="brand__name">SAMPROX ERP</p>
                    <p class="brand__section">7M Operations Overview</p>
                </div>
            </div>
            <div class="topbar__actions">
                <div class="user-summary">
                    <span class="user-summary__name" id="user-name"></span>
                    <span class="user-summary__role" id="user-role"></span>
                </div>
                <button type="button" class="button button--secondary" id="logout">Sign out</button>
            </div>
        </header>
        <nav class="subnav" aria-label="7M navigation">
            <a class="subnav__link subnav__link--active" href="{{ url_for('ui.mind_page') }}">Mind</a>
            <a class="subnav__link" href="{{ url_for('ui.man_page') }}">Man</a>
            <a class="subnav__link" href="{{ url_for('ui.machines_page') }}">Machine</a>
            <a class="subnav__link" href="{{ url_for('ui.material_page') }}">Material</a>
            <a class="subnav__link" href="{{ url_for('ui.market_page') }}">Market</a>
            <a class="subnav__link" href="{{ url_for('ui.manufacturing_page') }}">Manufacturing</a>
            <a class="subnav__link" href="{{ url_for('ui.money_page') }}">Money</a>
            <a
                class="subnav__link"
                href="{{ url_for('ui.mechanism_page') }}"
                id="mechanism-link"
                hidden
            >Mechanism</a>
        </nav>
        <section class="section">
            <div class="system-status system-status--full" aria-live="polite">
                <div class="system-status__header">
                    <div class="system-status__title">
                        <span class="system-status__dot" id="system-status-dot" aria-hidden="true"></span>
                        <div>
                            <p class="system-status__label">System Status</p>
                            <p class="system-status__value" id="system-status-value">Checking…</p>
                        </div>
                    </div>
                    <button type="button" class="button button--ghost system-status__refresh" id="system-status-refresh">
                        Refresh
                    </button>
                </div>
                <div class="system-status__deadline">
                    <div>
                        <p class="system-status__label">Daily deadline</p>
                        <p class="system-status__deadline-time" id="system-status-deadline">10:00 AM</p>
                    </div>
                    <p class="system-status__timestamp" id="system-status-timestamp">—</p>
                </div>
                <div class="system-status__list" id="system-status-list" role="status">
                    <p class="system-status__label">Missing updates (yesterday)</p>
                    <ul class="system-status__items" id="system-status-items"></ul>
                </div>
                <p class="system-status__footer">Keeping yesterday’s logs fresh unlocks today’s decisions.</p>
            </div>
            <div class="section__row section__row--top">
                <section class="production-chart" aria-labelledby="unit-economics-title">
                    <header class="production-chart__header">
                        <div>
                            <h2 id="unit-economics-title">Unit Variables &amp; Profitability Overview</h2>
                            <p>Average per-kg costs and contribution compared to the selling price.</p>
                        </div>
                        <div class="production-chart__controls">
                            <label class="production-chart__select" for="unit-economics-start-date">
                                <span>Start</span>
                                <input
                                    type="date"
                                    id="unit-economics-start-date"
                                    name="unit-economics-start-date"
                                />
                            </label>
                            <label class="production-chart__select" for="unit-economics-end-date">
                                <span>End</span>
                                <input
                                    type="date"
                                    id="unit-economics-end-date"
                                    name="unit-economics-end-date"
                                />
                            </label>
                        </div>
                    </header>
                    <div class="production-chart__body">
                        <div class="production-chart__summary" id="unit-economics-summary" aria-live="polite"></div>
                        <div class="unit-economics__charts">
                            <div class="unit-economics__chart unit-economics__chart--mix">
                                <div class="production-chart__canvas unit-economics__canvas">
                                    <canvas
                                        id="unit-economics-chart"
                                        height="280"
                                        aria-label="Average unit economics pie chart"
                                        role="img"
                                    ></canvas>
                                    <p
                                        class="unit-economics__empty-message"
                                        id="unit-economics-chart-empty"
                                        role="status"
                                        hidden
                                    >
                                        No unit economics data for the selected period.
                                    </p>
                                </div>
                            </div>
                            <div class="unit-economics__chart unit-economics__chart--breakeven">
                                <div class="production-chart__canvas unit-economics__canvas">
                                    <canvas
                                        id="breakeven-chart"
                                        height="280"
                                        aria-label="Breakeven stacked column chart"
                                        role="img"
                                    ></canvas>
                                    <p
                                        class="unit-economics__empty-message"
                                        id="breakeven-chart-empty"
                                        role="status"
                                        hidden
                                    >
                                        No breakeven data for the selected period.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
            <section class="production-chart" aria-labelledby="closing-stock-title">
                <header class="production-chart__header">
                    <div>
                        <h2 id="closing-stock-title">Closing stock snapshot</h2>
                        <p>Distribution of today&#39;s closing stock across core materials.</p>
                    </div>
                    <div class="production-chart__controls">
                        <label class="production-chart__select" for="closing-stock-date">
                            <span>Day</span>
                            <input type="date" id="closing-stock-date" name="closing-stock-date" />
                        </label>
                    </div>
                </header>
                <div class="production-chart__body">
                    <div class="production-chart__summary" id="closing-stock-summary" aria-live="polite"></div>
                    <div class="closing-stock__charts" id="closing-stock-chart-container" hidden>
                        <div class="closing-stock__chart" id="closing-stock-chart-primary">
                            <div class="production-chart__canvas" id="closing-stock-chart-wrapper">
                                <canvas
                                    id="closing-stock-chart"
                                    height="320"
                                    aria-label="Closing stock distribution doughnut chart"
                                    role="img"
                                ></canvas>
                            </div>
                            <p class="closing-stock__chart-message" id="closing-stock-chart-message" role="status" hidden></p>
                        </div>
                        <div class="closing-stock__chart" id="closing-stock-chart-previous-day">
                            <div class="production-chart__canvas" id="closing-stock-previous-day-chart-wrapper">
                                <canvas
                                    id="closing-stock-previous-day-chart"
                                    height="320"
                                    aria-label="Previous day closing stock distribution doughnut chart"
                                    role="img"
                                ></canvas>
                            </div>
                            <p class="closing-stock__chart-message" id="closing-stock-previous-day-message" role="status" hidden></p>
                        </div>
                        <div class="closing-stock__chart" id="closing-stock-chart-last-month">
                            <div class="production-chart__canvas" id="closing-stock-last-month-chart-wrapper">
                                <canvas
                                    id="closing-stock-last-month-chart"
                                    height="320"
                                    aria-label="Last month closing stock distribution doughnut chart"
                                    role="img"
                                ></canvas>
                            </div>
                            <p class="closing-stock__chart-message" id="closing-stock-last-month-message" role="status" hidden></p>
                        </div>
                    </div>
                </div>
            </section>
            <section class="production-chart" aria-labelledby="production-chart-title">
                <header class="production-chart__header">
                    <div>
                        <h2 id="production-chart-title">Monthly production</h2>
                        <p>Review day-by-day output and spot trends instantly.</p>
                    </div>
                    <div class="production-chart__controls">
                        <label class="production-chart__select">
                            <span>Year</span>
                            <select id="production-year"></select>
                        </label>
                        <label class="production-chart__select">
                            <span>Month</span>
                            <select id="production-month"></select>
                        </label>
                        <button type="button" class="button button--ghost" id="production-compare-toggle" aria-pressed="false">
                            Compare with previous month
                        </button>
                    </div>
                </header>
                <div class="production-chart__body">
                    <div class="production-chart__summary" id="production-summary" aria-live="polite"></div>
                    <div class="production-chart__canvas">
                        <canvas id="production-chart" height="320" aria-label="Daily production bar chart" role="img"></canvas>
                    </div>
                </div>
            </section>
            <section class="production-chart" aria-labelledby="pulse-chart-title">
                <header class="production-chart__header">
                    <div>
                        <h2 id="pulse-chart-title">Machine running pulse</h2>
                        <p>Track hourly tons for each critical machine across the month.</p>
                    </div>
                    <div class="production-chart__controls">
                        <label class="production-chart__select">
                            <span>Start date</span>
                            <input type="date" id="production-pulse-start-date" />
                        </label>
                        <label class="production-chart__select">
                            <span>End date</span>
                            <input type="date" id="production-pulse-end-date" />
                        </label>
                        <label class="production-chart__select">
                            <span>Machine</span>
                            <select id="production-pulse-machine"></select>
                        </label>
                    </div>
                </header>
                <div class="production-chart__body">
                    <div class="production-chart__summary" id="production-pulse-summary" aria-live="polite"></div>
                    <div class="production-chart__canvas">
                        <canvas
                            id="production-pulse-chart"
                            height="320"
                            aria-label="Hourly machine production line chart"
                            role="img"
                        ></canvas>
                    </div>
                </div>
            </section>
            <section class="production-chart" aria-labelledby="idle-pareto-title">
                <header class="production-chart__header">
                    <div>
                        <h2 id="idle-pareto-title">Secondary idle reasons</h2>
                        <p>Pareto view of downtime drivers, stacked by machine for the month.</p>
                    </div>
                </header>
                <div class="production-chart__body">
                    <div class="production-chart__summary" id="idle-pareto-summary" aria-live="polite"></div>
                    <div class="production-chart__canvas">
                        <canvas
                            id="idle-pareto-chart"
                            height="320"
                            aria-label="Secondary idle reasons stacked Pareto chart"
                            role="img"
                        ></canvas>
                    </div>
                </div>
            </section>
            <section class="production-chart" aria-labelledby="sales-chart-title">
                <header class="production-chart__header">
                    <div>
                        <h2 id="sales-chart-title">Monthly sales</h2>
                        <p>Stacked daily sales for the selected month, grouped by customer.</p>
                    </div>
                </header>
                <div class="production-chart__body">
                    <div class="production-chart__summary" id="sales-summary" aria-live="polite"></div>
                    <div class="production-chart__canvas">
                        <canvas
                            id="sales-chart"
                            height="320"
                            aria-label="Daily sales stacked bar chart"
                            role="img"
                        ></canvas>
                    </div>
                </div>
            </section>
            <section class="production-chart" aria-labelledby="material-chart-title">
                <header class="production-chart__header">
                    <div>
                        <h2 id="material-chart-title">Monthly material inflow</h2>
                        <p>Stacked daily receipts across the month for core raw materials.</p>
                    </div>
                </header>
                <div class="production-chart__body">
                    <div class="production-chart__summary" id="material-summary" aria-live="polite"></div>
                    <div class="production-chart__canvas">
                        <canvas
                            id="material-chart"
                            height="320"
                            aria-label="Daily material receipt stacked bar chart"
                            role="img"
                        ></canvas>
                    </div>
                </div>
            </section>
            <section class="production-chart" aria-labelledby="labor-chart-title">
                <header class="production-chart__header">
                    <div>
                        <h2 id="labor-chart-title">Daily production labor cost</h2>
                        <p>Stacked day-by-day payroll impact for factory and casual teams.</p>
                    </div>
                </header>
                <div class="production-chart__body">
                    <div class="production-chart__summary" id="labor-summary" aria-live="polite"></div>
                    <div class="production-chart__canvas">
                        <canvas
                            id="labor-chart"
                            height="320"
                            aria-label="Daily production labor stacked bar chart"
                            role="img"
                        ></canvas>
                    </div>
                </div>
            </section>
        </section>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script>
        const token = localStorage.getItem("samprox_token");
        const userRaw = localStorage.getItem("samprox_user");
        let user;

        try {
            user = userRaw ? JSON.parse(userRaw) : null;
        } catch (_) {
            user = null;
        }

        if (!token || !user) {
            window.location.href = "/";
        }

        if (user?.role === "outside_manager" && window.location.pathname !== "/responsibility_portal") {
            window.location.replace("/responsibility_portal");
        }

        if (user?.role === "maintenance_manager" && window.location.pathname !== "/machines") {
            window.location.replace("/machines");
        }

        const roleLabels = {
            admin: "Admin",
            production_manager: "Production Manager",
            maintenance_manager: "Maintenance Manager",
            finance_manager: "Finance Manager",
            technician: "Technician",
            outside_manager: "Member Of Rainbow Group",
        };

        const userNameEl = document.getElementById("user-name");
        const userRoleEl = document.getElementById("user-role");
        const logoutButton = document.getElementById("logout");
        const mechanismLink = document.getElementById("mechanism-link");

        userNameEl.textContent = user?.name || "Unknown";
        userRoleEl.textContent = roleLabels[user?.role] || "";
        if (mechanismLink) {
            if (user?.role === "admin") {
                mechanismLink.hidden = false;
            } else {
                mechanismLink.remove();
            }
        }

        logoutButton.addEventListener("click", async () => {
            try {
                await fetch("/api/auth/logout", { method: "POST", credentials: "include" });
            } catch (error) {
                console.error("Failed to log out", error);
            } finally {
                localStorage.removeItem("samprox_token");
                localStorage.removeItem("samprox_user");
                window.location.href = "/";
            }
        });

        const yearSelect = document.getElementById("production-year");
        const monthSelect = document.getElementById("production-month");
        const compareToggle = document.getElementById("production-compare-toggle");
        const productionSummaryContainer = document.getElementById("production-summary");
        const productionChartCanvas = document.getElementById("production-chart");
        const productionPulseSummaryContainer = document.getElementById("production-pulse-summary");
        const productionPulseChartCanvas = document.getElementById("production-pulse-chart");
        const productionPulseMachineSelect = document.getElementById("production-pulse-machine");
        const productionPulseStartDateInput = document.getElementById("production-pulse-start-date");
        const productionPulseEndDateInput = document.getElementById("production-pulse-end-date");
        const idleParetoSummaryContainer = document.getElementById("idle-pareto-summary");
        const idleParetoChartCanvas = document.getElementById("idle-pareto-chart");
        const salesSummaryContainer = document.getElementById("sales-summary");
        const salesChartCanvas = document.getElementById("sales-chart");
        const materialSummaryContainer = document.getElementById("material-summary");
        const materialChartCanvas = document.getElementById("material-chart");
        const laborSummaryContainer = document.getElementById("labor-summary");
        const laborChartCanvas = document.getElementById("labor-chart");
        const unitEconomicsSummaryContainer = document.getElementById("unit-economics-summary");
        const unitEconomicsChartCanvas = document.getElementById("unit-economics-chart");
        const unitEconomicsStartDateInput = document.getElementById("unit-economics-start-date");
        const unitEconomicsEndDateInput = document.getElementById("unit-economics-end-date");
        const breakevenChartCanvas = document.getElementById("breakeven-chart");
        const unitEconomicsChartEmptyMessage = document.getElementById("unit-economics-chart-empty");
        const breakevenChartEmptyMessage = document.getElementById("breakeven-chart-empty");
        const closingStockSummaryContainer = document.getElementById("closing-stock-summary");
        const closingStockChartCanvas = document.getElementById("closing-stock-chart");
        const closingStockChartContainer = document.getElementById("closing-stock-chart-container");
        const closingStockChartWrapper = document.getElementById("closing-stock-chart-wrapper");
        const closingStockPreviousDayChartCanvas = document.getElementById("closing-stock-previous-day-chart");
        const closingStockPreviousDayChartWrapper = document.getElementById(
            "closing-stock-previous-day-chart-wrapper",
        );
        const closingStockLastMonthChartCanvas = document.getElementById("closing-stock-last-month-chart");
        const closingStockLastMonthChartWrapper = document.getElementById(
            "closing-stock-last-month-chart-wrapper",
        );
        const closingStockChartMessage = document.getElementById("closing-stock-chart-message");
        const closingStockPreviousDayMessage = document.getElementById("closing-stock-previous-day-message");
        const closingStockLastMonthMessage = document.getElementById("closing-stock-last-month-message");
        const closingStockDateInput = document.getElementById("closing-stock-date");
        const systemStatusDot = document.getElementById("system-status-dot");
        const systemStatusValue = document.getElementById("system-status-value");
        const systemStatusDeadline = document.getElementById("system-status-deadline");
        const systemStatusTimestamp = document.getElementById("system-status-timestamp");
        const systemStatusList = document.getElementById("system-status-items");
        const systemStatusRefreshButton = document.getElementById("system-status-refresh");

        const authHeaders = {
            Authorization: `Bearer ${token}`,
        };

        let selectedPulseMachine = null;
        const initialSearchParams = new URLSearchParams(window.location.search);
        const machineQueryParam = (initialSearchParams.get("machine") || "").trim().toUpperCase();
        if (machineQueryParam) {
            selectedPulseMachine = machineQueryParam;
        }

        const numberFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2,
        });
        const percentFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 1,
        });
        const currencyFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2,
        });
        const hoursFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2,
        });
        const unitValueFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 3,
        });
        const kgFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
        });
        const dateRangeFormatter = new Intl.DateTimeFormat(undefined, {
            month: "short",
            day: "numeric",
            year: "numeric",
        });

        const isoToday = () => {
            const today = new Date();
            const month = String(today.getMonth() + 1).padStart(2, "0");
            const day = String(today.getDate()).padStart(2, "0");
            return `${today.getFullYear()}-${month}-${day}`;
        };

        const ensureChartJsAvailable = () => typeof Chart !== "undefined";

        const toIsoDate = (date) => {
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
                return null;
            }

            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            return `${date.getFullYear()}-${month}-${day}`;
        };

        const parseIsoDate = (value) => {
            if (!value) {
                return null;
            }

            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) {
                return null;
            }

            return parsed;
        };

        const getPreviousDayIso = (value) => {
            if (!value) {
                return null;
            }

            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
                return null;
            }

            date.setDate(date.getDate() - 1);
            return toIsoDate(date);
        };

        const getLastDayOfPreviousMonthIso = (value) => {
            if (!value) {
                return null;
            }

            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
                return null;
            }

            date.setDate(1);
            date.setHours(0, 0, 0, 0);
            date.setMonth(date.getMonth(), 0);
            return toIsoDate(date);
        };

        const formatChartDateLabel = (value) => {
            if (!value) {
                return "";
            }

            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) {
                return value;
            }

            return parsed.toLocaleDateString(undefined, {
                month: "short",
                day: "numeric",
            });
        };

        const SYSTEM_STATUS_FIELDS = [
            { key: "daily_production_entry", label: "Production entry" },
            { key: "sales_actual_entry", label: "Sales entry" },
            { key: "mrn_lines", label: "Material receipts" },
            { key: "briquette_mix_entries", label: "Mix update" },
            { key: "machine_idle_event", label: "Idle log" },
            { key: "team_attendance_record", label: "Attendance" },
        ];

        const normalizeStatusText = (value) => (value || "").toString().trim().toUpperCase();

        const setSystemStatusIndicator = (statusText) => {
            if (!systemStatusValue || !systemStatusDot) {
                return;
            }

            const normalized = normalizeStatusText(statusText);
            const isUpdated = normalized === "UPDATED";

            systemStatusValue.textContent = statusText || "Updated";
            systemStatusValue.classList.toggle("system-status__value--alert", !isUpdated);
            systemStatusDot.classList.toggle("system-status__dot--ok", isUpdated);
            systemStatusDot.classList.toggle("system-status__dot--alert", !isUpdated);
        };

        const setSystemStatusTimestamp = (value) => {
            if (!systemStatusTimestamp) {
                return;
            }

            if (!value) {
                systemStatusTimestamp.textContent = "—";
                return;
            }

            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) {
                systemStatusTimestamp.textContent = value;
                return;
            }

            systemStatusTimestamp.textContent = parsed.toLocaleString(undefined, {
                hour: "numeric",
                minute: "2-digit",
                hour12: true,
            });
        };

        const renderSystemStatusList = (payload) => {
            if (!systemStatusList) {
                return;
            }

            systemStatusList.innerHTML = "";

            SYSTEM_STATUS_FIELDS.forEach((field) => {
                const status = normalizeStatusText(payload?.[field.key]) === "OK" ? "OK" : "Missing";
                const item = document.createElement("li");
                item.className = `system-status__item system-status__item--${status === "OK" ? "ok" : "missing"}`;
                item.innerHTML = `
                    <span class="system-status__item-icon">${status === "OK" ? "✓" : "✕"}</span>
                    <span>${field.label}</span>
                    <span class="system-status__item-status">(${status})</span>
                `;
                systemStatusList.appendChild(item);
            });
        };

        const showSystemStatusLoading = () => {
            setSystemStatusIndicator("Checking…");
            setSystemStatusTimestamp(null);
            if (systemStatusList) {
                systemStatusList.innerHTML = "";
                const loader = document.createElement("li");
                loader.className = "system-status__item";
                loader.textContent = "Pulling in the latest checks…";
                systemStatusList.appendChild(loader);
            }
        };

        const showSystemStatusError = (message) => {
            setSystemStatusIndicator("Unavailable");
            setSystemStatusTimestamp(null);
            if (systemStatusList) {
                systemStatusList.innerHTML = "";
                const errorItem = document.createElement("li");
                errorItem.className = "system-status__item system-status__item--missing";
                errorItem.innerHTML = `
                    <span class="system-status__item-icon">!</span>
                    <span>${message}</span>
                `;
                systemStatusList.appendChild(errorItem);
            }
        };

        const fetchSystemStatus = async () => {
            if (!systemStatusValue || !systemStatusDot) {
                return;
            }

            showSystemStatusLoading();

            try {
                const response = await fetch("/api/system/status", { headers: { ...authHeaders } });
                if (!response.ok) {
                    throw new Error("Unable to fetch system status");
                }

                const payload = await response.json();
                const statusText = payload?.system_status || "UPDATED";

                setSystemStatusIndicator(statusText);
                renderSystemStatusList(payload || {});
                if (payload?.deadline && systemStatusDeadline) {
                    systemStatusDeadline.textContent = payload.deadline;
                }
                setSystemStatusTimestamp(payload?.last_checked);
            } catch (error) {
                console.error("Failed to refresh system status", error);
                showSystemStatusError("Status check failed. Try again shortly.");
            }
        };

        const getSelectedUnitEconomicsRange = () => {
            if (!unitEconomicsStartDateInput || !unitEconomicsEndDateInput) {
                return null;
            }

            const startDate = unitEconomicsStartDateInput.value;
            const endDate = unitEconomicsEndDateInput.value;

            if (!startDate || !endDate) {
                return null;
            }

            if (startDate > endDate) {
                return null;
            }

            return { startDate, endDate };
        };

        const buildUnitEconomicsRangeKey = (range) => {
            if (!range?.startDate || !range?.endDate) {
                return null;
            }

            return `${range.startDate}__${range.endDate}`;
        };

        const syncUnitEconomicsDateConstraints = () => {
            if (!unitEconomicsStartDateInput || !unitEconomicsEndDateInput) {
                return;
            }

            const startDate = unitEconomicsStartDateInput.value;
            const endDate = unitEconomicsEndDateInput.value;

            if (startDate) {
                unitEconomicsEndDateInput.min = startDate;
            }

            if (endDate) {
                unitEconomicsStartDateInput.max = endDate;
            }
        };

        const initializeUnitEconomicsDateInputs = () => {
            if (!unitEconomicsStartDateInput || !unitEconomicsEndDateInput) {
                return;
            }

            const todayIso = isoToday();
            const todayDate = parseIsoDate(todayIso);
            const defaultStart = todayDate
                ? new Date(todayDate.getFullYear(), todayDate.getMonth(), 1)
                : new Date();
            const startIso = toIsoDate(defaultStart);

            unitEconomicsStartDateInput.value = startIso;
            unitEconomicsEndDateInput.value = todayIso;
            unitEconomicsStartDateInput.max = todayIso;
            unitEconomicsEndDateInput.max = todayIso;
            unitEconomicsEndDateInput.min = startIso;

            syncUnitEconomicsDateConstraints();
        };

        const formatIsoDateLabel = (value) => {
            if (!value) {
                return "";
            }
            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) {
                return "";
            }
            return parsed.toLocaleDateString(undefined, {
                year: "numeric",
                month: "short",
                day: "numeric",
            });
        };

        const closingStockCharts = {
            today: {
                canvas: closingStockChartCanvas,
                wrapper: closingStockChartWrapper,
                message: closingStockChartMessage,
                instance: null,
                getTitle: (asOf) =>
                    asOf
                        ? `Closing stock as of ${formatIsoDateLabel(asOf) || asOf}`
                        : "Closing stock distribution",
            },
            previousDay: {
                canvas: closingStockPreviousDayChartCanvas,
                wrapper: closingStockPreviousDayChartWrapper,
                message: closingStockPreviousDayMessage,
                instance: null,
                getTitle: (asOf) =>
                    asOf
                        ? `Closing stock on ${formatIsoDateLabel(asOf) || asOf}`
                        : "Previous day closing stock",
            },
            lastMonth: {
                canvas: closingStockLastMonthChartCanvas,
                wrapper: closingStockLastMonthChartWrapper,
                message: closingStockLastMonthMessage,
                instance: null,
                getTitle: (asOf) =>
                    asOf
                        ? `Closing stock on ${formatIsoDateLabel(asOf) || asOf}`
                        : "Last month closing stock",
            },
        };

        const CLOSING_STOCK_KEYS = [
            "sawdust",
            "wood_shaving",
            "wood_powder",
            "peanut_husk",
            "fire_cut",
            "briquettes",
        ];

        const CLOSING_STOCK_COLOR_PALETTE = [
            { background: "rgba(37, 99, 235, 0.82)", border: "rgb(37, 99, 235)" },
            { background: "rgba(59, 130, 246, 0.82)", border: "rgb(59, 130, 246)" },
            { background: "rgba(14, 165, 233, 0.82)", border: "rgb(14, 165, 233)" },
            { background: "rgba(16, 185, 129, 0.82)", border: "rgb(16, 185, 129)" },
            { background: "rgba(251, 191, 36, 0.82)", border: "rgb(251, 191, 36)" },
            { background: "rgba(244, 114, 182, 0.82)", border: "rgb(244, 114, 182)" },
        ];

        let closingStockAsOf = null;

        const MACHINE_SERIES = [
            {
                field: "MCH1",
                label: "MCH-0001",
                backgroundColor: "rgba(37, 99, 235, 0.75)",
                borderColor: "rgb(37, 99, 235)",
            },
            {
                field: "MCH2",
                label: "MCH-0002",
                backgroundColor: "rgba(96, 165, 250, 0.75)",
                borderColor: "rgb(96, 165, 250)",
            },
        ];

        const DEFAULT_MACHINE_STACK_STYLE = {
            backgroundColor: "rgba(148, 163, 184, 0.65)",
            borderColor: "rgb(148, 163, 184)",
        };

        const PULSE_MACHINE_SERIES = [
            {
                field: "MCH1",
                label: "MCH-0001",
                borderColor: "rgb(37, 99, 235)",
                backgroundColor: "rgba(37, 99, 235, 0.25)",
            },
            {
                field: "MCH2",
                label: "MCH-0002",
                borderColor: "rgb(59, 130, 246)",
                backgroundColor: "rgba(59, 130, 246, 0.25)",
            },
            {
                field: "MCH3",
                label: "MCH-0003",
                borderColor: "rgb(56, 189, 248)",
                backgroundColor: "rgba(56, 189, 248, 0.25)",
            },
        ];

        const DEFAULT_PULSE_MACHINE_STYLE = {
            borderColor: "rgb(37, 99, 235)",
            backgroundColor: "rgba(37, 99, 235, 0.25)",
        };

        const SALES_DATASET_COLORS = [
            { background: "rgba(14, 165, 233, 0.75)", border: "rgb(14, 165, 233)" },
            { background: "rgba(99, 102, 241, 0.75)", border: "rgb(99, 102, 241)" },
            { background: "rgba(16, 185, 129, 0.75)", border: "rgb(16, 185, 129)" },
            { background: "rgba(234, 179, 8, 0.75)", border: "rgb(234, 179, 8)" },
            { background: "rgba(236, 72, 153, 0.75)", border: "rgb(236, 72, 153)" },
            { background: "rgba(148, 163, 184, 0.65)", border: "rgb(148, 163, 184)" },
        ];

        const MATERIAL_STACK_COLORS = {
            "Wood Shaving": { background: "rgba(245, 158, 11, 0.75)", border: "rgb(245, 158, 11)" },
            "Saw Dust": { background: "rgba(217, 119, 6, 0.75)", border: "rgb(217, 119, 6)" },
            "Wood Powder": { background: "rgba(59, 130, 246, 0.75)", border: "rgb(59, 130, 246)" },
            "Peanut Husk": { background: "rgba(16, 185, 129, 0.75)", border: "rgb(16, 185, 129)" },
            "Other materials": { background: "rgba(148, 163, 184, 0.65)", border: "rgb(148, 163, 184)" },
        };

        const MATERIAL_COLOR_PALETTE = [
            { background: "rgba(56, 189, 248, 0.75)", border: "rgb(56, 189, 248)" },
            { background: "rgba(96, 165, 250, 0.75)", border: "rgb(96, 165, 250)" },
            { background: "rgba(45, 212, 191, 0.75)", border: "rgb(45, 212, 191)" },
            { background: "rgba(129, 140, 248, 0.75)", border: "rgb(129, 140, 248)" },
        ];

        const LABOR_COLOR_PALETTE = [
            { background: "rgba(59, 130, 246, 0.75)", border: "rgb(59, 130, 246)" },
            { background: "rgba(16, 185, 129, 0.75)", border: "rgb(16, 185, 129)" },
            { background: "rgba(249, 115, 22, 0.75)", border: "rgb(249, 115, 22)" },
            { background: "rgba(236, 72, 153, 0.75)", border: "rgb(236, 72, 153)" },
            { background: "rgba(139, 92, 246, 0.75)", border: "rgb(139, 92, 246)" },
            { background: "rgba(34, 211, 238, 0.75)", border: "rgb(34, 211, 238)" },
            { background: "rgba(244, 114, 182, 0.75)", border: "rgb(244, 114, 182)" },
            { background: "rgba(74, 222, 128, 0.75)", border: "rgb(74, 222, 128)" },
            { background: "rgba(250, 204, 21, 0.75)", border: "rgb(250, 204, 21)" },
            { background: "rgba(148, 163, 184, 0.7)", border: "rgb(148, 163, 184)" },
        ];

        const UNIT_ECONOMICS_COLORS = {
            material: { background: "rgba(37, 99, 235, 0.8)", border: "rgb(37, 99, 235)" },
            labor: { background: "rgba(16, 185, 129, 0.8)", border: "rgb(16, 185, 129)" },
            other: { background: "rgba(234, 179, 8, 0.8)", border: "rgb(234, 179, 8)" },
            contributionPositive: { background: "rgba(129, 140, 248, 0.85)", border: "rgb(129, 140, 248)" },
            contributionNegative: { background: "rgba(248, 113, 113, 0.85)", border: "rgb(239, 68, 68)" },
        };

        const BREAKEVEN_FIXED_COST = 2100000;
        const BREAKEVEN_DATASET_COLORS = {
            profitPositive: { background: "rgba(34, 197, 94, 0.75)", border: "rgb(22, 163, 74)" },
            profitNegative: { background: "rgba(248, 113, 113, 0.8)", border: "rgb(239, 68, 68)" },
        };

        const setClosingStockSummaryMessage = (label, message) => {
            if (!closingStockSummaryContainer) {
                return;
            }

            closingStockSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">${label}</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const showClosingStockChartMessage = (config, message) => {
            if (!config) {
                return;
            }

            if (config.instance) {
                config.instance.destroy();
                config.instance = null;
            }

            if (config.wrapper) {
                config.wrapper.hidden = true;
            }

            if (config.message) {
                config.message.textContent = message;
                config.message.hidden = false;
            }

            if (closingStockChartContainer) {
                closingStockChartContainer.hidden = false;
            }
        };

        const showClosingStockChartData = (config, items, asOf) => {
            if (!config?.canvas || !ensureChartJsAvailable()) {
                return;
            }

            if (config.message) {
                config.message.hidden = true;
            }

            if (config.wrapper) {
                config.wrapper.hidden = false;
            }

            const labels = items.map((item) => item?.label || item?.name || item?.key || "—");
            const data = items.map((item) => {
                const closingBalance = Number(item?.metrics?.closing_balance ?? item?.quantity_ton ?? 0);
                return Number.isFinite(closingBalance) ? Math.max(closingBalance, 0) : 0;
            });
            const backgroundColor = items.map(
                (_, index) => CLOSING_STOCK_COLOR_PALETTE[index % CLOSING_STOCK_COLOR_PALETTE.length].background,
            );
            const borderColor = items.map(
                (_, index) => CLOSING_STOCK_COLOR_PALETTE[index % CLOSING_STOCK_COLOR_PALETTE.length].border,
            );

            const title = config.getTitle
                ? config.getTitle(asOf)
                : asOf
                  ? `Closing stock as of ${formatIsoDateLabel(asOf) || asOf}`
                  : "Closing stock distribution";
            const options = buildClosingStockChartOptions(title);

            const dataset = {
                label: "Closing stock (tons)",
                data,
                backgroundColor,
                borderColor,
                borderWidth: 1,
                hoverOffset: 6,
            };

            if (config.instance) {
                config.instance.data = { labels, datasets: [dataset] };
                config.instance.options = options;
                config.instance.update();
            } else {
                config.instance = new Chart(config.canvas, {
                    type: "doughnut",
                    data: { labels, datasets: [dataset] },
                    options,
                });
            }

            if (closingStockChartContainer) {
                closingStockChartContainer.hidden = false;
            }
        };

        const showClosingStockLoading = () => {
            setClosingStockSummaryMessage("Closing stock", "Loading…");
            if (closingStockChartContainer) {
                closingStockChartContainer.hidden = true;
            }
            Object.values(closingStockCharts).forEach((chart) => {
                if (chart.instance) {
                    chart.instance.destroy();
                    chart.instance = null;
                }
                if (chart.wrapper) {
                    chart.wrapper.hidden = true;
                }
                if (chart.message) {
                    chart.message.hidden = true;
                }
            });
        };

        const showClosingStockError = (message) => {
            setClosingStockSummaryMessage("Closing stock", message);
            if (closingStockChartContainer) {
                closingStockChartContainer.hidden = true;
            }
            Object.values(closingStockCharts).forEach((chart) => {
                if (chart.instance) {
                    chart.instance.destroy();
                    chart.instance = null;
                }
                if (chart.wrapper) {
                    chart.wrapper.hidden = true;
                }
                if (chart.message) {
                    chart.message.hidden = true;
                }
            });
        };

        const renderClosingStockSummary = (items) => {
            if (!closingStockSummaryContainer) {
                return;
            }

            let totalTons = 0;
            let totalValue = 0;
            let topMaterialLabel = "";
            let topMaterialTons = 0;

            items.forEach((item) => {
                const closingBalance = Number(item?.metrics?.closing_balance ?? item?.quantity_ton ?? 0);
                const normalizedClosing = Number.isFinite(closingBalance) ? Math.max(closingBalance, 0) : 0;
                const value = Number(item?.value_rs ?? 0);
                const normalizedValue = Number.isFinite(value) ? Math.max(value, 0) : 0;

                totalTons += normalizedClosing;
                totalValue += normalizedValue;

                if (normalizedClosing > topMaterialTons) {
                    topMaterialTons = normalizedClosing;
                    topMaterialLabel = item?.label || item?.name || item?.key || "—";
                }
            });

            const metrics = [
                {
                    label: "Total closing stock",
                    value: `${formatTons(totalTons)} tons`,
                },
                {
                    label: "Inventory value",
                    value: formatCurrency(totalValue),
                    isCurrency: true,
                },
                {
                    label: "Top material",
                    value:
                        topMaterialLabel && topMaterialTons > 0
                            ? `${topMaterialLabel} (${formatTons(topMaterialTons)} tons)`
                            : "—",
                },
            ];

            closingStockSummaryContainer.innerHTML = metrics
                .map((metric) => {
                    const valueClass = metric.isCurrency
                        ? "production-chart__metric-value production-chart__metric-value--currency"
                        : "production-chart__metric-value";
                    return `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="${valueClass}">${metric.value}</span>
                        </div>
                    `;
                })
                .join("");

            if (closingStockChartContainer) {
                closingStockChartContainer.hidden = false;
            }
        };

        const buildClosingStockChartOptions = (title) => ({
            responsive: true,
            maintainAspectRatio: false,
            cutout: "55%",
            plugins: {
                legend: {
                    position: "right",
                    labels: {
                        usePointStyle: true,
                        pointStyle: "rectRounded",
                        color: "#0f172a",
                    },
                },
                title: {
                    display: true,
                    align: "start",
                    text: title,
                    color: "#0f172a",
                    font: {
                        family: "Inter, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
                        size: 16,
                        weight: "600",
                    },
                },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const label = context.label || "";
                            const value = Number(context.parsed ?? 0);
                            const dataset = context?.chart?.data?.datasets?.[0];
                            const total = Array.isArray(dataset?.data)
                                ? dataset.data.reduce((sum, item) => sum + Number(item || 0), 0)
                                : 0;
                            const percent = total > 0 ? (value / total) * 100 : 0;
                            return `${label}: ${formatTons(value)} tons (${formatPercent(percent)}%)`;
                        },
                    },
                },
            },
        });

        const renderClosingStockChart = (items, asOf) => {
            if (!Array.isArray(items) || !items.length) {
                showClosingStockChartMessage(closingStockCharts.today, "No closing stock data available.");
                return;
            }

            showClosingStockChartData(closingStockCharts.today, items, asOf);
        };

        const fetchClosingStockStatus = async (asOf) => {
            const params = new URLSearchParams();
            if (asOf) {
                params.set("as_of", asOf);
            }
            const query = params.toString();
            const response = await fetch(`/api/material/stock-status${query ? `?${query}` : ""}`, {
                headers: authHeaders,
            });

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load closing stock status.");
            }

            return response.json();
        };

        const loadClosingStock = async (asOf) => {
            if (!closingStockSummaryContainer) {
                return;
            }

            showClosingStockLoading();

            try {
                const data = await fetchClosingStockStatus(asOf);
                if (!data) {
                    return;
                }

                closingStockAsOf = data.as_of || asOf || closingStockAsOf;
                const items = Array.isArray(data.items) ? data.items : [];
                const relevantItems = items.filter((item) => CLOSING_STOCK_KEYS.includes(item?.key));

                if (!relevantItems.length) {
                    showClosingStockError("No closing stock data available.");
                    return;
                }

                renderClosingStockSummary(relevantItems);
                renderClosingStockChart(relevantItems, closingStockAsOf);

                if (closingStockDateInput && closingStockAsOf) {
                    closingStockDateInput.value = closingStockAsOf;
                }

                loadClosingStockComparisons(closingStockAsOf);
            } catch (error) {
                console.error(error);
                showClosingStockError("Unable to load closing stock right now.");
            }
        };

        const loadClosingStockComparisons = async (baseDate) => {
            const comparisons = [
                {
                    config: closingStockCharts.previousDay,
                    asOf: getPreviousDayIso(baseDate),
                    emptyMessage: "No closing stock data available for the previous day.",
                },
                {
                    config: closingStockCharts.lastMonth,
                    asOf: getLastDayOfPreviousMonthIso(baseDate),
                    emptyMessage: "No closing stock data available for the last month.",
                },
            ];

            comparisons.forEach(({ config, asOf }) => {
                if (!config) {
                    return;
                }

                if (!asOf) {
                    showClosingStockChartMessage(config, "Select a day to view this comparison.");
                    return;
                }

                showClosingStockChartMessage(config, "Loading…");
            });

            await Promise.all(
                comparisons.map(async ({ config, asOf, emptyMessage }) => {
                    if (!config || !asOf) {
                        return;
                    }

                    try {
                        const data = await fetchClosingStockStatus(asOf);
                        if (!data) {
                            showClosingStockChartMessage(config, "Unable to load closing stock right now.");
                            return;
                        }

                        const items = Array.isArray(data.items) ? data.items : [];
                        const relevantItems = items.filter((item) => CLOSING_STOCK_KEYS.includes(item?.key));

                        if (!relevantItems.length) {
                            showClosingStockChartMessage(config, emptyMessage);
                            return;
                        }

                        showClosingStockChartData(config, relevantItems, data.as_of || asOf);
                    } catch (error) {
                        console.error(error);
                        showClosingStockChartMessage(config, "Unable to load closing stock right now.");
                    }
                }),
            );
        };

        const initializeClosingStockDateInput = () => {
            const todayValue = isoToday();
            if (!closingStockDateInput) {
                return todayValue;
            }

            closingStockDateInput.max = todayValue;
            if (!closingStockDateInput.value) {
                closingStockDateInput.value = todayValue;
            }

            closingStockDateInput.addEventListener("change", () => {
                const value = closingStockDateInput.value || closingStockDateInput.max || isoToday();
                loadClosingStock(value);
            });

            return closingStockDateInput.value || todayValue;
        };

        const MONTH_OPTIONS = Array.from({ length: 12 }, (_, index) => {
            const value = String(index + 1).padStart(2, "0");
            const label = new Date(2000, index, 1).toLocaleString(undefined, {
                month: "long",
            });
            return { value, label };
        });
        const MIN_YEAR = 1900;
        const MAX_YEAR = 2100;

        const populateYearOptions = (selectedYear) => {
            yearSelect.innerHTML = "";
            const parsedYear = Number(selectedYear);
            const startYear = Number.isFinite(parsedYear)
                ? Math.min(MIN_YEAR, parsedYear)
                : MIN_YEAR;
            const endYear = Number.isFinite(parsedYear)
                ? Math.max(MAX_YEAR, parsedYear)
                : MAX_YEAR;

            for (let year = endYear; year >= startYear; year -= 1) {
                const option = document.createElement("option");
                option.value = String(year);
                option.textContent = year;
                if (String(year) === String(selectedYear)) {
                    option.selected = true;
                }
                yearSelect.append(option);
            }
            yearSelect.disabled = yearSelect.options.length === 0;
        };

        const populateMonthOptions = (year, selectedPeriod = null) => {
            monthSelect.innerHTML = "";
            const targetMonth = selectedPeriod ? selectedPeriod.split("-")[1] : null;

            MONTH_OPTIONS.forEach(({ value, label }) => {
                const option = document.createElement("option");
                option.value = `${year}-${value}`;
                option.textContent = label;
                if (targetMonth ? targetMonth === value : false) {
                    option.selected = true;
                }
                monthSelect.append(option);
            });

            if (!monthSelect.value && monthSelect.options.length > 0) {
                const today = new Date();
                const currentMonth = String(today.getMonth() + 1).padStart(2, "0");
                const fallbackValue = `${year}-${currentMonth}`;
                const fallbackOption = Array.from(monthSelect.options).find(
                    (option) => option.value === fallbackValue,
                );
                if (fallbackOption) {
                    fallbackOption.selected = true;
                } else {
                    monthSelect.options[0].selected = true;
                }
            }

            monthSelect.disabled = monthSelect.options.length === 0;
        };

        const initializePeriodSelectors = () => {
            const today = new Date();
            const initialYear = String(today.getFullYear());
            const initialPeriod = `${initialYear}-${String(today.getMonth() + 1).padStart(2, "0")}`;

            populateYearOptions(initialYear);
            if (yearSelect.disabled) {
                showProductionSummaryError("No production periods available.");
                showSalesSummaryError("No sales periods available.");
                showLaborSummaryError("No labor data available.");
                return false;
            }

            populateMonthOptions(initialYear, initialPeriod);
            return true;
        };

        const getSelectedPeriodKey = () => {
            const periodKey = monthSelect.value;
            return periodKey ? periodKey : null;
        };

        const productionPeriodCache = new Map();
        const productionPulsePeriodCache = new Map();
        const idleSummaryPeriodCache = new Map();
        const idleParetoPeriodCache = new Map();
        const salesPeriodCache = new Map();
        const materialPeriodCache = new Map();
        const laborPeriodCache = new Map();
        const unitEconomicsPeriodCache = new Map();

        const formatTons = (value) => {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return "0";
            }
            return numberFormatter.format(number);
        };

        const formatPercent = (value) => {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return "0";
            }
            return percentFormatter.format(number);
        };

        const formatCurrency = (value) => {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return "Rs 0";
            }
            return `Rs ${currencyFormatter.format(number)}`;
        };

        const formatHours = (value) => {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return "0";
            }
            return hoursFormatter.format(number);
        };

        const formatDateRangeLabel = (startValue, endValue) => {
            const startDate = parseIsoDate(startValue);
            const endDate = parseIsoDate(endValue);

            if (!startDate && !endDate) {
                return "—";
            }

            if (!startDate || !endDate) {
                const formattedStart = startDate ? dateRangeFormatter.format(startDate) : "—";
                const formattedEnd = endDate ? dateRangeFormatter.format(endDate) : "—";
                if (formattedStart === formattedEnd) {
                    return formattedStart;
                }
                return `${formattedStart} – ${formattedEnd}`;
            }

            const formattedStart = dateRangeFormatter.format(startDate);
            const formattedEnd = dateRangeFormatter.format(endDate);

            if (formattedStart === formattedEnd) {
                return formattedStart;
            }

            return `${formattedStart} – ${formattedEnd}`;
        };

        const formatCurrencyPerKg = (value) => {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return "Rs 0/kg";
            }
            const formatted = unitValueFormatter.format(Math.abs(number));
            const prefix = number < 0 ? "-Rs" : "Rs";
            return `${prefix} ${formatted}/kg`;
        };

        const formatKg = (value) => {
            const number = Number(value);
            if (!Number.isFinite(number)) {
                return "0";
            }
            return kgFormatter.format(number);
        };

        const normalizeMachineCode = (code) => (code || "").trim().toUpperCase();

        const getMachineFieldName = (machineCode) => {
            if (!machineCode) {
                return null;
            }
            if (machineCode.startsWith("MCH-000")) {
                return machineCode.replace("MCH-000", "MCH");
            }
            return machineCode.replace(/-/g, "");
        };

        const getPulseMachineSeriesForCode = (machineCode) => {
            const fieldName = getMachineFieldName(machineCode);
            if (!fieldName) {
                return null;
            }
            return (
                PULSE_MACHINE_SERIES.find(
                    (series) => series.field === fieldName || series.label === machineCode,
                ) || null
            );
        };

        const getMachineStackStyleForCode = (machineCode) => {
            const fieldName = getMachineFieldName(machineCode);
            if (!fieldName) {
                return DEFAULT_MACHINE_STACK_STYLE;
            }
            return (
                MACHINE_SERIES.find(
                    (series) => series.field === fieldName || series.label === machineCode,
                ) || DEFAULT_MACHINE_STACK_STYLE
            );
        };

        const getMaterialStackStyle = (materialName, index = 0) => {
            const normalizedName = (materialName || "").trim();
            if (normalizedName && MATERIAL_STACK_COLORS[normalizedName]) {
                return MATERIAL_STACK_COLORS[normalizedName];
            }
            if (MATERIAL_COLOR_PALETTE.length > 0) {
                return MATERIAL_COLOR_PALETTE[index % MATERIAL_COLOR_PALETTE.length];
            }
            return MATERIAL_STACK_COLORS["Other materials"];
        };

        const updateMachineQueryParam = () => {
            const params = new URLSearchParams(window.location.search);
            if (selectedPulseMachine) {
                params.set("machine", selectedPulseMachine);
            } else {
                params.delete("machine");
            }
            const searchString = params.toString();
            const newUrl = `${window.location.pathname}${searchString ? `?${searchString}` : ""}${window.location.hash}`;
            window.history.replaceState({}, "", newUrl);
        };

        const updatePulseMachineOptions = (availableCodes, selectedCode) => {
            if (!productionPulseMachineSelect) {
                return;
            }

            const normalizedCodes = Array.isArray(availableCodes)
                ? availableCodes.map((code) => normalizeMachineCode(code))
                : [];

            productionPulseMachineSelect.innerHTML = "";

            normalizedCodes.forEach((code) => {
                const option = document.createElement("option");
                option.value = code;
                option.textContent = code;
                if (code === selectedCode) {
                    option.selected = true;
                }
                productionPulseMachineSelect.append(option);
            });

            productionPulseMachineSelect.disabled = normalizedCodes.length === 0;
        };

        const resolvePulseMachineSelection = (availableCodes) => {
            const normalizedCodes = Array.isArray(availableCodes)
                ? availableCodes.map((code) => normalizeMachineCode(code))
                : [];

            if (normalizedCodes.length === 0) {
                selectedPulseMachine = null;
                updatePulseMachineOptions([], null);
                updateMachineQueryParam();
                return null;
            }

            const normalizedSelection = normalizeMachineCode(selectedPulseMachine);
            const hasValidSelection = normalizedSelection
                ? normalizedCodes.includes(normalizedSelection)
                : false;
            const nextSelection = hasValidSelection ? normalizedSelection : normalizedCodes[0];

            selectedPulseMachine = nextSelection;
            updatePulseMachineOptions(normalizedCodes, nextSelection);
            updateMachineQueryParam();

            return nextSelection;
        };

        const getPeriodBounds = (periodKey) => {
            if (!periodKey) {
                return null;
            }

            const [yearStr, monthStr] = periodKey.split("-");
            const year = Number(yearStr);
            const month = Number(monthStr);

            if (!Number.isFinite(year) || !Number.isFinite(month)) {
                return null;
            }

            const startDate = new Date(year, month - 1, 1);
            const endDate = new Date(year, month, 0);

            return {
                start: toIsoDate(startDate),
                end: toIsoDate(endDate),
            };
        };

        const syncProductionPulseDateConstraints = () => {
            if (!productionPulseStartDateInput || !productionPulseEndDateInput) {
                return;
            }

            const startValue = productionPulseStartDateInput.value;
            const endValue = productionPulseEndDateInput.value;

            productionPulseStartDateInput.max = endValue || "";
            productionPulseEndDateInput.min = startValue || "";
        };

        const normalizeProductionPulseRange = (changedField = null) => {
            if (!productionPulseStartDateInput || !productionPulseEndDateInput) {
                return;
            }

            let startValue = productionPulseStartDateInput.value;
            let endValue = productionPulseEndDateInput.value;

            if (startValue && !endValue) {
                productionPulseEndDateInput.value = startValue;
                endValue = startValue;
            }

            if (endValue && !startValue) {
                productionPulseStartDateInput.value = endValue;
                startValue = endValue;
            }

            if (startValue && endValue && startValue > endValue) {
                if (changedField === "start") {
                    productionPulseEndDateInput.value = startValue;
                    endValue = startValue;
                } else if (changedField === "end") {
                    productionPulseStartDateInput.value = endValue;
                    startValue = endValue;
                } else {
                    productionPulseEndDateInput.value = startValue;
                    endValue = startValue;
                }
            }

            syncProductionPulseDateConstraints();
        };

        const getSelectedPulseRange = () => {
            if (!productionPulseStartDateInput || !productionPulseEndDateInput) {
                return null;
            }

            const startValue = productionPulseStartDateInput.value;
            const endValue = productionPulseEndDateInput.value;

            if (!startValue || !endValue) {
                return null;
            }

            return { startDate: startValue, endDate: endValue };
        };

        const resetProductionPulseRangeToPeriod = () => {
            if (!productionPulseStartDateInput || !productionPulseEndDateInput) {
                return;
            }

            const periodKey = getSelectedPeriodKey();
            const bounds = getPeriodBounds(periodKey);

            if (bounds) {
                productionPulseStartDateInput.value = bounds.start;
                productionPulseEndDateInput.value = bounds.end;
            } else {
                productionPulseStartDateInput.value = "";
                productionPulseEndDateInput.value = "";
            }

            normalizeProductionPulseRange();
        };

        const getPulseRangeCacheKey = (range) => {
            if (!range || !range.startDate || !range.endDate) {
                return null;
            }

            return `${range.startDate}__${range.endDate}`;
        };

        const renderProductionSummary = (periodData, comparisonData = null) => {
            const total = Number(periodData?.total_production ?? 0);
            const average = Number(periodData?.average_day_production ?? 0);
            const peakDay = periodData?.peak?.day ?? null;
            const peakValue = Number(periodData?.peak?.total_tons ?? 0);

            const summaryMetrics = [
                {
                    label: "Total Production",
                    value: formatTons(total),
                },
                {
                    label: "Average Day Production",
                    value: formatTons(average),
                },
                {
                    label: "Peak day",
                    value:
                        peakDay !== null
                            ? `Day ${peakDay} – ${formatTons(peakValue)} tons`
                            : "—",
                },
            ];

            if (comparisonData) {
                const compareTotal = Number(comparisonData.total_production ?? 0);
                const delta = total - compareTotal;
                const deltaSign = delta >= 0 ? "+" : "−";
                const deltaAbsolute = formatTons(Math.abs(delta));
                let changeText = `${deltaSign}${deltaAbsolute} tons`;

                if (compareTotal > 0) {
                    const percentValue = (delta / compareTotal) * 100;
                    const percentSign = percentValue >= 0 ? "+" : "−";
                    const percentAbsolute = formatPercent(Math.abs(percentValue));
                    changeText = `${deltaSign}${deltaAbsolute} tons (${percentSign}${percentAbsolute}%)`;
                }

                summaryMetrics.push({
                    label: "Change vs. prior month",
                    value: changeText,
                });
            }

            productionSummaryContainer.innerHTML = summaryMetrics
                .map(
                    (metric) => `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="production-chart__metric-value">${metric.value}</span>
                        </div>
                    `,
                )
                .join("");
        };

        const showProductionSummaryError = (message) => {
            productionSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Production data</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const renderProductionPulseSummary = ({
            machineCode,
            hourlyTotals,
            values,
            effectiveHours,
            idleTotals,
            startDate,
            endDate,
        }) => {
            if (!productionPulseSummaryContainer) {
                return;
            }

            const seriesValues = Array.isArray(values) ? values : [];
            const total = seriesValues.reduce(
                (sum, value) => sum + (Number.isFinite(value) ? value : 0),
                0,
            );

            let peakLabel = null;
            let peakValue = 0;

            if (Array.isArray(hourlyTotals)) {
                hourlyTotals.forEach((entry, index) => {
                    const value = Number(seriesValues[index] ?? 0);
                    if (value > peakValue) {
                        peakValue = value;
                        peakLabel = entry?.label ?? null;
                    }
                });
            }

            const effectiveHoursValue = Number(effectiveHours ?? 0);
            const average = effectiveHoursValue > 0 ? total / effectiveHoursValue : 0;
            const idleHours = Number(idleTotals?.idle_hours ?? 0);

            const summaryMetrics = [
                {
                    label: "Date range",
                    value: formatDateRangeLabel(startDate, endDate),
                },
                {
                    label: "Total Production",
                    value: `${formatTons(total)} tons`,
                },
                {
                    label: "Average tons/effective hour",
                    value: `${formatTons(average)} tons`,
                },
                {
                    label: "Peak hour",
                    value: peakLabel ? `${peakLabel} – ${formatTons(peakValue)} tons` : "—",
                },
                {
                    label: "Total Effective Hours",
                    value: `${formatHours(effectiveHoursValue)} hours`,
                },
                {
                    label: "Total Idle Hours",
                    value: `${formatHours(idleHours)} hours`,
                },
            ];

            productionPulseSummaryContainer.innerHTML = summaryMetrics
                .map(
                    (metric) => `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="production-chart__metric-value">${metric.value}</span>
                        </div>
                    `,
                )
                .join("");
        };

        const showProductionPulseSummaryError = (message) => {
            if (!productionPulseSummaryContainer) {
                return;
            }
            if (productionPulseMachineSelect) {
                productionPulseMachineSelect.innerHTML = "";
                productionPulseMachineSelect.disabled = true;
            }
            productionPulseSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Machine pulse</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const getPreviousPeriodKey = (periodKey) => {
            if (!periodKey) {
                return null;
            }
            const [yearStr, monthStr] = periodKey.split("-");
            const year = Number(yearStr);
            const month = Number(monthStr);
            if (!Number.isFinite(year) || !Number.isFinite(month)) {
                return null;
            }
            const date = new Date(year, month - 1, 1);
            date.setMonth(date.getMonth() - 1);
            const previousYear = date.getFullYear();
            const previousMonth = String(date.getMonth() + 1).padStart(2, "0");
            return `${previousYear}-${previousMonth}`;
        };

        const fetchProductionMonthlySummary = async (periodKey) => {
            if (!periodKey) {
                return null;
            }

            if (productionPeriodCache.has(periodKey)) {
                return productionPeriodCache.get(periodKey);
            }

            const params = new URLSearchParams({ period: periodKey });

            const response = await fetch(`/api/production/monthly/summary?${params.toString()}`, {
                headers: authHeaders,
            });

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load production data.");
            }

            const data = await response.json();
            productionPeriodCache.set(periodKey, data);
            return data;
        };

        const buildProductionDataset = async (periodKey, includePrevious = false) => {
            const periodData = await fetchProductionMonthlySummary(periodKey);
            if (!periodData) {
                return null;
            }

            const labels = periodData.daily_totals.map((item) => item.day);
            const datasets = MACHINE_SERIES.map((series, index, array) => {
                const data = periodData.daily_totals.map((item) => {
                    const value = Number(item?.[series.field] ?? 0);
                    return Number.isFinite(value) ? value : 0;
                });

                const isFirst = index === 0;
                const isLast = index === array.length - 1;

                return {
                    label: series.label,
                    data,
                    backgroundColor: series.backgroundColor,
                    borderColor: series.borderColor,
                    borderWidth: 1,
                    stack: "current",
                    maxBarThickness: 18,
                    borderSkipped: false,
                    borderRadius: {
                        topLeft: isLast ? 6 : 0,
                        topRight: isLast ? 6 : 0,
                        bottomLeft: isFirst ? 6 : 0,
                        bottomRight: isFirst ? 6 : 0,
                    },
                    order: 1,
                };
            });

            let comparisonData = null;

            if (includePrevious) {
                const previousKey = getPreviousPeriodKey(periodKey);
                if (previousKey) {
                    const previousPeriod = await fetchProductionMonthlySummary(previousKey);
                    if (previousPeriod) {
                        comparisonData = previousPeriod;
                        const totalsByDay = new Map(
                            previousPeriod.daily_totals.map((item) => [item.day, item.total_tons]),
                        );
                        const comparisonValues = labels.map((day) => {
                            return totalsByDay.has(day) ? totalsByDay.get(day) : null;
                        });
                        datasets.push({
                            label: `${previousPeriod.label} total`,
                            data: comparisonValues,
                            type: "line",
                            borderColor: "rgba(148, 163, 184, 0.9)",
                            backgroundColor: "rgba(148, 163, 184, 0.35)",
                            borderWidth: 2,
                            tension: 0.3,
                            spanGaps: true,
                            fill: false,
                            pointRadius: 0,
                            showInLegend: false,
                            order: 99,
                        });
                    }
                }
            }

            renderProductionSummary(periodData, comparisonData);
            return { labels, datasets };
        };

        const fetchProductionPulseSummary = async (periodKey) => {
            const range = getSelectedPulseRange();
            const cacheKey = getPulseRangeCacheKey(range) || periodKey;

            if (!cacheKey) {
                return null;
            }

            if (productionPulsePeriodCache.has(cacheKey)) {
                return productionPulsePeriodCache.get(cacheKey);
            }

            const params = new URLSearchParams();
            if (periodKey) {
                params.set("period", periodKey);
            }
            if (range?.startDate) {
                params.set("start_date", range.startDate);
            }
            if (range?.endDate) {
                params.set("end_date", range.endDate);
            }

            const response = await fetch(`/api/production/monthly/hourly-pulse?${params.toString()}`, {
                headers: authHeaders,
            });

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load machine pulse data.");
            }

            const data = await response.json();
            productionPulsePeriodCache.set(cacheKey, data);
            return data;
        };

        const fetchIdleSummaryForPeriod = async (periodKey) => {
            if (!periodKey) {
                return null;
            }

            if (idleSummaryPeriodCache.has(periodKey)) {
                return idleSummaryPeriodCache.get(periodKey);
            }

            const params = new URLSearchParams({ period: periodKey, shape: "ui" });
            const response = await fetch(`/api/production/monthly/idle-summary?${params.toString()}`, {
                headers: authHeaders,
            });

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load idle summary data.");
            }

            const data = await response.json();
            idleSummaryPeriodCache.set(periodKey, data);
            return data;
        };

        const fetchIdleSecondaryPareto = async (periodKey) => {
            if (!periodKey) {
                return null;
            }

            if (idleParetoPeriodCache.has(periodKey)) {
                return idleParetoPeriodCache.get(periodKey);
            }

            const params = new URLSearchParams({ period: periodKey });
            const response = await fetch(
                `/api/production/monthly/idle-secondary-pareto?${params.toString()}`,
                { headers: authHeaders },
            );

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load secondary idle reasons.");
            }

            const data = await response.json();
            idleParetoPeriodCache.set(periodKey, data);
            return data;
        };

        const buildProductionPulseDataset = async (periodKey) => {
            const range = getSelectedPulseRange();
            if (!range) {
                return null;
            }

            const periodData = await fetchProductionPulseSummary(periodKey);
            if (!periodData) {
                return null;
            }

            const machineCodes = Array.isArray(periodData.machine_codes)
                ? periodData.machine_codes.map((code) => normalizeMachineCode(code))
                : [];
            const machineCode = resolvePulseMachineSelection(machineCodes);
            if (!machineCode) {
                return null;
            }

            const machineField = getMachineFieldName(machineCode);
            if (!machineField) {
                return null;
            }

            const hourlyTotals = Array.isArray(periodData.hourly_totals)
                ? periodData.hourly_totals
                : [];

            const labels = hourlyTotals.map((item) => {
                if (item.label) {
                    return item.label;
                }
                const day = String(item.day ?? "").padStart(2, "0");
                const hour = String(item.hour ?? "").padStart(2, "0");
                return `Day ${day} – ${hour}:00`;
            });

            const values = hourlyTotals.map((item) => {
                const value = Number(item?.[machineField] ?? 0);
                return Number.isFinite(value) ? value : 0;
            });

            const machineSeries = getPulseMachineSeriesForCode(machineCode) || DEFAULT_PULSE_MACHINE_STYLE;

            let idleTotals = null;
            try {
                const idleSummary = await fetchIdleSummaryForPeriod(periodKey);
                if (idleSummary?.totals) {
                    const totalsEntry = idleSummary.totals[machineCode];
                    if (totalsEntry) {
                        idleTotals = totalsEntry;
                    }
                }
            } catch (error) {
                console.error(error);
            }

            const effectiveHours = Number(
                periodData?.effective_hours?.[machineCode] ?? 0,
            );

            const startDate = periodData?.start_date ?? range.startDate ?? null;
            const endDate = periodData?.end_date ?? range.endDate ?? null;

            renderProductionPulseSummary({
                machineCode,
                hourlyTotals,
                values,
                effectiveHours,
                idleTotals,
                startDate,
                endDate,
            });

            const dataset = {
                label: machineCode,
                data: values,
                borderColor: machineSeries.borderColor,
                backgroundColor: machineSeries.backgroundColor,
                borderWidth: 2,
                pointRadius: 0,
                pointHoverRadius: 3,
                tension: 0.25,
                fill: false,
            };

            return { labels, datasets: [dataset], hourlyTotals };
        };

        const buildProductionPulseChart = async () => {
            if (!productionPulseSummaryContainer || !productionPulseChartCanvas) {
                return;
            }

            const range = getSelectedPulseRange();
            if (!range) {
                showProductionPulseSummaryError("Select a valid date range.");
                return;
            }

            productionPulseSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Loading</span>
                    <span class="production-chart__metric-value">…</span>
                </div>
            `;
            if (productionPulseMachineSelect) {
                productionPulseMachineSelect.disabled = true;
            }

            try {
                const periodKey = getSelectedPeriodKey();
                const dataset = await buildProductionPulseDataset(periodKey);
                if (!dataset) {
                    showProductionPulseSummaryError("No pulse data available.");
                    return;
                }

                if (window.productionPulseChartInstance) {
                    window.productionPulseChartInstance.data.labels = dataset.labels;
                    window.productionPulseChartInstance.data.datasets = dataset.datasets;
                    window.productionPulseChartInstance.$hourlyTotals = dataset.hourlyTotals;
                    window.productionPulseChartInstance.update();
                    return;
                }

                window.productionPulseChartInstance = new Chart(productionPulseChartCanvas, {
                    type: "line",
                    data: {
                        labels: dataset.labels,
                        datasets: dataset.datasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: "Hour of month",
                                },
                                grid: {
                                    display: false,
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxTicksLimit: 31,
                                },
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Tons per hour",
                                },
                                ticks: {
                                    callback: (value) => formatTons(value),
                                },
                            },
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        elements: {
                            point: {
                                radius: 0,
                                hoverRadius: 3,
                            },
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    usePointStyle: true,
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    title: (contexts) => {
                                        if (!Array.isArray(contexts) || contexts.length === 0) {
                                            return "";
                                        }
                                        return contexts[0].label || "";
                                    },
                                    label: (context) => {
                                        const label = context.dataset.label || "";
                                        const value = Number(context.parsed.y ?? 0);
                                        return `${label}: ${formatTons(value)} tons`;
                                    },
                                    footer: (contexts) => {
                                        if (!Array.isArray(contexts) || contexts.length === 0) {
                                            return "";
                                        }
                                        const value = Number(contexts[0]?.parsed.y ?? 0);
                                        return `Machine total: ${formatTons(value)} tons`;
                                    },
                                },
                            },
                        },
                    },
                });
                window.productionPulseChartInstance.$hourlyTotals = dataset.hourlyTotals;
            } catch (error) {
                console.error(error);
                showProductionPulseSummaryError("Unable to load machine pulse data.");
            }
        };

        const renderIdleParetoSummary = (periodData) => {
            if (!idleParetoSummaryContainer) {
                return;
            }

            const totalHours = Number(periodData?.total_idle_hours ?? 0);
            const reasons = Array.isArray(periodData?.reasons) ? periodData.reasons : [];

            const positiveReasons = reasons.filter(
                (item) => Number(item?.total_idle_hours ?? 0) > 0,
            );
            const topReason = positiveReasons[0] || reasons[0] || null;
            const topHours = Number(topReason?.total_idle_hours ?? 0);
            const topLabel = topReason?.label ?? "—";
            const topPercent = totalHours > 0 ? (topHours / totalHours) * 100 : 0;

            if (!reasons.length || totalHours <= 0) {
                idleParetoSummaryContainer.innerHTML = `
                    <div class="production-chart__metric">
                        <span class="production-chart__metric-label">Idle breakdown</span>
                        <span class="production-chart__metric-value">No secondary idle reasons captured.</span>
                    </div>
                `;
                return;
            }

            let cumulativeHours = 0;
            let reasonsForEighty = 0;
            const threshold = totalHours * 0.8;
            positiveReasons.forEach((reason) => {
                if (reasonsForEighty > 0 && cumulativeHours >= threshold) {
                    return;
                }
                const value = Number(reason?.total_idle_hours ?? 0);
                if (!Number.isFinite(value) || value <= 0) {
                    return;
                }
                cumulativeHours += value;
                reasonsForEighty += 1;
            });

            if (totalHours <= 0) {
                reasonsForEighty = 0;
            } else if (reasonsForEighty === 0) {
                reasonsForEighty = positiveReasons.length || 0;
            }

            const metrics = [
                {
                    label: "Total captured idle",
                    value: `${formatHours(totalHours)} h`,
                },
                {
                    label: "Top secondary reason",
                    value: `${topLabel} (${formatHours(topHours)} h, ${formatPercent(topPercent)}%)`,
                },
                {
                    label: "Reasons covering 80%",
                    value:
                        reasonsForEighty > 0
                            ? `${reasonsForEighty} ${reasonsForEighty === 1 ? "reason" : "reasons"}`
                            : "—",
                },
            ];

            idleParetoSummaryContainer.innerHTML = metrics
                .map(
                    (metric) => `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="production-chart__metric-value">${metric.value}</span>
                        </div>
                    `,
                )
                .join("");
        };

        const showIdleParetoSummaryError = (message) => {
            if (!idleParetoSummaryContainer) {
                return;
            }
            idleParetoSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Idle breakdown</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const buildIdleParetoDataset = async (periodKey) => {
            const periodData = await fetchIdleSecondaryPareto(periodKey);
            if (!periodData) {
                return null;
            }

            renderIdleParetoSummary(periodData);

            const reasons = Array.isArray(periodData.reasons) ? periodData.reasons : [];

            const machineCodes = (() => {
                const seen = new Set();
                const codes = [];

                const append = (code) => {
                    const normalized = normalizeMachineCode(code);
                    if (!normalized || seen.has(normalized)) {
                        return;
                    }
                    seen.add(normalized);
                    codes.push(normalized);
                };

                if (Array.isArray(periodData.machine_codes)) {
                    periodData.machine_codes.forEach(append);
                }

                if (codes.length === 0) {
                    reasons.forEach((reason) => {
                        const machines = reason?.machines;
                        if (!machines || typeof machines !== "object") {
                            return;
                        }
                        Object.keys(machines).forEach(append);
                    });
                }

                return codes;
            })();

            if (!reasons.length || machineCodes.length === 0) {
                return {
                    labels: [],
                    datasets: [],
                    reasonTotals: [],
                    totalIdleHours: Number(periodData?.total_idle_hours ?? 0) || 0,
                };
            }

            const labels = reasons.map((item) => item?.label || "Unspecified");
            const reasonTotals = reasons.map((item) => {
                const value = Number(item?.total_idle_hours ?? 0);
                return Number.isFinite(value) ? value : 0;
            });

            const barDatasets = machineCodes.map((code) => {
                const style = getMachineStackStyleForCode(code);
                const values = reasons.map((item) => {
                    const rawValue = Number(item?.machines?.[code] ?? 0);
                    return Number.isFinite(rawValue) ? rawValue : 0;
                });

                return {
                    label: code,
                    data: values,
                    backgroundColor: style.backgroundColor,
                    borderColor: style.borderColor,
                    borderWidth: 1,
                    stack: "idle",
                    maxBarThickness: 22,
                    borderSkipped: false,
                    order: 1,
                };
            });

            const totalIdleHours = reasonTotals.reduce(
                (sum, value) => sum + (Number.isFinite(value) ? value : 0),
                0,
            );

            const cumulativePercentages = [];
            let running = 0;
            reasonTotals.forEach((value) => {
                running += Number.isFinite(value) ? value : 0;
                const percent = totalIdleHours > 0 ? (running / totalIdleHours) * 100 : 0;
                cumulativePercentages.push(Number.isFinite(percent) ? Number(percent.toFixed(2)) : 0);
            });

            const paretoDataset = {
                label: "Cumulative %",
                type: "line",
                data: cumulativePercentages,
                yAxisID: "y1",
                borderColor: "rgb(234, 179, 8)",
                backgroundColor: "rgba(234, 179, 8, 0.2)",
                borderWidth: 2,
                pointRadius: 3,
                pointHoverRadius: 4,
                tension: 0.25,
                fill: false,
                order: 0,
            };

            return {
                labels,
                datasets: [...barDatasets, paretoDataset],
                reasonTotals,
                totalIdleHours,
            };
        };

        const buildIdleParetoChart = async () => {
            if (!idleParetoSummaryContainer || !idleParetoChartCanvas) {
                return;
            }

            idleParetoSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Loading</span>
                    <span class="production-chart__metric-value">…</span>
                </div>
            `;

            try {
                const periodKey = getSelectedPeriodKey();
                const dataset = await buildIdleParetoDataset(periodKey);
                if (!dataset) {
                    showIdleParetoSummaryError("Unable to load idle breakdown.");
                    return;
                }

                const hasBarData = dataset.datasets.some(
                    (item) =>
                        item.stack === "idle" &&
                        Array.isArray(item.data) &&
                        item.data.some((value) => Number(value) > 0),
                );

                if (!hasBarData) {
                    if (window.idleParetoChartInstance) {
                        window.idleParetoChartInstance.data.labels = [];
                        window.idleParetoChartInstance.data.datasets = [];
                        window.idleParetoChartInstance.$reasonTotals = dataset.reasonTotals || [];
                        window.idleParetoChartInstance.$totalIdleHours = dataset.totalIdleHours || 0;
                        window.idleParetoChartInstance.update();
                    }
                    return;
                }

                if (window.idleParetoChartInstance) {
                    window.idleParetoChartInstance.data.labels = dataset.labels;
                    window.idleParetoChartInstance.data.datasets = dataset.datasets;
                    window.idleParetoChartInstance.$reasonTotals = dataset.reasonTotals;
                    window.idleParetoChartInstance.$totalIdleHours = dataset.totalIdleHours;
                    window.idleParetoChartInstance.update();
                    return;
                }

                window.idleParetoChartInstance = new Chart(idleParetoChartCanvas, {
                    type: "bar",
                    data: {
                        labels: dataset.labels,
                        datasets: dataset.datasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: "Secondary idle reason",
                                },
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 12,
                                },
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Idle hours",
                                },
                                ticks: {
                                    callback: (value) => `${formatHours(value)} h`,
                                },
                            },
                            y1: {
                                beginAtZero: true,
                                position: "right",
                                suggestedMax: 100,
                                title: {
                                    display: true,
                                    text: "Cumulative %",
                                },
                                ticks: {
                                    callback: (value) => `${formatPercent(value)}%`,
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    usePointStyle: true,
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        if (context.dataset.type === "line") {
                                            const percentValue = Number(context.parsed.y ?? 0);
                                            return `${context.dataset.label}: ${formatPercent(percentValue)}%`;
                                        }
                                        const value = Number(context.parsed.y ?? 0);
                                        return `${context.dataset.label}: ${formatHours(value)} h`;
                                    },
                                    footer: (contexts) => {
                                        if (!Array.isArray(contexts) || contexts.length === 0) {
                                            return "";
                                        }
                                        const chart = contexts[0]?.chart;
                                        const dataIndex = contexts[0]?.dataIndex;
                                        if (!chart || !Number.isInteger(dataIndex)) {
                                            return "";
                                        }
                                        const totals = chart.$reasonTotals || [];
                                        const total = Number(totals[dataIndex] ?? 0);
                                        if (!Number.isFinite(total)) {
                                            return "";
                                        }
                                        const totalIdle = Number(chart.$totalIdleHours ?? 0);
                                        const lines = [`Total: ${formatHours(total)} h`];
                                        if (totalIdle > 0) {
                                            const share = (total / totalIdle) * 100;
                                            lines.push(`Share: ${formatPercent(share)}%`);
                                        }
                                        return lines.join("\n");
                                    },
                                },
                            },
                        },
                    },
                });

                window.idleParetoChartInstance.$reasonTotals = dataset.reasonTotals;
                window.idleParetoChartInstance.$totalIdleHours = dataset.totalIdleHours;
            } catch (error) {
                console.error(error);
                showIdleParetoSummaryError("Unable to load idle breakdown.");
            }
        };

        const buildProductionChart = async () => {
            productionSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Loading</span>
                    <span class="production-chart__metric-value">…</span>
                </div>
            `;

            try {
                const periodKey = getSelectedPeriodKey();
                const includePrevious = compareToggle.getAttribute("aria-pressed") === "true";
                const dataset = await buildProductionDataset(periodKey, includePrevious);
                if (!dataset) {
                    showProductionSummaryError("No production data available.");
                    return;
                }

                if (window.productionChartInstance) {
                    window.productionChartInstance.data.labels = dataset.labels;
                    window.productionChartInstance.data.datasets = dataset.datasets;
                    window.productionChartInstance.update();
                    return;
                }

                window.productionChartInstance = new Chart(productionChartCanvas, {
                    type: "bar",
                    data: dataset,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: "Day of month",
                                },
                                grid: {
                                    display: false,
                                },
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 15,
                                },
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Tons produced",
                                },
                                ticks: {
                                    callback: (value) => formatTons(value),
                                },
                            },
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    usePointStyle: true,
                                    filter: (legendItem, chart) => {
                                        const dataset = chart?.data?.datasets?.[legendItem.datasetIndex];
                                        if (dataset && Object.prototype.hasOwnProperty.call(dataset, "showInLegend")) {
                                            return dataset.showInLegend !== false;
                                        }
                                        return true;
                                    },
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const label = context.dataset.label || "";
                                        const value = Number(context.parsed.y ?? 0);
                                        return `${label}: ${formatTons(value)} tons`;
                                    },
                                    footer: (contexts) => {
                                        if (!Array.isArray(contexts) || contexts.length === 0) {
                                            return "";
                                        }
                                        const stackContexts = contexts.filter(
                                            (item) => item.dataset?.stack === "current",
                                        );
                                        if (stackContexts.length === 0) {
                                            return "";
                                        }
                                        const total = stackContexts.reduce(
                                            (sum, item) => sum + Number(item.parsed.y ?? 0),
                                            0,
                                        );
                                        return `Total: ${formatTons(total)} tons`;
                                    },
                                },
                            },
                        },
                    },
                });
            } catch (error) {
                console.error(error);
                showProductionSummaryError("Unable to load production data.");
            }
        };

        const renderSalesSummary = (periodData) => {
            if (!salesSummaryContainer) {
                return;
            }

            const total = Number(periodData?.total_sales ?? 0);
            const totalQuantity = Number(periodData?.total_quantity_tons ?? 0);
            const average = Number(periodData?.average_day_sales ?? 0);
            const averageQuantity = Number(periodData?.average_day_quantity_tons ?? 0);
            const peakDay = periodData?.peak?.day ?? null;
            const peakValue = Number(periodData?.peak?.total_value ?? 0);
            const peakQuantity = Number(periodData?.peak?.total_quantity_tons ?? 0);
            const topCustomerName = periodData?.top_customer?.name ?? null;
            const topCustomerValue = Number(periodData?.top_customer?.sales_value ?? 0);
            const topCustomerQuantity = Number(periodData?.top_customer?.quantity_tons ?? 0);

            const summaryMetrics = [
                {
                    label: "Total Sales",
                    quantityText: `Qty: ${formatTons(totalQuantity)} tons`,
                    valueText: formatCurrency(total),
                },
                {
                    label: "Average Daily Sales",
                    quantityText: `Qty: ${formatTons(averageQuantity)} tons`,
                    valueText: formatCurrency(average),
                },
                {
                    label: "Peak day",
                    quantityText:
                        peakDay !== null
                            ? `Day ${peakDay} – Qty: ${formatTons(peakQuantity)} tons`
                            : "Qty: —",
                    valueText: peakDay !== null ? formatCurrency(peakValue) : "—",
                },
            ];

            if (topCustomerName) {
                summaryMetrics.push({
                    label: "Top customer",
                    quantityText: `${topCustomerName} – Qty: ${formatTons(topCustomerQuantity)} tons`,
                    valueText: formatCurrency(topCustomerValue),
                });
            }

            salesSummaryContainer.innerHTML = summaryMetrics
                .map(
                    (metric) => `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="production-chart__metric-value">${metric.quantityText ?? metric.valueText}</span>
                            <span class="production-chart__metric-value production-chart__metric-value--currency">${
                                metric.valueText ?? metric.value
                            }</span>
                        </div>
                    `,
                )
                .join("");
        };

        const renderUnitEconomicsSummary = (periodData) => {
            if (!unitEconomicsSummaryContainer) {
                return;
            }

            const summary = periodData?.summary ?? {};
            const daysWithSales = Number(summary?.days_with_sales ?? summary?.days_with_production ?? 0);

            if (!summary || daysWithSales === 0) {
                unitEconomicsSummaryContainer.innerHTML = `
                    <div class="production-chart__metric">
                        <span class="production-chart__metric-label">Unit economics</span>
                        <span class="production-chart__metric-value">No sales in the selected period.</span>
                    </div>
                `;
                return;
            }

            const avgSellingPrice = Number(
                summary?.average_selling_price ?? summary?.weighted_average_selling_price ?? 0,
            );
            const avgContribution = Number(
                summary?.average_contribution ?? summary?.weighted_average_contribution ?? 0,
            );
            const contributionMargin = Number(
                summary?.contribution_margin_percent ?? summary?.weighted_average_contribution_margin ?? 0,
            );

            const metrics = [
                {
                    label: "Days with sales",
                    valueText: String(daysWithSales),
                },
                {
                    label: "Avg selling price",
                    valueText: formatCurrencyPerKg(avgSellingPrice),
                },
                {
                    label: "Avg contribution",
                    valueText: formatCurrencyPerKg(avgContribution),
                },
            ];

            if (Number.isFinite(contributionMargin)) {
                metrics.push({
                    label: "Contribution margin",
                    valueText: `${formatPercent(contributionMargin)}%`,
                });
            }

            unitEconomicsSummaryContainer.innerHTML = metrics
                .map(
                    (metric) => `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="production-chart__metric-value">${metric.valueText}</span>
                        </div>
                    `,
                )
                .join("");
        };

        const showUnitEconomicsSummaryError = (message) => {
            if (!unitEconomicsSummaryContainer) {
                return;
            }
            unitEconomicsSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Unit economics</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const hideUnitEconomicsChartMessage = () => {
            if (unitEconomicsChartEmptyMessage) {
                unitEconomicsChartEmptyMessage.hidden = true;
            }
        };

        const showUnitEconomicsChartMessage = (message) => {
            if (unitEconomicsChartEmptyMessage) {
                unitEconomicsChartEmptyMessage.textContent = message;
                unitEconomicsChartEmptyMessage.hidden = false;
            }
        };

        const hideBreakevenChartMessage = () => {
            if (breakevenChartEmptyMessage) {
                breakevenChartEmptyMessage.hidden = true;
            }
        };

        const showBreakevenChartMessage = (message) => {
            if (breakevenChartEmptyMessage) {
                breakevenChartEmptyMessage.textContent = message;
                breakevenChartEmptyMessage.hidden = false;
            }
        };

        const destroyBreakevenChart = () => {
            if (window.breakevenChartInstance) {
                window.breakevenChartInstance.destroy();
                window.breakevenChartInstance = null;
            }
        };

        const fetchUnitEconomicsDailyStack = async (range) => {
            const cacheKey = buildUnitEconomicsRangeKey(range);
            if (!cacheKey) {
                return null;
            }

            if (unitEconomicsPeriodCache.has(cacheKey)) {
                return unitEconomicsPeriodCache.get(cacheKey);
            }

            const params = new URLSearchParams({
                start_date: range.startDate,
                end_date: range.endDate,
            });
            const response = await fetch(
                `/api/reports/production/unit-economics?${params.toString()}`,
                { headers: authHeaders },
            );

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load unit economics data.");
            }

            const data = await response.json();
            unitEconomicsPeriodCache.set(cacheKey, data);
            return data;
        };

        const buildBreakevenSeries = (periodData) => {
            const startIso = periodData?.start_date ?? null;
            const endIso = periodData?.end_date ?? null;
            const startDate = parseIsoDate(startIso);
            const endDate = parseIsoDate(endIso);

            if (!startDate || !endDate || startDate > endDate) {
                return {
                    labels: [],
                    isoLabels: [],
                    cumulativeProfitValues: [],
                    hasRenderableData: false,
                };
            }

            const normalizedStart = new Date(startDate.getTime());
            normalizedStart.setHours(0, 0, 0, 0);
            const normalizedEnd = new Date(endDate.getTime());
            normalizedEnd.setHours(0, 0, 0, 0);

            const dailyLookup = new Map();
            const dailyEntries = Array.isArray(periodData?.daily) ? periodData.daily : [];
            for (const entry of dailyEntries) {
                const iso = entry?.date ?? null;
                if (!iso) {
                    continue;
                }
                dailyLookup.set(iso, entry);
            }

            const labels = [];
            const isoLabels = [];
            const cumulativeProfitValues = [];

            let cumulativeContribution = 0;
            const cursor = new Date(normalizedStart.getTime());

            while (cursor.getTime() <= normalizedEnd.getTime()) {
                const iso = toIsoDate(cursor);
                isoLabels.push(iso);
                labels.push(formatChartDateLabel(iso) || iso);

                const entry = dailyLookup.get(iso) ?? null;
                const unitContribution = Number(entry?.unit_contribution ?? 0);
                const salesQuantityKg = Number(entry?.sales_quantity_kg ?? 0);

                let dailyContribution = 0;
                if (Number.isFinite(unitContribution) && Number.isFinite(salesQuantityKg)) {
                    dailyContribution = unitContribution * salesQuantityKg;
                }

                cumulativeContribution += dailyContribution;
                const cumulativeProfit = cumulativeContribution - BREAKEVEN_FIXED_COST;
                cumulativeProfitValues.push(cumulativeProfit);

                cursor.setDate(cursor.getDate() + 1);
            }

            return {
                labels,
                isoLabels,
                cumulativeProfitValues,
                hasRenderableData: labels.length > 0,
            };
        };

        const buildUnitEconomicsDataset = async (range) => {
            const periodData = await fetchUnitEconomicsDailyStack(range);
            if (!periodData) {
                return null;
            }

            const summary = periodData?.summary ?? {};
            const daysWithSales = Number(
                summary?.days_with_sales ?? summary?.days_with_production ?? 0,
            );

            const breakevenSeries = buildBreakevenSeries(periodData);

            if (!summary || daysWithSales === 0) {
                return { sourceData: periodData, hasRenderableData: false, breakeven: breakevenSeries };
            }

            const averageMaterialCost = Number(summary?.average_material_cost ?? 0);
            const averageLaborCost = Number(summary?.average_labor_cost ?? 0);
            const averageOtherCost = Number(summary?.average_other_variable_cost ?? 0);
            const averageContribution = Number(summary?.average_contribution ?? 0);
            const averageSellingPrice = Number(summary?.average_selling_price ?? 0);

            const segments = [
                {
                    key: "material",
                    label: "Unit Material Cost (Rs/kg)",
                    value: averageMaterialCost,
                    backgroundColor: UNIT_ECONOMICS_COLORS.material.background,
                    borderColor: UNIT_ECONOMICS_COLORS.material.border,
                },
                {
                    key: "labor",
                    label: "Unit Labor Cost (Rs/kg)",
                    value: averageLaborCost,
                    backgroundColor: UNIT_ECONOMICS_COLORS.labor.background,
                    borderColor: UNIT_ECONOMICS_COLORS.labor.border,
                },
                {
                    key: "other",
                    label: "Unit Other Variable Cost (Rs/kg)",
                    value: averageOtherCost,
                    backgroundColor: UNIT_ECONOMICS_COLORS.other.background,
                    borderColor: UNIT_ECONOMICS_COLORS.other.border,
                },
                {
                    key: "contribution",
                    label: "Unit Contribution (Rs/kg)",
                    value: averageContribution,
                    backgroundColor:
                        averageContribution >= 0
                            ? UNIT_ECONOMICS_COLORS.contributionPositive.background
                            : UNIT_ECONOMICS_COLORS.contributionNegative.background,
                    borderColor:
                        averageContribution >= 0
                            ? UNIT_ECONOMICS_COLORS.contributionPositive.border
                            : UNIT_ECONOMICS_COLORS.contributionNegative.border,
                },
            ];

            const normalizedSegments = segments.map((segment) => {
                const numericValue = Number(segment.value);
                const value = Number.isFinite(numericValue) ? numericValue : 0;
                const chartValue = Math.abs(value);
                return { ...segment, value, chartValue };
            });

            const hasRenderableData = normalizedSegments.some((segment) => segment.chartValue > 0);

            return {
                labels: normalizedSegments.map((segment) => segment.label),
                datasets: [
                    {
                        label: "Average unit mix (Rs/kg)",
                        data: normalizedSegments.map((segment) => segment.chartValue),
                        backgroundColor: normalizedSegments.map(
                            (segment) => segment.backgroundColor,
                        ),
                        borderColor: normalizedSegments.map((segment) => segment.borderColor),
                        borderWidth: 1,
                        segmentActualValues: normalizedSegments.map((segment) => segment.value),
                    },
                ],
                hasRenderableData,
                averageSellingPrice,
                segments: normalizedSegments,
                sourceData: periodData,
                breakeven: breakevenSeries,
            };
        };

        const renderBreakevenChart = (breakevenSeries) => {
            if (!breakevenChartCanvas) {
                return;
            }

            if (!breakevenSeries || !breakevenSeries.hasRenderableData) {
                destroyBreakevenChart();
                showBreakevenChartMessage("No breakeven data for the selected period.");
                return;
            }

            if (!ensureChartJsAvailable()) {
                return;
            }

            hideBreakevenChartMessage();

            const profitData = breakevenSeries.cumulativeProfitValues;
            const profitBackgroundColors = profitData.map((value) =>
                value >= 0
                    ? BREAKEVEN_DATASET_COLORS.profitPositive.background
                    : BREAKEVEN_DATASET_COLORS.profitNegative.background,
            );
            const profitBorderColors = profitData.map((value) =>
                value >= 0
                    ? BREAKEVEN_DATASET_COLORS.profitPositive.border
                    : BREAKEVEN_DATASET_COLORS.profitNegative.border,
            );

            if (window.breakevenChartInstance) {
                const chart = window.breakevenChartInstance;
                chart.data.labels = breakevenSeries.labels;

                let profitDataset = null;
                if (Array.isArray(chart.data.datasets) && chart.data.datasets.length >= 1) {
                    profitDataset = chart.data.datasets[0];
                }

                if (!profitDataset) {
                    profitDataset = {};
                }

                Object.assign(profitDataset, {
                    label: "Cumulative Profit",
                    data: profitData,
                    backgroundColor: profitBackgroundColors,
                    borderColor: profitBorderColors,
                    borderWidth: 1,
                    barPercentage: 0.8,
                    categoryPercentage: 0.85,
                    maxBarThickness: 32,
                });

                chart.data.datasets = [profitDataset];

                if (chart.options?.scales) {
                    if (chart.options.scales.x) {
                        chart.options.scales.x.stacked = false;
                    }
                    if (chart.options.scales.y) {
                        chart.options.scales.y.stacked = false;
                    }
                }

                chart.update();
            } else {
                window.breakevenChartInstance = new Chart(breakevenChartCanvas, {
                    type: "bar",
                    data: {
                        labels: breakevenSeries.labels,
                        datasets: [
                            {
                                label: "Cumulative Profit",
                                data: profitData,
                                backgroundColor: profitBackgroundColors,
                                borderColor: profitBorderColors,
                                borderWidth: 1,
                                barPercentage: 0.8,
                                categoryPercentage: 0.85,
                                maxBarThickness: 32,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                stacked: false,
                                title: {
                                    display: true,
                                    text: "Date",
                                },
                                grid: {
                                    display: false,
                                },
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 14,
                                },
                            },
                            y: {
                                stacked: false,
                                title: {
                                    display: true,
                                    text: "Profit (Rs)",
                                },
                                ticks: {
                                    callback: (value) => formatCurrency(value),
                                },
                                grid: {
                                    color: (context) =>
                                        context.tick.value === 0
                                            ? "rgba(15, 23, 42, 0.55)"
                                            : "rgba(226, 232, 240, 0.45)",
                                    lineWidth: (context) => (context.tick.value === 0 ? 1.4 : 0.8),
                                },
                            },
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: "top",
                                labels: {
                                    usePointStyle: true,
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    title: (items) => {
                                        if (!Array.isArray(items) || items.length === 0) {
                                            return "";
                                        }
                                        const index = items[0].dataIndex;
                                        const chart = items[0].chart;
                                        const iso = chart?.$breakevenMeta?.isoLabels?.[index];
                                        return formatIsoDateLabel(iso) || items[0].label || "";
                                    },
                                    label: (context) => {
                                        const label = context.dataset?.label ?? "";
                                        const value = Number(context.parsed.y ?? 0);
                                        return `${label}: ${formatCurrency(value)}`;
                                    },
                                },
                            },
                        },
                    },
                });
            }

            if (window.breakevenChartInstance) {
                window.breakevenChartInstance.$breakevenMeta = {
                    isoLabels: breakevenSeries.isoLabels,
                    profits: breakevenSeries.cumulativeProfitValues,
                };
            }
        };

        const buildUnitEconomicsChart = async () => {
            if (!unitEconomicsSummaryContainer || !unitEconomicsChartCanvas) {
                return;
            }

            unitEconomicsSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Loading</span>
                    <span class="production-chart__metric-value">…</span>
                </div>
            `;

            hideUnitEconomicsChartMessage();
            hideBreakevenChartMessage();

            try {
                const selectedRange = getSelectedUnitEconomicsRange();
                if (!selectedRange) {
                    showUnitEconomicsSummaryError("Select a valid start and end date.");
                    if (window.unitEconomicsChartInstance) {
                        window.unitEconomicsChartInstance.destroy();
                        window.unitEconomicsChartInstance = null;
                    }
                    destroyBreakevenChart();
                    showUnitEconomicsChartMessage("Select a valid start and end date.");
                    showBreakevenChartMessage("Select a valid start and end date.");
                    return;
                }

                const dataset = await buildUnitEconomicsDataset(selectedRange);
                if (!dataset) {
                    showUnitEconomicsSummaryError("Unable to load unit economics data.");
                    if (window.unitEconomicsChartInstance) {
                        window.unitEconomicsChartInstance.destroy();
                        window.unitEconomicsChartInstance = null;
                    }
                    destroyBreakevenChart();
                    showUnitEconomicsChartMessage("Unable to load unit economics data.");
                    showBreakevenChartMessage("Unable to load breakeven data.");
                    return;
                }

                renderUnitEconomicsSummary(dataset.sourceData);
                renderBreakevenChart(dataset.breakeven);

                if (!dataset.hasRenderableData) {
                    if (window.unitEconomicsChartInstance) {
                        window.unitEconomicsChartInstance.destroy();
                        window.unitEconomicsChartInstance = null;
                    }
                    showUnitEconomicsChartMessage(
                        "No unit economics data for the selected period.",
                    );
                    return;
                }

                if (!ensureChartJsAvailable()) {
                    return;
                }

                if (window.unitEconomicsChartInstance) {
                    window.unitEconomicsChartInstance.destroy();
                }

                const averageSellingPrice = Number(dataset.averageSellingPrice ?? 0);

                hideUnitEconomicsChartMessage();

                window.unitEconomicsChartInstance = new Chart(unitEconomicsChartCanvas, {
                    type: "pie",
                    data: {
                        labels: dataset.labels,
                        datasets: dataset.datasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: "right",
                                labels: {
                                    usePointStyle: true,
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const label = context.label || "";
                                        const actualValues =
                                            context?.dataset?.segmentActualValues ?? [];
                                        const actualValue = actualValues[context.dataIndex];
                                        const value = Number.isFinite(actualValue)
                                            ? actualValue
                                            : Number(context.parsed ?? 0);
                                        return `${label}: ${formatCurrencyPerKg(value)}`;
                                    },
                                    footer: () => {
                                        if (!Number.isFinite(averageSellingPrice) || averageSellingPrice <= 0) {
                                            return "";
                                        }
                                        return `Avg selling price: ${formatCurrencyPerKg(
                                            averageSellingPrice,
                                        )}`;
                                    },
                                },
                            },
                        },
                    },
                });
            } catch (error) {
                console.error(error);
                showUnitEconomicsSummaryError("Unable to load unit economics data.");
                showUnitEconomicsChartMessage("Unable to load unit economics data.");
                destroyBreakevenChart();
                showBreakevenChartMessage("Unable to load breakeven data.");
                if (window.unitEconomicsChartInstance) {
                    window.unitEconomicsChartInstance.destroy();
                    window.unitEconomicsChartInstance = null;
                }
            }
        };

        const showSalesSummaryError = (message) => {
            if (!salesSummaryContainer) {
                return;
            }
            salesSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Sales data</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const fetchSalesMonthlySummary = async (periodKey) => {
            if (!periodKey) {
                return null;
            }

            if (salesPeriodCache.has(periodKey)) {
                return salesPeriodCache.get(periodKey);
            }

            const params = new URLSearchParams({ period: periodKey });
            const response = await fetch(`/api/reports/sales/monthly-summary?${params.toString()}`, {
                headers: authHeaders,
            });

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load sales data.");
            }

            const data = await response.json();
            salesPeriodCache.set(periodKey, data);
            return data;
        };

        const buildSalesDataset = async (periodKey) => {
            const periodData = await fetchSalesMonthlySummary(periodKey);
            if (!periodData) {
                return null;
            }

            const labels = periodData.daily_totals.map((item) => item.day);
            const customers = Array.isArray(periodData.customers) ? periodData.customers : [];

            const datasets = customers.map((customer, index, array) => {
                const fieldName = customer.field;
                const values = periodData.daily_totals.map((item) => {
                    const value = Number(item?.[fieldName] ?? 0);
                    return Number.isFinite(value) ? value : 0;
                });

                const colors = SALES_DATASET_COLORS[index % SALES_DATASET_COLORS.length];
                const isFirst = index === 0;
                const isLast = index === array.length - 1;

                return {
                    label: customer.name,
                    data: values,
                    backgroundColor: colors.background,
                    borderColor: colors.border,
                    borderWidth: 1,
                    stack: "sales",
                    maxBarThickness: 18,
                    borderSkipped: false,
                    borderRadius: {
                        topLeft: isLast ? 6 : 0,
                        topRight: isLast ? 6 : 0,
                        bottomLeft: isFirst ? 6 : 0,
                        bottomRight: isFirst ? 6 : 0,
                    },
                    order: 1,
                };
            });

            renderSalesSummary(periodData);
            return { labels, datasets };
        };

        const buildSalesChart = async () => {
            if (!salesSummaryContainer || !salesChartCanvas) {
                return;
            }

            salesSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Loading</span>
                    <span class="production-chart__metric-value">…</span>
                </div>
            `;

            try {
                const periodKey = getSelectedPeriodKey();
                const dataset = await buildSalesDataset(periodKey);
                if (!dataset) {
                    showSalesSummaryError("No sales data available.");
                    return;
                }

                if (window.salesChartInstance) {
                    window.salesChartInstance.data.labels = dataset.labels;
                    window.salesChartInstance.data.datasets = dataset.datasets;
                    window.salesChartInstance.update();
                    return;
                }

                window.salesChartInstance = new Chart(salesChartCanvas, {
                    type: "bar",
                    data: dataset,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: "Day of month",
                                },
                                grid: {
                                    display: false,
                                },
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 15,
                                },
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Sales value (Rs)",
                                },
                                ticks: {
                                    callback: (value) => formatCurrency(value),
                                },
                            },
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    usePointStyle: true,
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const label = context.dataset.label || "";
                                        const value = Number(context.parsed.y ?? 0);
                                        return `${label}: ${formatCurrency(value)}`;
                                    },
                                    footer: (contexts) => {
                                        if (!Array.isArray(contexts) || contexts.length === 0) {
                                            return "";
                                        }
                                        const stackContexts = contexts.filter(
                                            (item) => item.dataset?.stack === "sales",
                                        );
                                        if (stackContexts.length === 0) {
                                            return "";
                                        }
                                        const total = stackContexts.reduce(
                                            (sum, item) => sum + Number(item.parsed.y ?? 0),
                                            0,
                                        );
                                        return `Total: ${formatCurrency(total)}`;
                                    },
                                },
                            },
                        },
                    },
                });
            } catch (error) {
                console.error(error);
                showSalesSummaryError("Unable to load sales data.");
            }
        };

        const renderMaterialSummary = (periodData) => {
            if (!materialSummaryContainer) {
                return;
            }

            const totalQuantity = Number(periodData?.total_quantity_tons ?? 0);
            const averageQuantity = Number(periodData?.average_day_quantity_tons ?? 0);
            const peakDay = periodData?.peak?.day ?? null;
            const peakQuantity = Number(periodData?.peak?.total_quantity_tons ?? 0);
            const topMaterialName = periodData?.top_material?.name ?? null;
            const topMaterialQuantity = Number(periodData?.top_material?.quantity_tons ?? 0);

            const summaryMetrics = [
                {
                    label: "Total received",
                    valueText: `${formatTons(totalQuantity)} tons`,
                },
                {
                    label: "Average daily received",
                    valueText: `${formatTons(averageQuantity)} tons`,
                },
                {
                    label: "Peak day",
                    valueText:
                        peakDay !== null
                            ? `Day ${peakDay} – ${formatTons(peakQuantity)} tons`
                            : "—",
                },
            ];

            if (topMaterialName) {
                summaryMetrics.push({
                    label: "Top material",
                    valueText: `${topMaterialName} – ${formatTons(topMaterialQuantity)} tons`,
                });
            }

            materialSummaryContainer.innerHTML = summaryMetrics
                .map(
                    (metric) => `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="production-chart__metric-value">${metric.valueText}</span>
                        </div>
                    `,
                )
                .join("");
        };

        const showMaterialSummaryError = (message) => {
            if (!materialSummaryContainer) {
                return;
            }
            materialSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Material data</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const fetchMaterialMonthlySummary = async (periodKey) => {
            if (!periodKey) {
                return null;
            }

            if (materialPeriodCache.has(periodKey)) {
                return materialPeriodCache.get(periodKey);
            }

            const params = new URLSearchParams({ period: periodKey });
            const response = await fetch(
                `/api/reports/materials/monthly-summary?${params.toString()}`,
                { headers: authHeaders },
            );

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load material data.");
            }

            const data = await response.json();
            materialPeriodCache.set(periodKey, data);
            return data;
        };

        const buildMaterialDataset = async (periodKey) => {
            const periodData = await fetchMaterialMonthlySummary(periodKey);
            if (!periodData) {
                return null;
            }

            const labels = Array.isArray(periodData.daily_totals)
                ? periodData.daily_totals.map((item) => item.day)
                : [];

            const materials = Array.isArray(periodData.materials) ? periodData.materials : [];

            const datasets = materials.map((material, index, array) => {
                const values = (periodData.daily_totals || []).map((item) => {
                    const value = Number(item?.[material.field] ?? 0);
                    return Number.isFinite(value) ? value : 0;
                });

                const style = getMaterialStackStyle(material.name, index);
                const isFirst = index === 0;
                const isLast = index === array.length - 1;

                return {
                    label: material.name,
                    data: values,
                    backgroundColor: style.background,
                    borderColor: style.border,
                    borderWidth: 1,
                    stack: "materials",
                    maxBarThickness: 18,
                    borderSkipped: false,
                    borderRadius: {
                        topLeft: isLast ? 6 : 0,
                        topRight: isLast ? 6 : 0,
                        bottomLeft: isFirst ? 6 : 0,
                        bottomRight: isFirst ? 6 : 0,
                    },
                    order: 1,
                };
            });

            renderMaterialSummary(periodData);
            return { labels, datasets };
        };

        const buildMaterialChart = async () => {
            if (!materialSummaryContainer || !materialChartCanvas) {
                return;
            }

            materialSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Loading</span>
                    <span class="production-chart__metric-value">…</span>
                </div>
            `;

            try {
                const periodKey = getSelectedPeriodKey();
                const dataset = await buildMaterialDataset(periodKey);
                if (!dataset) {
                    showMaterialSummaryError("No material data available.");
                    return;
                }

                if (window.materialChartInstance) {
                    window.materialChartInstance.data.labels = dataset.labels;
                    window.materialChartInstance.data.datasets = dataset.datasets;
                    window.materialChartInstance.update();
                    return;
                }

                window.materialChartInstance = new Chart(materialChartCanvas, {
                    type: "bar",
                    data: dataset,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: "Day of month",
                                },
                                grid: {
                                    display: false,
                                },
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 15,
                                },
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Quantity (tons)",
                                },
                                ticks: {
                                    callback: (value) => `${formatTons(value)} tons`,
                                },
                            },
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    usePointStyle: true,
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const label = context.dataset.label || "";
                                        const value = Number(context.parsed.y ?? 0);
                                        return `${label}: ${formatTons(value)} tons`;
                                    },
                                    footer: (contexts) => {
                                        if (!Array.isArray(contexts) || contexts.length === 0) {
                                            return "";
                                        }
                                        const stackContexts = contexts.filter(
                                            (item) => item.dataset?.stack === "materials",
                                        );
                                        if (stackContexts.length === 0) {
                                            return "";
                                        }
                                        const total = stackContexts.reduce(
                                            (sum, item) => sum + Number(item.parsed.y ?? 0),
                                            0,
                                        );
                                        return `Total: ${formatTons(total)} tons`;
                                    },
                                },
                            },
                        },
                    },
                });
            } catch (error) {
                console.error(error);
                showMaterialSummaryError("Unable to load material data.");
            }
        };

        const renderLaborSummary = (periodData) => {
            if (!laborSummaryContainer) {
                return;
            }

            const totalCost = Number(periodData?.monthly_total ?? 0);
            const averageCost = Number(periodData?.average_work_day_cost ?? 0);
            const peakDay = periodData?.peak_day?.day ?? null;
            const peakValue = Number(periodData?.peak_day?.total_cost ?? 0);
            const topMemberName = periodData?.top_member?.name ?? null;
            const topMemberCost = Number(periodData?.top_member?.total_cost ?? 0);

            const summaryMetrics = [
                {
                    label: "Monthly labor cost",
                    value: formatCurrency(totalCost),
                },
                {
                    label: "Average per work day",
                    value: formatCurrency(averageCost),
                },
                {
                    label: "Highest cost day",
                    value:
                        peakDay !== null
                            ? `Day ${peakDay} – ${formatCurrency(peakValue)}`
                            : "—",
                },
                {
                    label: "Top contributor",
                    value:
                        topMemberName
                            ? `${topMemberName} (${formatCurrency(topMemberCost)})`
                            : "—",
                },
            ];

            laborSummaryContainer.innerHTML = summaryMetrics
                .map(
                    (metric) => `
                        <div class="production-chart__metric">
                            <span class="production-chart__metric-label">${metric.label}</span>
                            <span class="production-chart__metric-value">${metric.value}</span>
                        </div>
                    `,
                )
                .join("");
        };

        const showLaborSummaryError = (message) => {
            if (!laborSummaryContainer) {
                return;
            }
            laborSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Labor data</span>
                    <span class="production-chart__metric-value">${message}</span>
                </div>
            `;
        };

        const fetchLaborDailyCost = async (periodKey) => {
            if (!periodKey) {
                return null;
            }

            if (laborPeriodCache.has(periodKey)) {
                return laborPeriodCache.get(periodKey);
            }

            const params = new URLSearchParams({ period: periodKey });
            const response = await fetch(
                `/api/reports/labor/daily-production-cost?${params.toString()}`,
                { headers: authHeaders },
            );

            if (response.status === 401) {
                logoutButton.click();
                return null;
            }

            if (!response.ok) {
                throw new Error("Failed to load labor data.");
            }

            const data = await response.json();
            laborPeriodCache.set(periodKey, data);
            return data;
        };

        const buildLaborDataset = async (periodKey) => {
            const periodData = await fetchLaborDailyCost(periodKey);
            if (!periodData) {
                return null;
            }

            const labels = Array.isArray(periodData.daily_totals)
                ? periodData.daily_totals.map((item) => item.day)
                : [];
            const members = Array.isArray(periodData.members) ? periodData.members : [];

            if (members.length === 0 || labels.length === 0) {
                showLaborSummaryError("No labor data available.");
                return null;
            }

            const datasets = members.map((member, index, array) => {
                const values = (periodData.daily_totals || []).map((entry) => {
                    const value = Number(entry?.member_costs?.[String(member.id)] ?? 0);
                    return Number.isFinite(value) ? value : 0;
                });

                const style = LABOR_COLOR_PALETTE[index % LABOR_COLOR_PALETTE.length];
                const isFirst = index === 0;
                const isLast = index === array.length - 1;
                const labelParts = [];
                if (member?.name) {
                    labelParts.push(member.name);
                }
                if (member?.regNumber) {
                    labelParts.push(member.regNumber);
                }
                const datasetLabel =
                    labelParts.length > 0 ? labelParts.join(" · ") : `Member ${index + 1}`;

                return {
                    label: datasetLabel,
                    data: values,
                    backgroundColor: style.background,
                    borderColor: style.border,
                    borderWidth: 1,
                    stack: "labor",
                    maxBarThickness: 18,
                    borderSkipped: false,
                    borderRadius: {
                        topLeft: isLast ? 6 : 0,
                        topRight: isLast ? 6 : 0,
                        bottomLeft: isFirst ? 6 : 0,
                        bottomRight: isFirst ? 6 : 0,
                    },
                    order: 1,
                };
            });

            renderLaborSummary(periodData);
            return { labels, datasets };
        };

        const buildLaborChart = async () => {
            if (!laborSummaryContainer || !laborChartCanvas) {
                return;
            }

            laborSummaryContainer.innerHTML = `
                <div class="production-chart__metric">
                    <span class="production-chart__metric-label">Loading</span>
                    <span class="production-chart__metric-value">…</span>
                </div>
            `;

            try {
                const periodKey = getSelectedPeriodKey();
                const dataset = await buildLaborDataset(periodKey);
                if (!dataset || !Array.isArray(dataset.datasets) || dataset.datasets.length === 0) {
                    showLaborSummaryError("No labor data available.");
                    if (window.laborChartInstance) {
                        window.laborChartInstance.destroy();
                        window.laborChartInstance = null;
                    }
                    return;
                }

                if (window.laborChartInstance) {
                    window.laborChartInstance.data.labels = dataset.labels;
                    window.laborChartInstance.data.datasets = dataset.datasets;
                    window.laborChartInstance.update();
                    return;
                }

                window.laborChartInstance = new Chart(laborChartCanvas, {
                    type: "bar",
                    data: dataset,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: "Day of month",
                                },
                                grid: {
                                    display: false,
                                },
                                ticks: {
                                    maxRotation: 0,
                                    autoSkip: true,
                                    maxTicksLimit: 15,
                                },
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: "Labor cost (Rs)",
                                },
                                ticks: {
                                    callback: (value) => formatCurrency(value),
                                },
                            },
                        },
                        interaction: {
                            mode: "index",
                            intersect: false,
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    usePointStyle: true,
                                },
                            },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const label = context.dataset.label || "";
                                        const value = Number(context.parsed.y ?? 0);
                                        return `${label}: ${formatCurrency(value)}`;
                                    },
                                    footer: (contexts) => {
                                        if (!Array.isArray(contexts) || contexts.length === 0) {
                                            return "";
                                        }
                                        const stackContexts = contexts.filter(
                                            (item) => item.dataset?.stack === "labor",
                                        );
                                        if (stackContexts.length === 0) {
                                            return "";
                                        }
                                        const total = stackContexts.reduce(
                                            (sum, item) => sum + Number(item.parsed.y ?? 0),
                                            0,
                                        );
                                        return `Total: ${formatCurrency(total)}`;
                                    },
                                },
                            },
                        },
                    },
                });
            } catch (error) {
                console.error(error);
                showLaborSummaryError("Unable to load labor data.");
            }
        };

        const refreshProductionChart = () => {
            buildProductionChart().catch((error) => {
                console.error(error);
                showProductionSummaryError("Unable to load production data.");
            });
        };

        const refreshProductionPulseChart = () => {
            buildProductionPulseChart().catch((error) => {
                console.error(error);
                showProductionPulseSummaryError("Unable to load machine pulse data.");
            });
        };

        const refreshIdleParetoChart = () => {
            buildIdleParetoChart().catch((error) => {
                console.error(error);
                showIdleParetoSummaryError("Unable to load idle breakdown.");
            });
        };

        const refreshSalesChart = () => {
            buildSalesChart().catch((error) => {
                console.error(error);
                showSalesSummaryError("Unable to load sales data.");
            });
        };

        const refreshMaterialChart = () => {
            buildMaterialChart().catch((error) => {
                console.error(error);
                showMaterialSummaryError("Unable to load material data.");
            });
        };

        const refreshLaborChart = () => {
            buildLaborChart().catch((error) => {
                console.error(error);
                showLaborSummaryError("Unable to load labor data.");
            });
        };

        const refreshUnitEconomicsChart = () => {
            buildUnitEconomicsChart().catch((error) => {
                console.error(error);
                showUnitEconomicsSummaryError("Unable to load unit economics data.");
            });
        };

        const normalizeUnitEconomicsRange = (changedField) => {
            if (!unitEconomicsStartDateInput || !unitEconomicsEndDateInput) {
                return;
            }

            let startValue = unitEconomicsStartDateInput.value;
            let endValue = unitEconomicsEndDateInput.value;

            if (startValue && endValue && startValue > endValue) {
                if (changedField === "start") {
                    unitEconomicsEndDateInput.value = startValue;
                    endValue = startValue;
                } else if (changedField === "end") {
                    unitEconomicsStartDateInput.value = endValue;
                    startValue = endValue;
                }
            }

            syncUnitEconomicsDateConstraints();
        };

        const handleUnitEconomicsStartChange = () => {
            normalizeUnitEconomicsRange("start");
            refreshUnitEconomicsChart();
        };

        const handleUnitEconomicsEndChange = () => {
            normalizeUnitEconomicsRange("end");
            refreshUnitEconomicsChart();
        };

        const refreshCharts = () => {
            refreshUnitEconomicsChart();
            refreshProductionChart();
            refreshProductionPulseChart();
            refreshIdleParetoChart();
            refreshSalesChart();
            refreshMaterialChart();
            refreshLaborChart();
        };

        if (systemStatusRefreshButton) {
            systemStatusRefreshButton.addEventListener("click", () => {
                fetchSystemStatus();
            });
        }

        fetchSystemStatus();
        setInterval(fetchSystemStatus, 5 * 60 * 1000);

        const initialClosingStockDate = initializeClosingStockDateInput();
        loadClosingStock(initialClosingStockDate);

        const selectorsInitialized = initializePeriodSelectors();

        resetProductionPulseRangeToPeriod();

        initializeUnitEconomicsDateInputs();

        yearSelect.addEventListener("change", () => {
            const previousSelection = getSelectedPeriodKey();
            populateMonthOptions(yearSelect.value, previousSelection);
            resetProductionPulseRangeToPeriod();
            refreshCharts();
        });

        monthSelect.addEventListener("change", () => {
            resetProductionPulseRangeToPeriod();
            refreshCharts();
        });

        if (productionPulseMachineSelect) {
            productionPulseMachineSelect.addEventListener("change", () => {
                selectedPulseMachine = normalizeMachineCode(productionPulseMachineSelect.value);
                updateMachineQueryParam();
                refreshProductionPulseChart();
            });
        }

        compareToggle.addEventListener("click", () => {
            const isActive = compareToggle.getAttribute("aria-pressed") === "true";
            compareToggle.setAttribute("aria-pressed", String(!isActive));
            compareToggle.classList.toggle("button--active", !isActive);
            refreshCharts();
        });

        if (unitEconomicsStartDateInput) {
            unitEconomicsStartDateInput.addEventListener("change", handleUnitEconomicsStartChange);
        }

        if (unitEconomicsEndDateInput) {
            unitEconomicsEndDateInput.addEventListener("change", handleUnitEconomicsEndChange);
        }

        if (productionPulseStartDateInput) {
            productionPulseStartDateInput.addEventListener("change", () => {
                normalizeProductionPulseRange("start");
                refreshProductionPulseChart();
            });
        }

        if (productionPulseEndDateInput) {
            productionPulseEndDateInput.addEventListener("change", () => {
                normalizeProductionPulseRange("end");
                refreshProductionPulseChart();
            });
        }

        if (selectorsInitialized) {
            refreshCharts();
        }
    </script>
</body>
</html>
