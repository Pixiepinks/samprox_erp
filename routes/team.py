from datetime import date, datetime

from flask import Blueprint, current_app, jsonify, request
from flask_jwt_extended import jwt_required
from sqlalchemy import inspect, text
from sqlalchemy.exc import DataError, IntegrityError, OperationalError, ProgrammingError

from extensions import db
from models import RoleEnum, TeamMember, TeamMemberStatus
from routes.jobs import require_role
from schemas import TeamMemberSchema

bp = Blueprint("team", __name__, url_prefix="/api/team")

member_schema = TeamMemberSchema()
members_schema = TeamMemberSchema(many=True)


def _ensure_schema():
    """Ensure the ``team_member`` table has the expected structure."""

    try:
        engine = db.engine
    except RuntimeError:
        # No application context â€“ nothing we can do here.
        return

    inspector = inspect(engine)
    tables = set(inspector.get_table_names())

    if "team_member" not in tables:
        # Create the table if it has not been provisioned yet.
        TeamMember.__table__.create(bind=engine, checkfirst=True)
        inspector = inspect(engine)
    columns = {column["name"] for column in inspector.get_columns("team_member")}

    statements: list[str] = []

    if "image_url" not in columns:
        statements.append("ALTER TABLE team_member ADD COLUMN image_url VARCHAR(500)")

    dialect = engine.dialect.name

    if "created_at" not in columns:
        statements.append("ALTER TABLE team_member ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
        statements.append("UPDATE team_member SET created_at = CURRENT_TIMESTAMP WHERE created_at IS NULL")
        if dialect != "sqlite":
            statements.append("ALTER TABLE team_member ALTER COLUMN created_at SET NOT NULL")
            statements.append("ALTER TABLE team_member ALTER COLUMN created_at DROP DEFAULT")

    if "updated_at" not in columns:
        statements.append("ALTER TABLE team_member ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
        statements.append("UPDATE team_member SET updated_at = CURRENT_TIMESTAMP WHERE updated_at IS NULL")
        if dialect != "sqlite":
            statements.append("ALTER TABLE team_member ALTER COLUMN updated_at SET NOT NULL")
            statements.append("ALTER TABLE team_member ALTER COLUMN updated_at DROP DEFAULT")

    if statements:
        with engine.begin() as connection:
            for statement in statements:
                try:
                    connection.execute(text(statement))
                except (ProgrammingError, OperationalError):
                    # If another process created the column in the meantime we can ignore the error.
                    current_app.logger.debug("Schema statement failed (likely already applied): %s", statement)


def _clean_string(value) -> str:
    if value is None:
        return ""
    if isinstance(value, str):
        return value.strip()
    return str(value).strip()


def _extract_string(
    value,
    *,
    label: str,
    required: bool = False,
    max_length: int | None = None,
) -> str | None:
    text = _clean_string(value)
    if not text:
        if required:
            raise ValueError(f"{label} is required.")
        return None
    if max_length is not None and len(text) > max_length:
        raise ValueError(f"{label} must be at most {max_length} characters.")
    return text


def _parse_join_date(value, *, required: bool) -> date | None:
    if isinstance(value, datetime):
        return value.date()
    if isinstance(value, date):
        return value

    text = _clean_string(value)
    if not text:
        if required:
            raise ValueError("Date of Join is required.")
        return None

    # First try strict ISO format to avoid ambiguity when the client submits the
    # value generated by a ``type="date"`` control.
    try:
        return date.fromisoformat(text)
    except ValueError:
        pass

    # Accept a handful of common human-entered variations so that manual entry
    # in browsers that do not enforce the control format still succeeds.
    accepted_formats = (
        "%d/%m/%Y",
        "%m/%d/%Y",
        "%d-%m-%Y",
        "%m-%d-%Y",
        "%Y/%m/%d",
        "%d %b %Y",
        "%d %B %Y",
        "%Y-%b-%d",
        "%Y-%B-%d",
    )

    for fmt in accepted_formats:
        try:
            return datetime.strptime(text, fmt).date()
        except ValueError:
            continue

    raise ValueError("Invalid date for joinDate. Please use the YYYY-MM-DD format.")


def _parse_status(value) -> TeamMemberStatus:
    if isinstance(value, TeamMemberStatus):
        return value
    text = _clean_string(value)
    if not text:
        return TeamMemberStatus.ACTIVE
    try:
        return TeamMemberStatus(text)
    except ValueError as exc:
        valid_values = ", ".join(status.value for status in TeamMemberStatus)
        raise ValueError(f"Status must be one of: {valid_values}.") from exc


def _data_error_message(exc: DataError, *, fallback: str) -> str:
    detail = ""
    origin = getattr(exc, "orig", None)
    if origin is not None:
        detail = str(origin)
    elif exc.args:
        detail = " ".join(str(arg) for arg in exc.args if arg)

    lowered = detail.lower()

    if any(keyword in lowered for keyword in ("invalid", "incorrect", "out of range")) and "date" in lowered:
        return "Invalid date for joinDate. Please use the YYYY-MM-DD format."

    if "isoformat" in lowered and "date" in lowered:
        return "Invalid date for joinDate. Please use the YYYY-MM-DD format."

    return fallback


@bp.get("/members")
@jwt_required()
def list_members():
    try:
        _ensure_schema()
        members = TeamMember.query.order_by(TeamMember.reg_number.asc()).all()
        return jsonify(members_schema.dump(members))
    except (ProgrammingError, OperationalError):
        db.session.rollback()
        current_app.logger.exception("Failed to list team members due to schema issues.")
        _ensure_schema()
        members = TeamMember.query.order_by(TeamMember.reg_number.asc()).all()
        return jsonify(members_schema.dump(members))


@bp.post("/members")
@jwt_required()
def create_member():
    if not require_role(RoleEnum.admin):
        return jsonify({"msg": "Only administrators can register team members."}), 403

    _ensure_schema()

    payload = request.get_json() or {}

    try:
        reg_number = _extract_string(
            payload.get("regNumber"),
            label="Registration number",
            required=True,
            max_length=40,
        )
        name = _extract_string(
            payload.get("name"),
            label="Name",
            required=True,
            max_length=200,
        )
        nickname = _extract_string(
            payload.get("nickname"),
            label="Nickname",
            max_length=120,
        )
        epf = _extract_string(
            payload.get("epf"),
            label="EPF number",
            max_length=120,
        )
        position = _extract_string(
            payload.get("position"),
            label="Position",
            max_length=120,
        )
        image_url = _extract_string(
            payload.get("image"),
            label="Profile image URL",
            max_length=500,
        )
    except ValueError as exc:
        return jsonify({"msg": str(exc)}), 400

    try:
        join_date = _parse_join_date(payload.get("joinDate"), required=True)
    except ValueError as exc:
        return jsonify({"msg": str(exc)}), 400

    try:
        status = _parse_status(payload.get("status"))
    except ValueError as exc:
        return jsonify({"msg": str(exc)}), 400

    member = TeamMember(
        reg_number=reg_number,
        name=name,
        nickname=nickname,
        epf=epf,
        position=position,
        join_date=join_date,
        status=status,
        image_url=image_url,
    )

    db.session.add(member)
    try:
        db.session.commit()
    except IntegrityError:
        db.session.rollback()
        return (
            jsonify({"msg": f"Registration number {reg_number} already exists."}),
            409,
        )
    except DataError as exc:
        db.session.rollback()
        message = _data_error_message(
            exc,
            fallback="Unable to register member. One or more fields exceed the allowed length.",
        )
        current_app.logger.warning("Failed to create team member due to data error: %s", exc)
        return jsonify({"msg": message}), 400
    except (ProgrammingError, OperationalError):
        db.session.rollback()
        current_app.logger.exception("Failed to create team member due to schema issues.")
        _ensure_schema()
        db.session.add(member)
        db.session.commit()

    return jsonify(member_schema.dump(member)), 201


@bp.patch("/members/<int:member_id>")
@jwt_required()
def update_member(member_id: int):
    if not require_role(RoleEnum.admin):
        return jsonify({"msg": "Only administrators can update team members."}), 403

    _ensure_schema()

    member = TeamMember.query.get_or_404(member_id)
    payload = request.get_json() or {}

    if "name" in payload:
        try:
            name = _extract_string(
                payload.get("name"),
                label="Name",
                required=True,
                max_length=200,
            )
        except ValueError as exc:
            return jsonify({"msg": str(exc)}), 400
        member.name = name

    if "nickname" in payload:
        try:
            member.nickname = _extract_string(
                payload.get("nickname"),
                label="Nickname",
                max_length=120,
            )
        except ValueError as exc:
            return jsonify({"msg": str(exc)}), 400

    if "epf" in payload:
        try:
            member.epf = _extract_string(
                payload.get("epf"),
                label="EPF number",
                max_length=120,
            )
        except ValueError as exc:
            return jsonify({"msg": str(exc)}), 400

    if "position" in payload:
        try:
            member.position = _extract_string(
                payload.get("position"),
                label="Position",
                max_length=120,
            )
        except ValueError as exc:
            return jsonify({"msg": str(exc)}), 400

    if "image" in payload:
        try:
            member.image_url = _extract_string(
                payload.get("image"),
                label="Profile image URL",
                max_length=500,
            )
        except ValueError as exc:
            return jsonify({"msg": str(exc)}), 400

    if "joinDate" in payload:
        try:
            join_date = _parse_join_date(payload.get("joinDate"), required=True)
        except ValueError as exc:
            return jsonify({"msg": str(exc)}), 400
        member.join_date = join_date

    if "status" in payload:
        try:
            member.status = _parse_status(payload.get("status"))
        except ValueError as exc:
            return jsonify({"msg": str(exc)}), 400

    try:
        db.session.commit()
    except DataError as exc:
        db.session.rollback()
        message = _data_error_message(
            exc,
            fallback="Unable to update member. One or more fields exceed the allowed length.",
        )
        current_app.logger.warning("Failed to update team member due to data error: %s", exc)
        return jsonify({"msg": message}), 400
    except (ProgrammingError, OperationalError):
        db.session.rollback()
        current_app.logger.exception("Failed to update team member due to schema issues.")
        _ensure_schema()
        db.session.add(member)
        db.session.commit()
    return jsonify(member_schema.dump(member))
