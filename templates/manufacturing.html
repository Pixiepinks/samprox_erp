<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Manufacturing | SAMPROX ERP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}" />
</head>
<body>
    <div class="page">
        <header class="topbar">
            <div class="brand">
                <div class="brand__logo">S</div>
                <div class="brand__details">
                    <p class="brand__name">SAMPROX ERP</p>
                    <p class="brand__section">Manufacturing Operations</p>
                </div>
            </div>
            <div class="topbar__actions">
                <a class="button button--ghost" href="{{ url_for('ui.mind_page') }}">Mind</a>
                <div class="user-summary">
                    <span class="user-summary__name" id="user-name"></span>
                    <span class="user-summary__role" id="user-role"></span>
                </div>
                <button type="button" class="button button--secondary" id="logout">Sign out</button>
            </div>
        </header>
        <nav class="subnav" aria-label="7M navigation">
            <a class="subnav__link" href="{{ url_for('ui.mind_page') }}">Mind</a>
            <a class="subnav__link" href="{{ url_for('ui.man_page') }}">Man</a>
            <a class="subnav__link" href="{{ url_for('ui.machines_page') }}">Machine</a>
            <a class="subnav__link" href="{{ url_for('ui.material_page') }}">Material</a>
            <a class="subnav__link" href="{{ url_for('ui.market_page') }}">Market</a>
            <a class="subnav__link subnav__link--active" href="{{ url_for('ui.manufacturing_page') }}">Manufacturing</a>
            <a class="subnav__link" href="{{ url_for('ui.money_page') }}">Money</a>
        </nav>
        <section class="section">
            <header class="section__header">
                <h1>Production flow coordination</h1>
            </header>
            <p class="section__description">
                Oversee the end-to-end production process, from work order release to final quality
                checks. Align capacity, resources, and schedules so every shift meets delivery
                commitments without sacrificing quality.
            </p>
            <div class="section__grid">
                <article class="tile">
                    <h2 class="tile__title">Work order control</h2>
                    <p class="tile__description">
                        Track live work orders, their routing steps, and current status to remove
                        bottlenecks before they impact throughput.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Capacity planning</h2>
                    <p class="tile__description">
                        Balance machine availability and staffing across shifts to keep utilization high
                        while maintaining buffer for urgent jobs.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Quality checkpoints</h2>
                    <p class="tile__description">
                        Coordinate in-process inspections, capture deviations, and escalate corrective
                        actions to protect outgoing quality.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Production analytics</h2>
                    <p class="tile__description">
                        Analyze yield, cycle times, and first-pass success to drive continuous
                        improvement initiatives across lines.
                    </p>
                </article>
            </div>
            <div class="production-card" aria-live="polite">
                <header class="production-card__header">
                    <div>
                        <h2>Daily production sheet</h2>
                        <p>Capture hourly output in tons for each manufacturing asset.</p>
                    </div>
                    <div class="production-summary">
                        <span class="production-summary__label">Total (tons)</span>
                        <span class="production-summary__value" id="production-total">0.00</span>
                    </div>
                </header>
                <div class="production-card__body">
                    <div class="production-totals" aria-live="polite">
                        <div class="production-totals__row">
                            <span class="production-totals__title">Today</span>
                            <div class="production-totals__metrics">
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">Total MCH-0001 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-today-mch-0001"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">Total MCH-0002 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-today-mch-0002"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">Total (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-today-total"
                                    >0.00</span>
                                </div>
                            </div>
                        </div>
                        <div class="production-totals__row">
                            <span class="production-totals__title">Month to Date</span>
                            <div class="production-totals__metrics">
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">MTD MCH-0001 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-mtd-mch-0001"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">MTD MCH-0002 (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-mtd-mch-0002"
                                    >0.00</span>
                                </div>
                                <div class="production-totals__metric">
                                    <span class="production-totals__metric-label">MTD Total (tons)</span>
                                    <span
                                        class="production-totals__metric-value"
                                        id="production-mtd-total"
                                    >0.00</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <form class="production-form" id="production-form" novalidate>
                        <div class="production-form__grid">
                            <div class="production-input">
                                <label for="production-date">Date <span class="required">*</span></label>
                                <input id="production-date" name="date" type="date" required />
                            </div>
                            <div class="production-input">
                                <label for="production-machine">Machine ID <span class="required">*</span></label>
                                <select id="production-machine" name="machine_code" required>
                                    <option value="" disabled selected>Select machine</option>
                                </select>
                            </div>
                            <div class="production-input">
                                <label for="production-hour">Hour no. <span class="required">*</span></label>
                                <select id="production-hour" name="hour_no" required>
                                    {% for hour in range(1, 25) %}
                                    <option value="{{ hour }}">{{ "%02d" % hour }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                            <div class="production-input">
                                <label for="production-qty">Production qty (tons) <span class="required">*</span></label>
                                <input
                                    id="production-qty"
                                    name="quantity_tons"
                                    type="number"
                                    min="0"
                                    step="0.01"
                                    placeholder="0.00"
                                    required
                                />
                            </div>
                        </div>
                        <div class="production-actions">
                            <button type="submit" class="button" id="production-submit">Save hour</button>
                        </div>
                        <p class="production-feedback production-feedback--success" id="production-success" hidden>
                            Production updated successfully.
                        </p>
                        <p class="production-feedback production-feedback--error" id="production-error" hidden></p>
                    </form>
                    <div class="production-table-wrapper">
                        <table class="production-table">
                            <thead>
                                <tr>
                                    <th scope="col">Hour</th>
                                    <th scope="col">MCH-0001 (tons)</th>
                                    <th scope="col">MCH-0002 (tons)</th>
                                    <th scope="col">Hour total (tons)</th>
                                    <th scope="col">Last updated</th>
                                </tr>
                            </thead>
                            <tbody id="production-table-body">
                                <tr id="production-empty-row">
                                    <td colspan="5" class="production-table__empty">
                                        No production records are available for this date.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="production-card forecast-card" id="forecast-card" aria-live="polite">
                <header class="production-card__header forecast-card__header">
                    <div>
                        <h2>Monthly production forecast</h2>
                        <p>Plan daily tons by machine while staying aware of Sri Lankan holidays.</p>
                    </div>
                    <div class="forecast-summary">
                        <span class="forecast-summary__label">Month total (tons)</span>
                        <span class="forecast-summary__value" id="forecast-total">0.00</span>
                    </div>
                </header>
                <div class="forecast-controls">
                    <div class="forecast-control">
                        <label for="forecast-machine">Machine ID <span class="required">*</span></label>
                        <select id="forecast-machine" name="forecast_machine" required disabled>
                            <option value="" disabled selected>Loading machines…</option>
                        </select>
                    </div>
                    <div class="forecast-month-nav" role="group" aria-label="Change month">
                        <button type="button" class="forecast-month-nav__button" id="forecast-prev-month" aria-label="Previous month" disabled>
                            &lsaquo;
                        </button>
                        <span class="forecast-month-nav__label" id="forecast-month-label"></span>
                        <button type="button" class="forecast-month-nav__button" id="forecast-next-month" aria-label="Next month" disabled>
                            &rsaquo;
                        </button>
                    </div>
                </div>
                <div class="forecast-layout">
                    <div class="forecast-calendar">
                        <table class="forecast-calendar__table">
                            <thead class="forecast-calendar__head">
                                <tr>
                                    <th scope="col">Mon</th>
                                    <th scope="col">Tue</th>
                                    <th scope="col">Wed</th>
                                    <th scope="col">Thu</th>
                                    <th scope="col">Fri</th>
                                    <th scope="col">Sat</th>
                                    <th scope="col">Sun</th>
                                </tr>
                            </thead>
                            <tbody class="forecast-calendar__body" id="forecast-calendar-body">
                                <tr>
                                    <td colspan="7" class="forecast-calendar__empty">Select a machine to manage forecasts.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <form class="forecast-form" id="forecast-form" novalidate>
                        <input type="hidden" id="forecast-date" name="date" />
                        <div class="forecast-form__row">
                            <p class="forecast-form__label">Selected day</p>
                            <p class="forecast-form__value" id="forecast-date-display">—</p>
                        </div>
                        <div class="forecast-form__row">
                            <label for="forecast-qty">Forecast qty (tons) <span class="required">*</span></label>
                            <input
                                id="forecast-qty"
                                name="forecast_tons"
                                type="number"
                                min="0"
                                step="0.01"
                                placeholder="0.00"
                                required
                                disabled
                            />
                        </div>
                        <p class="forecast-holiday" id="forecast-holiday-note" hidden></p>
                        <div class="forecast-actions">
                            <button type="submit" class="button" id="forecast-submit" disabled>Save forecast</button>
                        </div>
                        <p class="forecast-feedback forecast-feedback--success" id="forecast-success" hidden>
                            Forecast updated successfully.
                        </p>
                        <p class="forecast-feedback forecast-feedback--error" id="forecast-error" hidden></p>
                    </form>
                </div>
            </div>
        </section>
    </div>
    <script>
        const token = localStorage.getItem("samprox_token");
        const userRaw = localStorage.getItem("samprox_user");
        let user;

        try {
            user = userRaw ? JSON.parse(userRaw) : null;
        } catch (_) {
            user = null;
        }

        if (!token || !user) {
            window.location.href = "/";
        }

        const roleLabels = {
            admin: "Admin",
            production_manager: "Production Manager",
            maintenance_manager: "Maintenance Manager",
            technician: "Technician",
        };

        const userNameEl = document.getElementById("user-name");
        const userRoleEl = document.getElementById("user-role");
        const logoutButton = document.getElementById("logout");

        userNameEl.textContent = user?.name || "Unknown";
        userRoleEl.textContent = roleLabels[user?.role] || "";

        logoutButton.addEventListener("click", () => {
            localStorage.removeItem("samprox_token");
            localStorage.removeItem("samprox_user");
            window.location.href = "/";
        });

        const machineSelect = document.getElementById("production-machine");
        const dateInput = document.getElementById("production-date");
        const hourSelect = document.getElementById("production-hour");
        const quantityInput = document.getElementById("production-qty");
        const productionForm = document.getElementById("production-form");
        const productionSuccess = document.getElementById("production-success");
        const productionError = document.getElementById("production-error");
        const productionTableBody = document.getElementById("production-table-body");
        const productionEmptyRow = document.getElementById("production-empty-row");
        const productionTotal = document.getElementById("production-total");
        const productionSubmit = document.getElementById("production-submit");

        const forecastMachineSelect = document.getElementById("forecast-machine");
        const forecastMonthLabel = document.getElementById("forecast-month-label");
        const forecastPrevMonth = document.getElementById("forecast-prev-month");
        const forecastNextMonth = document.getElementById("forecast-next-month");
        const forecastCalendarBody = document.getElementById("forecast-calendar-body");
        const forecastForm = document.getElementById("forecast-form");
        const forecastDateInput = document.getElementById("forecast-date");
        const forecastDateDisplay = document.getElementById("forecast-date-display");
        const forecastQtyInput = document.getElementById("forecast-qty");
        const forecastSubmit = document.getElementById("forecast-submit");
        const forecastSuccess = document.getElementById("forecast-success");
        const forecastError = document.getElementById("forecast-error");
        const forecastHolidayNote = document.getElementById("forecast-holiday-note");
        const forecastTotal = document.getElementById("forecast-total");

        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, "0");
        const dd = String(today.getDate()).padStart(2, "0");
        dateInput.value = `${yyyy}-${mm}-${dd}`;

        const authHeaders = {
            Authorization: `Bearer ${token}`,
        };

        let machinesCache = [];

        const forecastState = {
            anchorDate: new Date(today.getFullYear(), today.getMonth(), 1),
            selectedDate: new Date(today.getFullYear(), today.getMonth(), today.getDate()),
            preferredDay: today.getDate(),
            machineCode: "",
            entries: new Map(),
            holidaysByYear: new Map(),
            total: 0,
        };

        function showMessage(element, message = "") {
            if (!element) return;
            if (message) {
                element.textContent = message;
                element.hidden = false;
            } else {
                element.hidden = true;
            }
        }

        function clearFeedback() {
            showMessage(productionSuccess);
            showMessage(productionError);
        }

        function setFormDisabled(disabled) {
            productionSubmit.disabled = disabled;
            dateInput.disabled = disabled;
            machineSelect.disabled = disabled;
            hourSelect.disabled = disabled;
            quantityInput.disabled = disabled;
        }

        function clearForecastFeedback() {
            showMessage(forecastSuccess);
            showMessage(forecastError);
        }

        function formatDateISO(date) {
            if (!(date instanceof Date) || Number.isNaN(date.valueOf())) {
                return "";
            }

            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");

            return `${year}-${month}-${day}`;
        }

        function parseISODate(dateIso) {
            if (typeof dateIso !== "string") {
                return null;
            }

            const [yearStr, monthStr, dayStr] = dateIso.split("-");
            const year = Number(yearStr);
            const month = Number(monthStr);
            const day = Number(dayStr);

            if (
                !Number.isFinite(year) ||
                !Number.isFinite(month) ||
                !Number.isFinite(day)
            ) {
                return null;
            }

            const parsed = new Date(year, month - 1, day);

            if (Number.isNaN(parsed.valueOf())) {
                return null;
            }

            return parsed;
        }

        function updateForecastMonthLabel() {
            if (!forecastMonthLabel) {
                return;
            }
            const localeLabel = forecastState.anchorDate.toLocaleDateString(undefined, {
                month: "long",
                year: "numeric",
            });
            forecastMonthLabel.textContent = localeLabel;
        }

        function ensureForecastNavState() {
            const disabled = !forecastState.machineCode;
            if (forecastPrevMonth) {
                forecastPrevMonth.disabled = disabled;
            }
            if (forecastNextMonth) {
                forecastNextMonth.disabled = disabled;
            }
        }

        function ensureForecastFormState() {
            const hasMachine = Boolean(forecastState.machineCode);
            const hasDate = Boolean(forecastState.selectedDate);
            if (forecastQtyInput) {
                forecastQtyInput.disabled = !hasMachine || !hasDate;
            }
            if (forecastSubmit) {
                forecastSubmit.disabled = !hasMachine || !hasDate;
            }
        }

        function setForecastFormDisabled(disabled) {
            if (forecastQtyInput) {
                forecastQtyInput.disabled = disabled;
            }
            if (forecastSubmit) {
                forecastSubmit.disabled = disabled;
            }
        }

        function renderForecastEmptyState(message) {
            if (!forecastCalendarBody) {
                return;
            }
            forecastCalendarBody.innerHTML = "";
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 7;
            td.className = "forecast-calendar__empty";
            td.textContent = message;
            tr.appendChild(td);
            forecastCalendarBody.appendChild(tr);
        }

        function getHolidayForDate(dateIso) {
            if (!dateIso) {
                return null;
            }
            const year = Number(dateIso.slice(0, 4));
            if (!Number.isFinite(year)) {
                return null;
            }
            const yearMap = forecastState.holidaysByYear.get(year);
            return yearMap ? yearMap.get(dateIso) : null;
        }

        async function ensureHolidaysForYear(year) {
            if (!Number.isFinite(year)) {
                return;
            }
            if (forecastState.holidaysByYear.has(year)) {
                return;
            }
            try {
                const response = await fetch(`/api/production/forecast/holidays?year=${year}`, {
                    headers: authHeaders,
                });
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Unable to load Sri Lanka holidays for this year.");
                }
                const data = await response.json();
                const list = Array.isArray(data?.holidays) ? data.holidays : [];
                const map = new Map();
                list.forEach((item) => {
                    if (item?.date && item?.name) {
                        map.set(item.date, item.name);
                    }
                });
                forecastState.holidaysByYear.set(year, map);
            } catch (error) {
                forecastState.holidaysByYear.set(year, new Map());
                showMessage(
                    forecastError,
                    error?.message || "Unable to load Sri Lanka holidays for this year.",
                );
            }
        }

        function recalculateForecastTotal() {
            let total = 0;
            forecastState.entries.forEach((value) => {
                const number = Number(value || 0);
                if (Number.isFinite(number)) {
                    total += number;
                }
            });
            forecastState.total = Number.isFinite(total) ? Number(total.toFixed(3)) : 0;
        }

        function updateForecastTotalElement() {
            if (forecastTotal) {
                updateTotalElement(forecastTotal, forecastState.total);
            }
        }

        function ensureSelectedDateInAnchorMonth() {
            const year = forecastState.anchorDate.getFullYear();
            const month = forecastState.anchorDate.getMonth();
            const monthDays = new Date(year, month + 1, 0).getDate();
            let candidate = forecastState.selectedDate;
            if (!(candidate instanceof Date) || Number.isNaN(candidate.valueOf())) {
                candidate = new Date(year, month, Math.min(forecastState.preferredDay, monthDays));
            }
            if (candidate.getFullYear() !== year || candidate.getMonth() !== month) {
                const day = Math.min(forecastState.preferredDay, monthDays);
                candidate = new Date(year, month, day);
            }
            forecastState.selectedDate = candidate;
            forecastState.preferredDay = candidate.getDate();
        }

        function updateForecastSelectionUI() {
            const selectedDate = forecastState.selectedDate;
            const iso =
                selectedDate &&
                selectedDate instanceof Date &&
                !Number.isNaN(selectedDate.valueOf())
                    ? formatDateISO(selectedDate)
                    : "";

            if (forecastDateInput) {
                forecastDateInput.value = iso;
            }
            if (forecastDateDisplay) {
                if (iso) {
                    const displayDate = parseISODate(iso);
                    forecastDateDisplay.textContent = displayDate
                        ? displayDate.toLocaleDateString(undefined, {
                              weekday: "long",
                              month: "long",
                              day: "numeric",
                              year: "numeric",
                          })
                        : "—";
                } else {
                    forecastDateDisplay.textContent = "—";
                }
            }

            const forecastValue = iso ? forecastState.entries.get(iso) ?? 0 : null;
            if (forecastQtyInput) {
                if (forecastValue === null) {
                    forecastQtyInput.value = "";
                } else {
                    forecastQtyInput.value = formatQuantity(forecastValue || 0);
                }
            }

            if (forecastHolidayNote) {
                const holidayName = getHolidayForDate(iso);
                if (holidayName) {
                    forecastHolidayNote.hidden = false;
                    forecastHolidayNote.textContent = `${holidayName} · Sri Lanka holiday`;
                } else {
                    forecastHolidayNote.hidden = true;
                    forecastHolidayNote.textContent = "";
                }
            }

            if (forecastCalendarBody) {
                const buttons = forecastCalendarBody.querySelectorAll(".forecast-calendar__day");
                buttons.forEach((button) => {
                    if (button.dataset.date === iso) {
                        button.classList.add("forecast-calendar__day--selected");
                        button.setAttribute("aria-pressed", "true");
                    } else {
                        button.classList.remove("forecast-calendar__day--selected");
                        button.setAttribute("aria-pressed", "false");
                    }
                });
            }

            ensureForecastFormState();
        }

        function renderForecastCalendar() {
            if (!forecastCalendarBody) {
                return;
            }

            const machineCode = forecastState.machineCode;
            if (!machineCode) {
                renderForecastEmptyState("Select a machine to manage forecasts.");
                return;
            }

            forecastCalendarBody.innerHTML = "";

            const year = forecastState.anchorDate.getFullYear();
            const month = forecastState.anchorDate.getMonth();
            const monthDays = new Date(year, month + 1, 0).getDate();
            const firstDay = new Date(year, month, 1);
            const firstWeekday = (firstDay.getDay() + 6) % 7; // Monday as first column

            let dayCounter = 1 - firstWeekday;

            for (let week = 0; week < 6; week += 1) {
                const tr = document.createElement("tr");
                tr.className = "forecast-calendar__row";

                for (let weekday = 0; weekday < 7; weekday += 1, dayCounter += 1) {
                    const td = document.createElement("td");
                    td.className = "forecast-calendar__cell";

                    if (dayCounter < 1 || dayCounter > monthDays) {
                        td.classList.add("forecast-calendar__cell--muted");
                        tr.appendChild(td);
                        continue;
                    }

                    const currentDate = new Date(year, month, dayCounter);
                    const iso = formatDateISO(currentDate);

                    const button = document.createElement("button");
                    button.type = "button";
                    button.className = "forecast-calendar__day";
                    button.dataset.date = iso;
                    button.setAttribute(
                        "aria-label",
                        `${currentDate.toLocaleDateString(undefined, {
                            weekday: "long",
                            month: "long",
                            day: "numeric",
                        })} forecast ${formatQuantity(
                            forecastState.entries.get(iso) || 0,
                        )} tons`,
                    );
                    button.setAttribute("aria-pressed", "false");

                    const weekdayValue = currentDate.getDay();
                    if (weekdayValue === 0 || weekdayValue === 6) {
                        button.classList.add("forecast-calendar__day--weekend");
                    }

                    const holidayName = getHolidayForDate(iso);
                    if (holidayName) {
                        button.classList.add("forecast-calendar__day--holiday");
                        button.title = `${holidayName} (Sri Lanka holiday)`;
                    }

                    const dayNumber = document.createElement("span");
                    dayNumber.className = "forecast-calendar__date";
                    dayNumber.textContent = String(dayCounter);
                    button.appendChild(dayNumber);

                    const valueSpan = document.createElement("span");
                    const rawValue = forecastState.entries.get(iso) || 0;
                    valueSpan.className = "forecast-calendar__value";
                    valueSpan.textContent = formatQuantity(rawValue);
                    if (!rawValue) {
                        valueSpan.classList.add("forecast-calendar__value--empty");
                    }
                    button.appendChild(valueSpan);

                    if (holidayName) {
                        const holidayBadge = document.createElement("span");
                        holidayBadge.className = "forecast-calendar__holiday";
                        holidayBadge.textContent = holidayName;
                        button.appendChild(holidayBadge);
                    }

                    td.appendChild(button);
                    tr.appendChild(td);
                }

                forecastCalendarBody.appendChild(tr);
            }

            updateForecastSelectionUI();
        }

        function setSelectedForecastDate(dateIso) {
            if (!dateIso) {
                return;
            }
            const candidate = parseISODate(dateIso);
            if (!(candidate instanceof Date) || Number.isNaN(candidate.valueOf())) {
                return;
            }
            forecastState.selectedDate = candidate;
            forecastState.preferredDay = candidate.getDate();
            updateForecastSelectionUI();
        }

        const SUMMARY_MACHINE_CODES = ["MCH-0001", "MCH-0002"];
        const totalsTodayTotal = document.getElementById("production-today-total");
        const totalsMtdTotal = document.getElementById("production-mtd-total");
        const totalsTodayMachineElements = {};
        const totalsMtdMachineElements = {};

        SUMMARY_MACHINE_CODES.forEach((code) => {
            const normalized = code.toLowerCase();
            totalsTodayMachineElements[code] = document.getElementById(
                `production-today-${normalized}`,
            );
            totalsMtdMachineElements[code] = document.getElementById(
                `production-mtd-${normalized}`,
            );
        });

        let latestSummary = null;

        function formatQuantity(value) {
            const number = Number(value);
            return Number.isFinite(number) ? number.toFixed(2) : "0.00";
        }

        function updateTotalElement(element, value) {
            if (!element) return;
            const number = Number(value ?? 0);
            element.textContent = formatQuantity(number);
        }

        function renderTotals(data) {
            const totals = data?.totals || {};
            const todayTotals = totals.today || {};
            const mtdTotals = totals.mtd || {};
            const todayMachines = todayTotals.machines || {};
            const mtdMachines = mtdTotals.machines || {};

            SUMMARY_MACHINE_CODES.forEach((code) => {
                updateTotalElement(
                    totalsTodayMachineElements[code],
                    todayMachines[code],
                );
                updateTotalElement(
                    totalsMtdMachineElements[code],
                    mtdMachines[code],
                );
            });

            const fallbackTodayTotal =
                todayTotals.total ?? data?.total_quantity_tons ?? 0;
            updateTotalElement(totalsTodayTotal, fallbackTodayTotal);
            updateTotalElement(totalsMtdTotal, mtdTotals.total);
        }

        function renderSummary(data) {
            productionTableBody.innerHTML = "";
            productionEmptyRow.hidden = true;
            const emptyCell = productionEmptyRow.querySelector("td");
            if (emptyCell) {
                emptyCell.textContent = "No production records are available for this date.";
            }

            const hoursMap = new Map();
            if (data && Array.isArray(data.hours)) {
                data.hours.forEach((hour) => {
                    const hourNumber = Number(hour?.hour_no);
                    if (Number.isFinite(hourNumber)) {
                        hoursMap.set(hourNumber, hour);
                    }
                });
            }

            for (let hour = 1; hour <= 24; hour += 1) {
                const hourData = hoursMap.get(hour) || {};
                const machinesMap = hourData.machines || {};

                const tr = document.createElement("tr");
                tr.dataset.hour = String(hour);

                const hourCell = document.createElement("th");
                hourCell.scope = "row";
                hourCell.textContent = String(hour).padStart(2, "0");
                tr.appendChild(hourCell);

                SUMMARY_MACHINE_CODES.forEach((code) => {
                    const machineCell = document.createElement("td");
                    machineCell.dataset.machineCode = code;
                    const machineData = machinesMap[code];
                    const quantity = Number(machineData?.quantity_tons ?? 0);
                    machineCell.textContent = formatQuantity(quantity);
                    machineCell.dataset.quantity = Number.isFinite(quantity) ? quantity : 0;
                    tr.appendChild(machineCell);
                });

                const totalCell = document.createElement("td");
                const hourTotal = Number(hourData.hour_total_tons ?? 0);
                totalCell.textContent = formatQuantity(hourTotal);
                tr.appendChild(totalCell);

                const updatedCell = document.createElement("td");
                const updatedValue = hourData.last_updated;
                if (updatedValue) {
                    const updatedDate = new Date(updatedValue);
                    if (!Number.isNaN(updatedDate.valueOf())) {
                        updatedCell.textContent = updatedDate.toLocaleString(undefined, {
                            hour: "2-digit",
                            minute: "2-digit",
                        });
                    } else {
                        updatedCell.textContent = "—";
                    }
                } else {
                    updatedCell.textContent = "—";
                }
                tr.appendChild(updatedCell);

                productionTableBody.appendChild(tr);
            }

            const total = Number(
                data?.totals?.today?.total ?? data?.total_quantity_tons ?? 0,
            );
            productionTotal.textContent = formatQuantity(total);
            renderTotals(data);
        }

        function updateQuantityFieldFromSummary() {
            const machineCode = machineSelect.value;
            const hourValue = Number(hourSelect.value);

            if (!machineCode || !Number.isFinite(hourValue)) {
                quantityInput.value = "";
                return;
            }

            if (!latestSummary || !Array.isArray(latestSummary.hours)) {
                quantityInput.value = formatQuantity(0);
                return;
            }

            const hourData = latestSummary.hours.find(
                (hour) => Number(hour?.hour_no) === hourValue,
            );
            const machineData = hourData?.machines?.[machineCode];
            const quantity = Number(machineData?.quantity_tons ?? 0);
            quantityInput.value = formatQuantity(quantity);
        }

        async function loadProductionSummary() {
            showMessage(productionError);

            const params = new URLSearchParams();
            if (dateInput.value) {
                params.set("date", dateInput.value);
            }
            if (SUMMARY_MACHINE_CODES.length > 0) {
                params.set("machine_codes", SUMMARY_MACHINE_CODES.join(","));
            }

            try {
                const response = await fetch(`/api/production/daily/summary?${params.toString()}`, {
                    headers: authHeaders,
                });
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Failed to load production summary.");
                }

                const data = await response.json();
                latestSummary = data;
                renderSummary(data);
                updateQuantityFieldFromSummary();
            } catch (error) {
                latestSummary = null;
                productionTotal.textContent = "0.00";
                productionTableBody.innerHTML = "";
                productionEmptyRow.hidden = false;
                const emptyCell = productionEmptyRow.querySelector("td");
                if (emptyCell) {
                    emptyCell.textContent = "Unable to load production summary.";
                }
                productionTableBody.appendChild(productionEmptyRow);
                renderTotals(null);
                showMessage(
                    productionError,
                    error.message || "Unable to load production summary.",
                );
            }
        }

        function populateProductionMachineSelect(machines) {
            machineSelect.innerHTML = "";
            if (!Array.isArray(machines) || machines.length === 0) {
                const option = document.createElement("option");
                option.textContent = "No machines available";
                option.value = "";
                machineSelect.appendChild(option);
                machineSelect.disabled = true;
                return;
            }

            machines.forEach((machine, index) => {
                const option = document.createElement("option");
                option.value = machine.code;
                option.textContent = `${machine.code} — ${machine.name}`;
                if (index === 0) {
                    option.selected = true;
                }
                machineSelect.appendChild(option);
            });
            machineSelect.disabled = false;
        }

        function populateForecastMachineSelect(machines) {
            if (!forecastMachineSelect) {
                return;
            }

            const previousSelection = forecastMachineSelect.value;
            forecastMachineSelect.innerHTML = "";

            if (!Array.isArray(machines) || machines.length === 0) {
                const option = document.createElement("option");
                option.textContent = "No machines available";
                option.value = "";
                forecastMachineSelect.appendChild(option);
                forecastMachineSelect.disabled = true;
                forecastState.machineCode = "";
                ensureForecastNavState();
                ensureForecastFormState();
                renderForecastEmptyState("Add a machine to begin forecasting.");
                forecastState.entries.clear();
                forecastState.total = 0;
                updateForecastTotalElement();
                return;
            }

            let selection = previousSelection;
            const options = machines.map((machine) => {
                const option = document.createElement("option");
                option.value = machine.code;
                option.textContent = `${machine.code} — ${machine.name}`;
                return option;
            });

            options.forEach((option) => {
                forecastMachineSelect.appendChild(option);
            });

            if (!selection || !machines.some((machine) => machine.code === selection)) {
                selection = machines[0]?.code || "";
            }

            forecastMachineSelect.value = selection || "";
            forecastMachineSelect.disabled = false;
            forecastState.machineCode = selection || "";
            ensureForecastNavState();
            ensureForecastFormState();
        }

        async function fetchMachines() {
            try {
                const response = await fetch("/api/machines/assets", { headers: authHeaders });
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Failed to load machines");
                }

                const machines = await response.json();
                machinesCache = Array.isArray(machines) ? machines : [];
                populateProductionMachineSelect(machinesCache);
                populateForecastMachineSelect(machinesCache);
                await loadProductionSummary();
                await loadForecastData();
            } catch (error) {
                renderTotals(null);
                showMessage(productionError, error.message || "Unable to load machines");
                populateForecastMachineSelect([]);
            }
        }

        async function loadForecastData() {
            updateForecastMonthLabel();
            ensureForecastNavState();

            const machineCode = forecastState.machineCode;
            if (!machineCode) {
                forecastState.entries.clear();
                forecastState.total = 0;
                forecastState.selectedDate = null;
                updateForecastTotalElement();
                renderForecastCalendar();
                ensureForecastFormState();
                return;
            }

            const year = forecastState.anchorDate.getFullYear();
            await ensureHolidaysForYear(year);

            const period = `${forecastState.anchorDate.getFullYear()}-${String(
                forecastState.anchorDate.getMonth() + 1,
            ).padStart(2, "0")}`;

            const params = new URLSearchParams();
            params.set("period", period);
            params.set("machine_code", machineCode);

            try {
                const response = await fetch(`/api/production/forecast?${params.toString()}`, {
                    headers: authHeaders,
                });
                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }
                if (!response.ok) {
                    throw new Error("Unable to load production forecast.");
                }

                const data = await response.json();
                const entriesList = Array.isArray(data?.entries) ? data.entries : [];
                const entriesMap = new Map();
                entriesList.forEach((entry) => {
                    if (!entry || !entry.date) {
                        return;
                    }
                    const value = Number(entry.forecast_tons ?? 0);
                    entriesMap.set(
                        entry.date,
                        Number.isFinite(value) ? Number(value.toFixed(3)) : 0,
                    );
                });

                const monthDays = Number.isFinite(Number(data?.days))
                    ? Number(data.days)
                    : new Date(
                          forecastState.anchorDate.getFullYear(),
                          forecastState.anchorDate.getMonth() + 1,
                          0,
                      ).getDate();

                for (let day = 1; day <= monthDays; day += 1) {
                    const iso = formatDateISO(
                        new Date(
                            forecastState.anchorDate.getFullYear(),
                            forecastState.anchorDate.getMonth(),
                            day,
                        ),
                    );
                    if (!entriesMap.has(iso)) {
                        entriesMap.set(iso, 0);
                    }
                }

                forecastState.entries = entriesMap;
                recalculateForecastTotal();
                ensureSelectedDateInAnchorMonth();
                renderForecastCalendar();
                updateForecastTotalElement();
            } catch (error) {
                forecastState.entries.clear();
                forecastState.total = 0;
                forecastState.selectedDate = null;
                renderForecastEmptyState(error.message || "Unable to load production forecast.");
                updateForecastTotalElement();
                ensureForecastFormState();
                showMessage(
                    forecastError,
                    error.message || "Unable to load production forecast.",
                );
            }
        }

        function changeForecastMonth(step) {
            if (!Number.isFinite(step) || step === 0) {
                return;
            }
            const anchor = forecastState.anchorDate;
            forecastState.anchorDate = new Date(
                anchor.getFullYear(),
                anchor.getMonth() + step,
                1,
            );
            ensureSelectedDateInAnchorMonth();
            clearForecastFeedback();
            loadForecastData();
        }

        productionForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            clearFeedback();

            const machineCode = machineSelect.value;
            const dateValue = dateInput.value;
            const hourValue = hourSelect.value;
            const quantityValue = quantityInput.value;

            if (!machineCode || !dateValue || !hourValue) {
                showMessage(productionError, "Please complete all required fields.");
                return;
            }

            setFormDisabled(true);

            try {
                const response = await fetch("/api/production/daily", {
                    method: "POST",
                    headers: {
                        ...authHeaders,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        machine_code: machineCode,
                        date: dateValue,
                        hour_no: Number(hourValue),
                        quantity_tons: quantityValue ? Number(quantityValue) : 0,
                    }),
                });

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                const payload = await response.json().catch(() => ({}));

                if (!response.ok) {
                    const message = payload?.msg || "Unable to save production.";
                    showMessage(productionError, message);
                    return;
                }

                showMessage(productionSuccess, "Production updated successfully.");
                await loadProductionSummary();
            } catch (error) {
                showMessage(productionError, error.message || "Unable to save production.");
            } finally {
                setFormDisabled(false);
            }
        });

        if (forecastForm) {
            forecastForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                clearForecastFeedback();

                const machineCode = forecastState.machineCode;
                const dateValue = forecastDateInput?.value;
                const quantityValue = forecastQtyInput?.value ?? "";

                if (!machineCode || !dateValue) {
                    showMessage(
                        forecastError,
                        "Select a machine and day before saving a forecast.",
                    );
                    return;
                }

                let forecastValue = quantityValue ? Number(quantityValue) : 0;
                if (!Number.isFinite(forecastValue)) {
                    showMessage(forecastError, "Enter a valid forecast quantity.");
                    return;
                }

                if (forecastValue < 0) {
                    showMessage(
                        forecastError,
                        "Forecast quantity cannot be negative.",
                    );
                    return;
                }

                setForecastFormDisabled(true);

                try {
                    const response = await fetch("/api/production/forecast", {
                        method: "POST",
                        headers: {
                            ...authHeaders,
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            machine_code: machineCode,
                            date: dateValue,
                            forecast_tons: forecastValue,
                        }),
                    });

                    if (response.status === 401) {
                        logoutButton.click();
                        return;
                    }

                    const payload = await response.json().catch(() => ({}));
                    if (!response.ok) {
                        const message = payload?.msg || "Unable to save forecast.";
                        showMessage(forecastError, message);
                        return;
                    }

                    const savedValue = Number(payload?.forecast_tons ?? forecastValue);
                    if (Number.isFinite(savedValue)) {
                        const normalized = Number(savedValue.toFixed(3));
                        forecastState.entries.set(dateValue, normalized);
                        recalculateForecastTotal();
                        updateForecastTotalElement();
                    }

                    showMessage(forecastSuccess, "Forecast updated successfully.");
                    renderForecastCalendar();
                } catch (error) {
                    showMessage(forecastError, error.message || "Unable to save forecast.");
                } finally {
                    setForecastFormDisabled(false);
                    ensureForecastFormState();
                }
            });
        }

        machineSelect.addEventListener("change", () => {
            clearFeedback();
            updateQuantityFieldFromSummary();
        });

        hourSelect.addEventListener("change", () => {
            clearFeedback();
            updateQuantityFieldFromSummary();
        });

        dateInput.addEventListener("change", () => {
            clearFeedback();
            loadProductionSummary();
        });

        productionTableBody.addEventListener("click", (event) => {
            const machineCell = event.target.closest("td[data-machine-code]");
            if (machineCell) {
                const row = machineCell.closest("tr[data-hour]");
                if (row?.dataset.hour) {
                    hourSelect.value = String(Number(row.dataset.hour));
                }

                const machineCode = machineCell.dataset.machineCode;
                const option = Array.from(machineSelect.options).find(
                    (opt) => opt.value === machineCode,
                );
                if (option) {
                    machineSelect.value = machineCode;
                }

                const qty = Number(machineCell.dataset.quantity ?? 0);
                quantityInput.value = formatQuantity(qty);
                clearFeedback();
                return;
            }

            const row = event.target.closest("tr[data-hour]");
            if (!row || !row.dataset.hour) {
                return;
            }

            hourSelect.value = String(Number(row.dataset.hour));
            updateQuantityFieldFromSummary();
            clearFeedback();
        });

        if (forecastMachineSelect) {
            forecastMachineSelect.addEventListener("change", () => {
                clearForecastFeedback();
                forecastState.machineCode = forecastMachineSelect.value || "";
                ensureSelectedDateInAnchorMonth();
                loadForecastData();
            });
        }

        if (forecastPrevMonth) {
            forecastPrevMonth.addEventListener("click", () => {
                changeForecastMonth(-1);
            });
        }

        if (forecastNextMonth) {
            forecastNextMonth.addEventListener("click", () => {
                changeForecastMonth(1);
            });
        }

        if (forecastCalendarBody) {
            forecastCalendarBody.addEventListener("click", (event) => {
                const button = event.target.closest(".forecast-calendar__day");
                if (!button || !button.dataset.date) {
                    return;
                }
                event.preventDefault();
                clearForecastFeedback();
                setSelectedForecastDate(button.dataset.date);
            });

            forecastCalendarBody.addEventListener("keydown", (event) => {
                if (event.key !== "Enter" && event.key !== " ") {
                    return;
                }
                const button = event.target.closest(".forecast-calendar__day");
                if (!button || !button.dataset.date) {
                    return;
                }
                event.preventDefault();
                clearForecastFeedback();
                setSelectedForecastDate(button.dataset.date);
            });
        }

        updateForecastMonthLabel();
        renderForecastEmptyState("Select a machine to manage forecasts.");
        fetchMachines();
    </script>
</body>
</html>
