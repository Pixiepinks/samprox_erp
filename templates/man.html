<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Man | SAMPROX ERP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}" />
</head>
<body>
    <div class="page">
        <header class="topbar">
            <div class="brand">
                <div class="brand__logo">S</div>
                <div class="brand__details">
                    <p class="brand__name">SAMPROX ERP</p>
                    <p class="brand__section">Man Resource Planning</p>
                </div>
            </div>
            <div class="topbar__actions">
                <a class="button button--ghost" href="{{ url_for('ui.mind_page') }}">Mind</a>
                <div class="user-summary">
                    <span class="user-summary__name" id="user-name"></span>
                    <span class="user-summary__role" id="user-role"></span>
                </div>
                <button type="button" class="button button--secondary" id="logout">Sign out</button>
            </div>
        </header>
        <nav class="subnav" aria-label="7M navigation">
            <a class="subnav__link" href="{{ url_for('ui.mind_page') }}">Mind</a>
            <a class="subnav__link subnav__link--active" href="{{ url_for('ui.man_page') }}">Man</a>
            <a class="subnav__link" href="{{ url_for('ui.machines_page') }}">Machine</a>
            <a class="subnav__link" href="{{ url_for('ui.material_page') }}">Material</a>
            <a class="subnav__link" href="{{ url_for('ui.market_page') }}">Market</a>
            <a class="subnav__link" href="{{ url_for('ui.manufacturing_page') }}">Manufacturing</a>
            <a class="subnav__link" href="{{ url_for('ui.movers_page') }}">Movers</a>
            <a class="subnav__link" href="{{ url_for('ui.money_page') }}">Money</a>
            <a class="subnav__link" href="{{ url_for('ui.miscellaneous_page') }}">Miscellaneous</a>
            <a
                class="subnav__link"
                href="{{ url_for('ui.mechanism_page') }}"
                id="mechanism-link"
                hidden
            >Mechanism</a>
        </nav>
        <section class="section">
            <header class="section__header">
                <h1>People & capability overview</h1>
            </header>
            <p class="section__description">
                Manage the workforce pipeline by tracking available skills, upcoming shifts, and
                training requirements. Use this page to ensure the right technicians are ready for
                each maintenance job and production order.
            </p>
            <div class="section__grid">
                <article class="tile">
                    <h2 class="tile__title">Team roster</h2>
                    <p class="tile__description">
                        View key team members, their roles, and certification status. Identify coverage
                        gaps before they impact production schedules.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Training tracker</h2>
                    <p class="tile__description">
                        Monitor mandatory trainings, license renewals, and development plans to keep the
                        workforce compliant and skilled.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Shift planning</h2>
                    <p class="tile__description">
                        Align technician shifts with maintenance demand and active work orders. Balance
                        workloads to prevent burnout.
                    </p>
                </article>
                <article class="tile">
                    <h2 class="tile__title">Safety briefings</h2>
                    <p class="tile__description">
                        Document toolbox talks and safety observations. Share recurring hazards with the
                        wider team to improve awareness.
                    </p>
                </article>
            </div>
            <section class="responsibility-plan" aria-labelledby="responsibility-plan-heading">
                <div class="responsibility-plan__header">
                    <div>
                        <h2 class="responsibility-plan__title" id="responsibility-plan-heading">Responsibility plan</h2>
                        <p class="responsibility-plan__description">
                            Assign and monitor managerial responsibilities, plan recurring tasks, and keep everyone informed.
                        </p>
                    </div>
                    <div class="responsibility-plan__header-actions">
                        <button type="button" class="button button--primary" id="responsibility-create-button">
                            New responsibility
                        </button>
                    </div>
                </div>
                <div class="responsibility-plan__utilities">
                    <form class="responsibility-weekly-form" id="responsibility-weekly-form" novalidate>
                        <div class="responsibility-weekly-form__fields">
                            <label class="responsibility-weekly-form__label" for="responsibility-weekly-start">
                                Week starting
                                <input class="responsibility-weekly-form__input" id="responsibility-weekly-start" name="startDate" type="date" />
                            </label>
                            <label class="responsibility-weekly-form__label" for="responsibility-weekly-email">
                                Recipient email
                                <input
                                    class="responsibility-weekly-form__input"
                                    id="responsibility-weekly-email"
                                    name="recipientEmail"
                                    type="email"
                                    placeholder="name@example.com"
                                    required
                                />
                            </label>
                        </div>
                        <button type="submit" class="button button--secondary" id="responsibility-weekly-send">
                            Email Monday–Sunday plan
                        </button>
                    </form>
                    <p class="responsibility-plan__message" id="responsibility-weekly-message" hidden></p>
                </div>
                <div class="responsibility-plan__controls" id="responsibility-table-controls">
                    <div class="responsibility-plan__control-group">
                        <label class="responsibility-plan__control-label" for="responsibility-period-start">
                            Period start
                            <input
                                class="responsibility-plan__control-input"
                                id="responsibility-period-start"
                                name="periodStart"
                                type="date"
                            />
                        </label>
                        <label class="responsibility-plan__control-label" for="responsibility-period-end">
                            Period end
                            <input
                                class="responsibility-plan__control-input"
                                id="responsibility-period-end"
                                name="periodEnd"
                                type="date"
                            />
                        </label>
                        <button type="button" class="button button--ghost button--small" id="responsibility-period-clear">
                            Clear period
                        </button>
                    </div>
                    <div class="responsibility-plan__control-group">
                        <label class="responsibility-plan__control-label" for="responsibility-filter-column">
                            Filter column
                            <select
                                class="responsibility-plan__control-input"
                                id="responsibility-filter-column"
                                name="filterColumn"
                            ></select>
                        </label>
                        <label class="responsibility-plan__control-label" for="responsibility-filter-value">
                            Filter value
                            <input
                                class="responsibility-plan__control-input"
                                id="responsibility-filter-value"
                                name="filterValue"
                                type="text"
                                placeholder="Search responsibilities"
                                autocomplete="off"
                            />
                        </label>
                        <button type="button" class="button button--ghost button--small" id="responsibility-filter-clear">
                            Clear filter
                        </button>
                    </div>
                </div>
                <div class="table-container table-container--scrollable">
                    <table class="team-table responsibility-table">
                        <thead>
                            <tr>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="number">
                                        <span>Responsibility No</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="title">
                                        <span>Title</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="progress">
                                        <span>Progress</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="assigner">
                                        <span>Assigned by</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="assignee">
                                        <span>Assigned to</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="delegatedTo">
                                        <span>Delegated to</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="performanceUnit">
                                        <span>Unit of Measure</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button
                                        type="button"
                                        class="responsibility-table__sort-button"
                                        data-sort-key="performanceResponsible"
                                    >
                                        <span>Responsible</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button
                                        type="button"
                                        class="responsibility-table__sort-button"
                                        data-sort-key="performanceActual"
                                    >
                                        <span>Actual</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button
                                        type="button"
                                        class="responsibility-table__sort-button"
                                        data-sort-key="performanceMetric"
                                    >
                                        <span>Performance Metric</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="detail">
                                        <span>Detail</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button
                                        type="button"
                                        class="responsibility-table__sort-button"
                                        data-sort-key="scheduledFor"
                                    >
                                        <span>Scheduled for</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="action">
                                        <span>5D Action</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col" aria-sort="none">
                                    <button type="button" class="responsibility-table__sort-button" data-sort-key="createdAt">
                                        <span>Created</span>
                                        <span class="responsibility-table__sort-icon" aria-hidden="true">⇅</span>
                                    </button>
                                </th>
                                <th scope="col">Update</th>
                            </tr>
                        </thead>
                        <tbody id="responsibility-table-body"></tbody>
                    </table>
                </div>
                <p class="responsibility-plan__empty" id="responsibility-empty" hidden>
                    No responsibilities have been added yet.
                </p>
                <p class="responsibility-plan__message" id="responsibility-message" hidden></p>
            </section>
            <section class="responsibility-report" aria-labelledby="responsibility-report-heading">
                <div class="responsibility-report__header">
                    <div>
                        <h2 class="responsibility-report__title" id="responsibility-report-heading">Responsibilities by team member</h2>
                        <p class="responsibility-report__description">
                            Analyse how responsibilities are distributed across team members for a selected period, then export the insights for sharing.
                        </p>
                    </div>
                    <div class="responsibility-report__downloads" role="group" aria-label="Download responsibility report">
                        <button type="button" class="button button--ghost button--small" data-report-download="excel" disabled>
                            Download Excel
                        </button>
                        <button type="button" class="button button--ghost button--small" data-report-download="pdf" disabled>
                            Download PDF
                        </button>
                        <button type="button" class="button button--ghost button--small" data-report-download="png" disabled>
                            Download PNG
                        </button>
                    </div>
                </div>
                <form class="responsibility-report__filters" id="responsibility-report-form" novalidate>
                    <div class="responsibility-report__field">
                        <label for="responsibility-report-start">Start date</label>
                        <input class="responsibility-report__input" type="date" id="responsibility-report-start" name="startDate" required />
                    </div>
                    <div class="responsibility-report__field">
                        <label for="responsibility-report-end">End date</label>
                        <input class="responsibility-report__input" type="date" id="responsibility-report-end" name="endDate" required />
                    </div>
                    <div class="responsibility-report__field">
                        <label for="responsibility-report-member">Team member</label>
                        <select class="responsibility-report__select" id="responsibility-report-member" name="teamMemberId" required>
                            <option value="all">All team members</option>
                        </select>
                    </div>
                </form>
                <div class="responsibility-report__body">
                    <div class="responsibility-report__chart-container">
                        <canvas id="responsibility-report-chart" role="img" aria-label="Responsibilities per team member"></canvas>
                    </div>
                    <div class="responsibility-report__table-wrapper">
                        <table class="responsibility-report__table" aria-describedby="responsibility-report-heading">
                            <thead>
                                <tr>
                                    <th scope="col">Team member</th>
                                    <th scope="col">Occurrences</th>
                                    <th scope="col">Unique responsibilities</th>
                                </tr>
                            </thead>
                            <tbody id="responsibility-report-tbody"></tbody>
                        </table>
                        <p class="responsibility-report__empty" id="responsibility-report-empty" hidden>
                            No responsibilities recorded for the selected filters.
                        </p>
                    </div>
                </div>
                <p class="responsibility-report__summary" id="responsibility-report-summary"></p>
                <p class="responsibility-report__message" id="responsibility-report-message" hidden></p>
            </section>
            <section class="work-calendar" aria-labelledby="work-calendar-heading">
                <div class="work-calendar__header">
                    <div class="work-calendar__intro">
                        <h2 class="work-calendar__title" id="work-calendar-heading">Work calendar</h2>
                        <p class="work-calendar__description">
                            Plan working days and public holidays for the team. Times are shown in the Asia/Colombo timezone.
                        </p>
                    </div>
                    <div class="work-calendar__controls" role="group" aria-label="Select calendar month">
                        <label class="work-calendar__selector">
                            <span class="work-calendar__selector-label">Year</span>
                            <select class="edit-form__input work-calendar__select" id="work-calendar-year"></select>
                        </label>
                        <label class="work-calendar__selector">
                            <span class="work-calendar__selector-label">Month</span>
                            <select class="edit-form__input work-calendar__select" id="work-calendar-month"></select>
                        </label>
                    </div>
                </div>
                <div class="work-calendar__content">
                    <div class="work-calendar__weekdays" aria-hidden="true">
                        <span class="work-calendar__weekday">Mon</span>
                        <span class="work-calendar__weekday">Tue</span>
                        <span class="work-calendar__weekday">Wed</span>
                        <span class="work-calendar__weekday">Thu</span>
                        <span class="work-calendar__weekday">Fri</span>
                        <span class="work-calendar__weekday">Sat</span>
                        <span class="work-calendar__weekday">Sun</span>
                    </div>
                    <div class="work-calendar__grid" id="work-calendar-grid" role="grid" aria-labelledby="work-calendar-heading"></div>
                    <div class="work-calendar__loading" id="work-calendar-loading" hidden>
                        <span class="work-calendar__loading-text">Loading calendar…</span>
                    </div>
                </div>
                <p class="work-calendar__message" id="work-calendar-message" hidden></p>
            </section>
            <section class="team-directory" aria-labelledby="team-directory-heading">
                <h2 class="team-directory__title" id="team-directory-heading">Team members</h2>
                <div class="table-container">
                    <table class="team-table team-table--simple">
                        <thead>
                            <tr>
                                <th scope="col">ID</th>
                                <th scope="col">Reg No</th>
                                <th scope="col">Image</th>
                                <th scope="col">Name</th>
                                <th scope="col">Nickname</th>
                                <th scope="col">EPF</th>
                                <th scope="col">Position</th>
                                <th scope="col">Pay category</th>
                                <th scope="col">Join date</th>
                                <th scope="col">Status</th>
                                <th scope="col">Created at</th>
                                <th scope="col">Updated at</th>
                                <th scope="col">Personal detail</th>
                                <th scope="col">Assignments</th>
                                <th scope="col">Training records</th>
                                <th scope="col">Employment log</th>
                                <th scope="col">Files</th>
                                <th scope="col">Assets</th>
                                <th scope="col" id="team-update-column-header">Update</th>
                            </tr>
                        </thead>
                        <tbody id="team-table-body"></tbody>
                    </table>
                </div>
                <p class="team-directory__empty" id="team-empty-state" hidden>
                    No team members available yet.
                </p>
                <section class="team-form" id="team-form-section">
                    <h3 class="team-form__title">Register a team member</h3>
                    <p class="team-form__description">
                        Keep the roster current by logging new colleagues as soon as they join the team.
                    </p>
                    <p class="team-form__editing" id="team-form-editing" hidden>
                        Editing <strong id="team-form-editing-name"></strong>
                        <button type="button" class="button button--ghost button--small" id="team-form-cancel-edit">
                            Cancel
                        </button>
                    </p>
                    <div class="team-form__feedback">
                        <p class="alert alert--error" id="team-form-error" hidden></p>
                        <p class="alert alert--success" id="team-form-success" hidden></p>
                    </div>
                    <form class="edit-form" id="team-form">
                        <div class="edit-form__grid">
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-reg-number">
                                    Registration number <span class="required">*</span>
                                </label>
                                <input
                                    class="edit-form__input"
                                    id="team-reg-number"
                                    name="regNumber"
                                    type="text"
                                    autocomplete="off"
                                    required
                                />
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-name">
                                    Name <span class="required">*</span>
                                </label>
                                <input
                                    class="edit-form__input"
                                    id="team-name"
                                    name="name"
                                    type="text"
                                    autocomplete="name"
                                    required
                                />
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-nickname">Nickname</label>
                                <input
                                    class="edit-form__input"
                                    id="team-nickname"
                                    name="nickname"
                                    type="text"
                                    autocomplete="off"
                                />
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-epf">EPF number</label>
                                <input
                                    class="edit-form__input"
                                    id="team-epf"
                                    name="epf"
                                    type="text"
                                    autocomplete="off"
                                />
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-position">Position</label>
                                <input
                                    class="edit-form__input"
                                    id="team-position"
                                    name="position"
                                    type="text"
                                    autocomplete="organization-title"
                                />
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-pay-category">Pay category</label>
                                <select class="edit-form__input" id="team-pay-category" name="payCategory">
                                    <option value="Office" selected>Office</option>
                                    <option value="Factory">Factory</option>
                                    <option value="Casual">Casual</option>
                                    <option value="Loading">Loading</option>
                                    <option value="Transport">Transport</option>
                                    <option value="Maintenance">Maintenance</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-join-date">Date of join</label>
                                <input
                                    class="edit-form__input"
                                    id="team-join-date"
                                    name="joinDate"
                                    type="date"
                                />
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-status">Status</label>
                                <select class="edit-form__input" id="team-status" name="status">
                                    <option value="Active" selected>Active</option>
                                    <option value="On Leave">On Leave</option>
                                    <option value="Inactive">Inactive</option>
                                </select>
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-image">Profile image URL</label>
                                <input
                                    class="edit-form__input"
                                    id="team-image"
                                    name="image"
                                    type="url"
                                    inputmode="url"
                                    placeholder="https://example.com/profile.jpg"
                                />
                            </div>
                            <div class="edit-form__field edit-form__field--full">
                                <label class="edit-form__label" for="team-personal-detail">Personal detail</label>
                                <div class="team-form__bank-actions">
                                    <button
                                        type="button"
                                        class="button button--primary button--small"
                                        id="team-bank-detail-button"
                                    >
                                        Personal Detail
                                    </button>
                                    <p
                                        class="team-form__bank-summary team-form__bank-summary--empty"
                                        id="team-bank-detail-summary"
                                    >
                                        No personal detail added yet.
                                    </p>
                                </div>
                                <input type="hidden" id="team-bank-account-name" name="bankAccountName" />
                                <input type="hidden" id="team-bank-name" name="bankName" />
                                <input type="hidden" id="team-branch-name" name="branchName" />
                                <input type="hidden" id="team-bank-account-number" name="bankAccountNumber" />
                                <textarea
                                    class="edit-form__input"
                                    id="team-personal-detail"
                                    name="personalDetail"
                                    rows="3"
                                ></textarea>
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-assignments">Assignments</label>
                                <textarea
                                    class="edit-form__input"
                                    id="team-assignments"
                                    name="assignments"
                                    rows="3"
                                ></textarea>
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-training">Training records</label>
                                <textarea
                                    class="edit-form__input"
                                    id="team-training"
                                    name="trainingRecords"
                                    rows="3"
                                ></textarea>
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-employment-log">Employment log</label>
                                <textarea
                                    class="edit-form__input"
                                    id="team-employment-log"
                                    name="employmentLog"
                                    rows="3"
                                ></textarea>
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-files">Files</label>
                                <textarea
                                    class="edit-form__input"
                                    id="team-files"
                                    name="files"
                                    rows="3"
                                ></textarea>
                            </div>
                            <div class="edit-form__field">
                                <label class="edit-form__label" for="team-assets">Controlled assets</label>
                                <textarea
                                    class="edit-form__input"
                                    id="team-assets"
                                    name="assets"
                                    rows="3"
                                ></textarea>
                            </div>
                        </div>
                        <div class="edit-form__actions">
                            <button type="submit" class="button button--primary team-form__submit">Save member</button>
                            <button type="button" class="button button--ghost team-form__cancel" id="team-form-cancel-edit-footer" hidden>
                                Cancel edit
                            </button>
                        </div>
                    </form>
                </section>
                <section class="salary-section" aria-labelledby="salary-section-heading">
                    <div class="salary-section__header">
                        <h3 class="salary-section__title" id="salary-section-heading">Salary sheet</h3>
                        <p class="salary-section__description">
                            Record and review the monthly salary breakdown for every active employee.
                        </p>
                    </div>
                    <div class="salary-section__controls">
                        <div class="salary-summary" id="salary-summary" hidden>
                            <span class="salary-summary__label">Total Gross Salary</span>
                            <span class="salary-summary__value" id="salary-summary-total">—</span>
                            <div class="salary-summary__breakdown">
                                <span class="salary-summary__breakdown-item">
                                    <span class="salary-summary__breakdown-label">Factory</span>
                                    <span
                                        class="salary-summary__breakdown-value"
                                        id="salary-summary-factory"
                                    >—</span>
                                </span>
                                <span class="salary-summary__breakdown-item">
                                    <span class="salary-summary__breakdown-label">Casual</span>
                                    <span
                                        class="salary-summary__breakdown-value"
                                        id="salary-summary-casual"
                                    >—</span>
                                </span>
                            </div>
                        </div>
                        <label class="salary-section__month" for="salary-month-selector">
                            Salary month
                            <input
                                class="salary-section__month-input edit-form__input"
                                type="month"
                                id="salary-month-selector"
                                name="salaryMonth"
                            />
                        </label>
                    </div>
                    <div class="table-container">
                        <table class="team-table salary-table">
                            <thead>
                                <tr>
                                    <th scope="col">Reg No</th>
                                    <th scope="col">Name</th>
                                    <th scope="col">Basic Salary</th>
                                    <th scope="col">Day Salary</th>
                                    <th scope="col">General Allowance</th>
                                    <th scope="col">Transport Allowance</th>
                                    <th scope="col">Attendance Allowance</th>
                                    <th scope="col">Special Allowance</th>
                                    <th scope="col">Performance Bonus</th>
                                    <th scope="col">Total Day Salary</th>
                                    <th scope="col">Target Allowance</th>
                                    <th scope="col">Overtime</th>
                                    <th scope="col">Gross Salary</th>
                                    <th scope="col">Provident Fund</th>
                                    <th scope="col">Loan Deduction</th>
                                    <th scope="col">Meal Deduction</th>
                                    <th scope="col">Other Deduction</th>
                                    <th scope="col">Salary Advance</th>
                                    <th scope="col">No Pay</th>
                                    <th scope="col">Total Deduction</th>
                                    <th scope="col">Net Pay</th>
                                    <th scope="col">Record Attendance</th>
                                    <th scope="col">Manage Salary</th>
                                </tr>
                            </thead>
                            <tbody id="salary-table-body"></tbody>
                        </table>
                    </div>
                    <p class="salary-section__empty" id="salary-empty-state" hidden>
                        No active team members available for the selected month.
                    </p>
                </section>
                <section class="loading-pay" aria-labelledby="loading-pay-heading">
                    <div class="loading-pay__header">
                        <div>
                            <h3 class="loading-pay__title" id="loading-pay-heading">Loading Pay Sheet</h3>
                            <p class="loading-pay__description">
                                Review loading quantities and pay allocations calculated from actual sales entries.
                            </p>
                        </div>
                        <div class="loading-pay__filters" role="group" aria-label="Select loading pay period">
                            <label class="loading-pay__filter" for="loading-pay-month">
                                <span class="loading-pay__filter-label">Month</span>
                                <select class="edit-form__input loading-pay__select" id="loading-pay-month"></select>
                            </label>
                            <label class="loading-pay__filter" for="loading-pay-year">
                                <span class="loading-pay__filter-label">Year</span>
                                <select class="edit-form__input loading-pay__select" id="loading-pay-year"></select>
                            </label>
                        </div>
                    </div>
                    <p class="loading-pay__rate" id="loading-pay-rate-container">
                        Standard loading pay rate (Rs/kg):
                        <span class="loading-pay__rate-value" id="loading-pay-rate">—</span>
                    </p>
                    <div class="table-container loading-pay__table-container">
                        <table class="team-table loading-pay__table">
                            <thead>
                                <tr>
                                    <th scope="col">Reg No</th>
                                    <th scope="col">Name</th>
                                    <th scope="col">Loading Qty (kg)</th>
                                    <th scope="col">Loading Pay (Rs)</th>
                                </tr>
                            </thead>
                            <tbody id="loading-pay-table-body"></tbody>
                        </table>
                    </div>
                    <p class="loading-pay__empty" id="loading-pay-empty" hidden>
                        No loading activity for the selected period.
                    </p>
                    <p class="loading-pay__message" id="loading-pay-message" hidden></p>
                </section>
                <section class="loading-pay transport-pay" aria-labelledby="transport-pay-heading">
                    <div class="loading-pay__header">
                        <div>
                            <h3 class="loading-pay__title" id="transport-pay-heading">Transport Pay Sheet</h3>
                            <p class="loading-pay__description">
                                Review transport quantities and payments for drivers and helpers using the selected month and year.
                            </p>
                        </div>
                    </div>
                    <div class="table-container loading-pay__table-container transport-pay__table-container">
                        <table class="team-table loading-pay__table transport-pay__table">
                            <thead>
                                <tr>
                                    <th scope="col">Reg No</th>
                                    <th scope="col">Name</th>
                                    <th scope="col">Wood shaving Qty (Ton)</th>
                                    <th scope="col">Briquette Qty (Ton)</th>
                                    <th scope="col">Driver Payment (Rs.)</th>
                                    <th scope="col">Helper Payment (Rs.)</th>
                                    <th scope="col">Extra Payment (Rs.)</th>
                                    <th scope="col">Total Payment (Rs.)</th>
                                </tr>
                            </thead>
                            <tbody id="transport-pay-table-body"></tbody>
                        </table>
                    </div>
                    <p class="loading-pay__empty transport-pay__empty" id="transport-pay-empty" hidden>
                        No transport activity for the selected period.
                    </p>
                    <p class="loading-pay__message transport-pay__message" id="transport-pay-message" hidden></p>
                </section>
            </section>
        </section>
    </div>
    <div class="modal modal--app" id="responsibility-modal" hidden aria-hidden="true">
        <div class="modal__overlay" data-modal-dismiss></div>
        <div class="modal__content" role="dialog" aria-modal="true" aria-labelledby="responsibility-modal-title">
            <header class="modal__header">
                <h2 class="modal__title" id="responsibility-modal-title">New responsibility</h2>
                <button type="button" class="modal__close" id="responsibility-modal-close" aria-label="Close responsibility form">
                    <span aria-hidden="true">&times;</span>
                </button>
            </header>
            <div class="modal__body">
                <p class="modal__hint">Define the responsibility, choose the recurrence, and notify the appropriate manager.</p>
                <p class="alert alert--error" id="responsibility-form-error" hidden></p>
                <form class="edit-form" id="responsibility-form" novalidate>
                    <div class="edit-form__grid">
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-title">Title <span class="required">*</span></label>
                            <input class="edit-form__input" id="responsibility-title" name="title" type="text" required />
                        </div>
                        <div class="edit-form__field edit-form__field--full">
                            <label class="edit-form__label" for="responsibility-detail">Detail</label>
                            <textarea class="edit-form__input" id="responsibility-detail" name="detail" rows="3"></textarea>
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-date">First scheduled date <span class="required">*</span></label>
                            <input class="edit-form__input" id="responsibility-date" name="scheduledFor" type="date" required />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-recurrence">Recurrence <span class="required">*</span></label>
                            <select class="edit-form__input" id="responsibility-recurrence" name="recurrence" required>
                                <option value="does_not_repeat">Does not repeat</option>
                                <option value="monday_to_friday">Monday to Friday</option>
                                <option value="daily">Daily</option>
                                <option value="weekly">Weekly on (Today)</option>
                                <option value="monthly">Monthly on (Today)</option>
                                <option value="annually">Annually on (Today)</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>
                        <fieldset class="edit-form__field edit-form__field--full" id="responsibility-custom-days" hidden>
                            <legend class="edit-form__label">Custom weekdays <span class="required">*</span></legend>
                            <div class="responsibility-custom-weekdays" id="responsibility-custom-weekdays">
                                <label class="responsibility-custom-weekdays__option">
                                    <input type="checkbox" value="0" name="customWeekdays" />
                                    <span>Monday</span>
                                </label>
                                <label class="responsibility-custom-weekdays__option">
                                    <input type="checkbox" value="1" name="customWeekdays" />
                                    <span>Tuesday</span>
                                </label>
                                <label class="responsibility-custom-weekdays__option">
                                    <input type="checkbox" value="2" name="customWeekdays" />
                                    <span>Wednesday</span>
                                </label>
                                <label class="responsibility-custom-weekdays__option">
                                    <input type="checkbox" value="3" name="customWeekdays" />
                                    <span>Thursday</span>
                                </label>
                                <label class="responsibility-custom-weekdays__option">
                                    <input type="checkbox" value="4" name="customWeekdays" />
                                    <span>Friday</span>
                                </label>
                                <label class="responsibility-custom-weekdays__option">
                                    <input type="checkbox" value="5" name="customWeekdays" />
                                    <span>Saturday</span>
                                </label>
                                <label class="responsibility-custom-weekdays__option">
                                    <input type="checkbox" value="6" name="customWeekdays" />
                                    <span>Sunday</span>
                                </label>
                            </div>
                        </fieldset>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-assignee">Assign to <span class="required">*</span></label>
                            <select class="edit-form__input" id="responsibility-assignee" name="assigneeId" required>
                                <option value="">Select a team member</option>
                            </select>
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-action">5D Action <span class="required">*</span></label>
                            <select class="edit-form__input" id="responsibility-action" name="action" required>
                                <option value="">Select</option>
                                <option value="done">Done</option>
                                <option value="delegated">Delegated</option>
                                <option value="deferred">Deferred</option>
                                <option value="discussed">Discussed</option>
                                <option value="deleted">Deleted</option>
                            </select>
                        </div>
                        <div class="edit-form__field" id="responsibility-delegated-field" hidden>
                            <label class="edit-form__label" for="responsibility-delegations-list">Delegated team members <span class="required">*</span></label>
                            <div class="responsibility-delegations" id="responsibility-delegations">
                                <div class="responsibility-delegations__list" id="responsibility-delegations-list"></div>
                                <button
                                    type="button"
                                    class="button button--secondary button--small responsibility-delegations__add"
                                    id="responsibility-add-delegation"
                                >Add delegated team member</button>
                                <p class="edit-form__hint">Split the responsibility target among the team members below.</p>
                            </div>
                        </div>
                        <template id="responsibility-delegation-template">
                            <div class="responsibility-delegations__row">
                                <select class="edit-form__input responsibility-delegations__select" name="delegationManager"></select>
                                <input
                                    type="text"
                                    class="edit-form__input responsibility-delegations__value"
                                    name="delegationValue"
                                    inputmode="decimal"
                                    placeholder="Allocated value"
                                />
                                <button
                                    type="button"
                                    class="button button--ghost button--small responsibility-delegations__remove"
                                    aria-label="Remove delegated team member"
                                >Remove</button>
                            </div>
                        </template>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-progress">Progress (%)</label>
                            <input
                                class="edit-form__input"
                                id="responsibility-progress"
                                name="progress"
                                type="number"
                                min="0"
                                max="100"
                                step="1"
                                inputmode="numeric"
                                value="0"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-performance-unit">Unit of measure <span class="required">*</span></label>
                            <select
                                class="edit-form__input"
                                id="responsibility-performance-unit"
                                name="performanceUnit"
                                required
                            ></select>
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-performance-responsible">Responsible <span class="required">*</span></label>
                            <input
                                class="edit-form__input"
                                id="responsibility-performance-responsible"
                                name="performanceResponsible"
                                required
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-performance-actual">Actual</label>
                            <input
                                class="edit-form__input"
                                id="responsibility-performance-actual"
                                name="performanceActual"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="responsibility-performance-metric">Performance metric</label>
                            <input
                                class="edit-form__input"
                                id="responsibility-performance-metric"
                                type="text"
                                readonly
                                tabindex="-1"
                            />
                        </div>
                        <div class="edit-form__field edit-form__field--full">
                            <span class="edit-form__label">Email notifications</span>
                            <div class="edit-form__group edit-form__group--columns">
                                <div class="edit-form__subfield">
                                    <label class="edit-form__label--sub" for="responsibility-recipient">To <span class="required">*</span></label>
                                    <input
                                        class="edit-form__input"
                                        id="responsibility-recipient"
                                        name="recipientEmail"
                                        type="email"
                                        inputmode="email"
                                        required
                                        autocomplete="email"
                                    />
                                </div>
                                <div class="edit-form__subfield">
                                    <label class="edit-form__label--sub" for="responsibility-cc">CC</label>
                                    <input
                                        class="edit-form__input"
                                        id="responsibility-cc"
                                        name="ccEmail"
                                        type="email"
                                        inputmode="email"
                                        autocomplete="email"
                                        placeholder="name@example.com"
                                    />
                                </div>
                            </div>
                        </div>
                    </div>
                    <input type="hidden" id="responsibility-action-notes" name="actionNotes" />
                    <div class="modal__actions">
                        <button type="button" class="button button--ghost" id="responsibility-cancel">Cancel</button>
                        <button type="submit" class="button button--primary" id="responsibility-submit">Save responsibility</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <div class="modal modal--app" id="responsibility-action-notes-modal" hidden aria-hidden="true">
        <div class="modal__overlay" data-modal-dismiss></div>
        <div class="modal__content" role="dialog" aria-modal="true" aria-labelledby="responsibility-action-notes-title">
            <header class="modal__header">
                <h2 class="modal__title" id="responsibility-action-notes-title">Discussion details</h2>
                <button type="button" class="modal__close" id="responsibility-action-notes-close" aria-label="Close notes editor">
                    <span aria-hidden="true">&times;</span>
                </button>
            </header>
            <div class="modal__body">
                <p class="modal__hint">Record discussion points or reasons for the selected 5D action.</p>
                <p class="alert alert--error" id="responsibility-action-notes-error" hidden></p>
                <div class="edit-form__field edit-form__field--full">
                    <label class="edit-form__label" for="responsibility-action-notes-text">Notes <span class="required">*</span></label>
                    <textarea class="edit-form__input" id="responsibility-action-notes-text" rows="4"></textarea>
                </div>
                <div class="modal__actions">
                    <button type="button" class="button button--ghost" id="responsibility-action-notes-cancel">Cancel</button>
                    <button type="button" class="button button--primary" id="responsibility-action-notes-save">Save notes</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal modal--app" id="workday-modal" hidden aria-hidden="true">
        <div class="modal__overlay" data-modal-dismiss></div>
        <div class="modal__content" role="dialog" aria-modal="true" aria-labelledby="workday-modal-title">
            <header class="modal__header">
                <h2 class="modal__title" id="workday-modal-title">Update work day</h2>
                <button type="button" class="modal__close" id="workday-modal-close" aria-label="Close work day editor">
                    &times;
                </button>
            </header>
            <div class="modal__body">
                <form class="edit-form workday-form" id="workday-form">
                    <p class="workday-form__date" id="workday-form-date">—</p>
                    <fieldset class="workday-form__field-group">
                        <legend class="workday-form__label">Work status</legend>
                        <div class="workday-form__options">
                            <label class="workday-form__option">
                                <input type="radio" name="isWorkDay" value="true" id="workday-status-work" checked />
                                <span>Work day</span>
                            </label>
                            <label class="workday-form__option">
                                <input type="radio" name="isWorkDay" value="false" id="workday-status-off" />
                                <span>Not work day</span>
                            </label>
                        </div>
                    </fieldset>
                    <div class="edit-form__field">
                        <label class="edit-form__label" for="workday-holiday">Holiday name</label>
                        <input
                            class="edit-form__input"
                            id="workday-holiday"
                            name="holidayName"
                            type="text"
                            maxlength="120"
                            autocomplete="off"
                            placeholder="Enter holiday name"
                            disabled
                        />
                    </div>
                    <p class="workday-form__hint" id="workday-form-hint">
                        Holiday name is optional and only applies to non-working days.
                    </p>
                    <p class="workday-form__error" id="workday-form-error" hidden></p>
                    <div class="modal__actions">
                        <button type="button" class="button button--ghost" id="workday-modal-cancel">Cancel</button>
                        <button type="submit" class="button button--primary" id="workday-modal-save">Save day</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <div class="modal modal--app" id="attendance-modal" hidden aria-hidden="true">
        <div class="modal__overlay" data-modal-dismiss></div>
        <div
            class="modal__content"
            role="dialog"
            aria-modal="true"
            aria-labelledby="attendance-modal-title"
        >
            <header class="modal__header">
                <h2 class="modal__title" id="attendance-modal-title">Record attendance</h2>
                <button
                    type="button"
                    class="modal__close"
                    id="attendance-modal-close"
                    aria-label="Close attendance form"
                >
                    &times;
                </button>
            </header>
            <div class="modal__body">
                <form class="attendance-form" id="attendance-form">
                    <div class="attendance-form__summary salary-form__summary">
                        <p class="attendance-form__summary-item salary-form__summary-item">
                            <span class="attendance-form__summary-label salary-form__summary-label">Employee</span>
                            <span
                                class="attendance-form__summary-value salary-form__summary-value"
                                id="attendance-form-member-name"
                            >
                                —
                            </span>
                        </p>
                        <p class="attendance-form__summary-item salary-form__summary-item">
                            <span class="attendance-form__summary-label salary-form__summary-label">Reg No</span>
                            <span
                                class="attendance-form__summary-value salary-form__summary-value"
                                id="attendance-form-regno"
                            >
                                —
                            </span>
                        </p>
                        <p class="attendance-form__summary-item salary-form__summary-item">
                            <span class="attendance-form__summary-label salary-form__summary-label">Month</span>
                            <span
                                class="attendance-form__summary-value salary-form__summary-value"
                                id="attendance-summary-month"
                            >
                                —
                            </span>
                        </p>
                        <div class="attendance-summary__cards">
                            <div class="attendance-summary__totals">
                                <span class="attendance-summary__totals-label">Total Pay Hours</span>
                                <span class="attendance-summary__totals-main" id="attendance-total-pay-hours"
                                    >00:00</span
                                >
                                <div class="attendance-summary__totals-detail">
                                    <span class="attendance-summary__totals-sub-label">Regular Hours</span>
                                    <span
                                        class="attendance-summary__totals-sub-value"
                                        id="attendance-total-regular-hours"
                                    >00:00</span>
                                </div>
                                <div class="attendance-summary__totals-detail">
                                    <span class="attendance-summary__totals-sub-label">OT Hours</span>
                                    <span
                                        class="attendance-summary__totals-sub-value"
                                        id="attendance-total-ot-hours"
                                    >00:00</span>
                                </div>
                            </div>
                            <div class="attendance-summary__leave" aria-live="polite">
                                <h3 class="attendance-summary__leave-title">Leave summary</h3>
                                <dl class="attendance-summary__leave-list">
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">Workdays (month)</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-workdays"
                                        >—</dd>
                                    </div>
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">No-pay days (month)</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-nopay"
                                        >—</dd>
                                    </div>
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">Annual Leave B/F</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-annual-bf"
                                        >—</dd>
                                    </div>
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">Annual Leave (This Month)</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-annual-this"
                                        >—</dd>
                                    </div>
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">Annual Leave Balance</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-annual-balance"
                                        >—</dd>
                                    </div>
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">Medical Leave B/F</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-medical-bf"
                                        >—</dd>
                                    </div>
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">Medical Leave (This Month)</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-medical-this"
                                        >—</dd>
                                    </div>
                                    <div class="attendance-summary__leave-item">
                                        <dt class="attendance-summary__leave-term">Medical Leave Balance</dt>
                                        <dd
                                            class="attendance-summary__leave-value"
                                            id="attendance-leave-medical-balance"
                                        >—</dd>
                                    </div>
                                </dl>
                            </div>
                        </div>
                    </div>
                    <div class="table-container attendance-table-container">
                        <table class="team-table attendance-table">
                            <thead>
                                <tr>
                                    <th scope="col">Date</th>
                                    <th scope="col">On time</th>
                                    <th scope="col">Off time</th>
                                    <th scope="col">Actual hours</th>
                                    <th scope="col">Pay hours</th>
                                    <th scope="col">OT hours</th>
                                    <th scope="col">Day Status</th>
                                </tr>
                            </thead>
                            <tbody id="attendance-table-body"></tbody>
                        </table>
                    </div>
                    <div class="modal__actions">
                        <button
                            type="button"
                            class="button button--ghost"
                            id="attendance-modal-cancel"
                        >
                            Cancel
                        </button>
                        <button type="submit" class="button button--primary">Save attendance</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <div class="modal modal--app" id="salary-modal" hidden aria-hidden="true">
        <div class="modal__overlay" data-modal-dismiss></div>
        <div class="modal__content" role="dialog" aria-modal="true" aria-labelledby="salary-modal-title">
            <header class="modal__header">
                <h2 class="modal__title" id="salary-modal-title">Update salary</h2>
                <button type="button" class="modal__close" id="salary-modal-close" aria-label="Close salary form">
                    &times;
                </button>
            </header>
            <div class="modal__body">
                <form class="edit-form salary-form" id="salary-form">
                    <div class="salary-form__summary">
                        <p class="salary-form__summary-item">
                            <span class="salary-form__summary-label">Employee</span>
                            <span class="salary-form__summary-value" id="salary-form-member-name">—</span>
                        </p>
                        <p class="salary-form__summary-item">
                            <span class="salary-form__summary-label">Reg No</span>
                            <span class="salary-form__summary-value" id="salary-form-regno">—</span>
                        </p>
                    </div>
                    <div class="edit-form__grid salary-form__grid">
                        <div class="edit-form__field edit-form__field--full">
                            <label class="edit-form__label" for="salary-form-month">Salary month</label>
                            <input
                                class="edit-form__input"
                                type="month"
                                id="salary-form-month"
                                name="salaryMonth"
                                required
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-basic-salary">Basic salary</label>
                            <input class="edit-form__input" type="number" step="0.01" id="salary-basic-salary" name="basicSalary" />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-day-salary">Day salary</label>
                            <input class="edit-form__input" type="number" step="0.01" id="salary-day-salary" name="daySalary" />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-general-allowance">General allowance</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-general-allowance"
                                name="generalAllowance"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-transport-allowance">Transport allowance</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-transport-allowance"
                                name="transportAllowance"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-attendance-allowance">Attendance allowance</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-attendance-allowance"
                                name="attendanceAllowance"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-special-allowance">Special allowance</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-special-allowance"
                                name="specialAllowance"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-performance-bonus">Performance bonus</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-performance-bonus"
                                name="performanceBonus"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-production">Total Day Salary</label>
                            <input class="edit-form__input" type="number" step="0.01" id="salary-production" name="production" />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-target-allowance">Target allowance</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-target-allowance"
                                name="targetAllowance"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-overtime">Overtime</label>
                            <input class="edit-form__input" type="number" step="0.01" id="salary-overtime" name="overtime" />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-casual-ot-rate">Casual OT Rate</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-casual-ot-rate"
                                name="casualOtRate"
                                placeholder="Enter Casual OT Rate"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-gross-salary">Gross salary</label>
                            <input class="edit-form__input" type="number" step="0.01" id="salary-gross-salary" name="grossSalary" />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-provident-fund">Provident fund</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-provident-fund"
                                name="providentFund"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-loan-deduction">Loan deduction</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                min="0"
                                id="salary-loan-deduction"
                                name="loanDeduction"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-meal-deduction">Meal deduction</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                min="0"
                                id="salary-meal-deduction"
                                name="mealDeduction"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-other-deduction">Other deduction</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-other-deduction"
                                name="otherDeduction"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-salary-advance">Salary advance</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-salary-advance"
                                name="salaryAdvance"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-no-pay">No pay</label>
                            <input class="edit-form__input" type="number" step="0.01" id="salary-no-pay" name="noPay" />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-total-deduction">Total deduction</label>
                            <input
                                class="edit-form__input"
                                type="number"
                                step="0.01"
                                id="salary-total-deduction"
                                name="totalDeduction"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="salary-net-pay">Net pay</label>
                            <input class="edit-form__input" type="number" step="0.01" id="salary-net-pay" name="netPay" />
                        </div>
                    </div>
                    <div class="modal__actions">
                        <button type="button" class="button button--ghost" id="salary-modal-cancel">Cancel</button>
                        <button type="submit" class="button button--primary">Save salary</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <div class="modal modal--app" id="bank-detail-modal" hidden aria-hidden="true">
        <div class="modal__overlay" data-modal-dismiss></div>
        <div
            class="modal__content"
            role="dialog"
            aria-modal="true"
            aria-labelledby="bank-detail-modal-title"
        >
            <header class="modal__header modal__header--with-actions">
                <h2 class="modal__title" id="bank-detail-modal-title">Personal detail</h2>
                <div class="modal__header-actions">
                    <button
                        type="button"
                        class="button button--ghost button--small"
                        id="bank-detail-edit-toggle"
                        hidden
                    >
                        Edit
                    </button>
                    <button
                        type="button"
                        class="modal__close"
                        id="bank-detail-modal-close"
                        aria-label="Close personal detail editor"
                    >
                        &times;
                    </button>
                </div>
            </header>
            <div class="modal__body">
                <form class="edit-form" id="bank-detail-form">
                    <p class="modal__hint" id="bank-detail-modal-hint"></p>
                    <p class="alert alert--error" id="bank-detail-error" hidden></p>
                    <p class="alert alert--success" id="bank-detail-success" hidden></p>
                    <div class="edit-form__grid">
                        <div class="edit-form__field edit-form__field--full">
                            <label class="edit-form__label" for="bank-detail-account-name">Bank account name</label>
                            <input
                                class="edit-form__input"
                                id="bank-detail-account-name"
                                name="bankAccountName"
                                type="text"
                                autocomplete="off"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="bank-detail-bank-name">Bank name</label>
                            <input
                                class="edit-form__input"
                                id="bank-detail-bank-name"
                                name="bankName"
                                type="text"
                                autocomplete="off"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="bank-detail-branch-name">Branch name</label>
                            <input
                                class="edit-form__input"
                                id="bank-detail-branch-name"
                                name="branchName"
                                type="text"
                                autocomplete="off"
                            />
                        </div>
                        <div class="edit-form__field">
                            <label class="edit-form__label" for="bank-detail-account-number">Bank account number</label>
                            <input
                                class="edit-form__input"
                                id="bank-detail-account-number"
                                name="bankAccountNumber"
                                type="text"
                                inputmode="numeric"
                                autocomplete="off"
                            />
                        </div>
                    </div>
                    <div class="modal__actions">
                        <button type="button" class="button button--ghost" id="bank-detail-modal-cancel">Cancel</button>
                        <button type="submit" class="button button--primary" id="bank-detail-save-button">
                            Save details
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js" integrity="sha384-8FmKpVzVfU6Ly3OJUokHknsE+Fjr12JOP5tBxOBE31AyGdSzZsv/CrKHr2TRVsyG" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js" crossorigin="anonymous"></script>
    <script src="{{ url_for('static', filename='js/responsibility-report.js') }}"></script>
    <script>
        const token = localStorage.getItem("samprox_token");
        const userRaw = localStorage.getItem("samprox_user");
        let user;

        try {
            user = userRaw ? JSON.parse(userRaw) : null;
        } catch (_) {
            user = null;
        }

        if (!token || !user) {
            window.location.href = "/";
        }

        if (user?.role === "outside_manager" && window.location.pathname !== "/responsibility_portal") {
            window.location.replace("/responsibility_portal");
        }

        if (user?.role === "maintenance_manager" && window.location.pathname !== "/machines") {
            window.location.replace("/machines");
        }
        if (user?.role === "sales_manager" && window.location.pathname !== "/sales/dashboard") {
            window.location.replace("/sales/dashboard");
        }

        const roleLabels = {
            admin: "Admin",
            production_manager: "Production Manager",
            maintenance_manager: "Maintenance Manager",
            finance_manager: "Finance Manager",
            technician: "Technician",
            outside_manager: "Member Of Rainbow Group",
            sales_manager: "Sales Manager",
        };

        const userNameEl = document.getElementById("user-name");
        const userRoleEl = document.getElementById("user-role");
        const logoutButton = document.getElementById("logout");
        const mechanismLink = document.getElementById("mechanism-link");

        userNameEl.textContent = user?.name || "Unknown";
        userRoleEl.textContent = roleLabels[user?.role] || "";
        if (mechanismLink) {
            if (user?.role === "admin") {
                mechanismLink.hidden = false;
            } else {
                mechanismLink.remove();
            }
        }

        logoutButton.addEventListener("click", async () => {
            try {
                await fetch("/api/auth/logout", { method: "POST", credentials: "include" });
            } catch (error) {
                console.error("Failed to log out", error);
            } finally {
                localStorage.removeItem("samprox_token");
                localStorage.removeItem("samprox_user");
                window.location.href = "/";
            }
        });

        const authHeaders = {
            Accept: "application/json",
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
        };

        const responsibilityTableBody = document.getElementById("responsibility-table-body");
        const responsibilityEmptyState = document.getElementById("responsibility-empty");
        const responsibilityMessage = document.getElementById("responsibility-message");
        const responsibilityPeriodStartInput = document.getElementById("responsibility-period-start");
        const responsibilityPeriodEndInput = document.getElementById("responsibility-period-end");
        const responsibilityPeriodClearButton = document.getElementById("responsibility-period-clear");
        const responsibilityFilterColumnSelect = document.getElementById("responsibility-filter-column");
        const responsibilityFilterValueInput = document.getElementById("responsibility-filter-value");
        const responsibilityFilterClearButton = document.getElementById("responsibility-filter-clear");
        const responsibilitySortButtons = document.querySelectorAll(".responsibility-table__sort-button");
        const responsibilityReportForm = document.getElementById("responsibility-report-form");
        const responsibilityReportStart = document.getElementById("responsibility-report-start");
        const responsibilityReportEnd = document.getElementById("responsibility-report-end");
        const responsibilityReportMember = document.getElementById("responsibility-report-member");
        const responsibilityReportSummary = document.getElementById("responsibility-report-summary");
        const responsibilityReportMessage = document.getElementById("responsibility-report-message");
        const responsibilityReportTableBody = document.getElementById("responsibility-report-tbody");
        const responsibilityReportEmpty = document.getElementById("responsibility-report-empty");
        const responsibilityReportChart = document.getElementById("responsibility-report-chart");
        const responsibilityReportDownloads = document.querySelectorAll(
            ".responsibility-report [data-report-download]"
        );
        const responsibilityWeeklyForm = document.getElementById("responsibility-weekly-form");
        const responsibilityWeeklyMessage = document.getElementById("responsibility-weekly-message");
        const responsibilityWeeklyStartInput = document.getElementById("responsibility-weekly-start");
        const responsibilityWeeklyEmailInput = document.getElementById("responsibility-weekly-email");
        const responsibilityWeeklySendButton = document.getElementById("responsibility-weekly-send");
        const responsibilityCreateButton = document.getElementById("responsibility-create-button");
        const responsibilityModal = document.getElementById("responsibility-modal");
        const responsibilityModalTitle = document.getElementById("responsibility-modal-title");
        const responsibilityModalClose = document.getElementById("responsibility-modal-close");
        const responsibilityCancelButton = document.getElementById("responsibility-cancel");
        const responsibilityForm = document.getElementById("responsibility-form");
        const responsibilityFormError = document.getElementById("responsibility-form-error");
        const responsibilityTitleInput = document.getElementById("responsibility-title");
        const responsibilityDateInput = document.getElementById("responsibility-date");
        const responsibilityRecurrenceSelect = document.getElementById("responsibility-recurrence");
        const responsibilityCustomDays = document.getElementById("responsibility-custom-days");
        const responsibilityCustomWeekdays = document.getElementById("responsibility-custom-weekdays");
        const responsibilityAssigneeSelect = document.getElementById("responsibility-assignee");
        const responsibilityDetailInput = document.getElementById("responsibility-detail");
        const responsibilityActionSelect = document.getElementById("responsibility-action");
        const responsibilityDelegatedField = document.getElementById("responsibility-delegated-field");
        const responsibilityDelegationsContainer = document.getElementById("responsibility-delegations");
        const responsibilityDelegationsList = document.getElementById("responsibility-delegations-list");
        const responsibilityAddDelegationButton = document.getElementById("responsibility-add-delegation");
        const responsibilityDelegationTemplate = document.getElementById("responsibility-delegation-template");
        const responsibilityProgressInput = document.getElementById("responsibility-progress");
        const responsibilityPerformanceUnitSelect = document.getElementById("responsibility-performance-unit");
        const responsibilityPerformanceResponsibleInput = document.getElementById(
            "responsibility-performance-responsible",
        );
        const responsibilityPerformanceActualInput = document.getElementById(
            "responsibility-performance-actual",
        );
        const responsibilityPerformanceMetricInput = document.getElementById("responsibility-performance-metric");
        const responsibilityRecipientInput = document.getElementById("responsibility-recipient");
        const responsibilityCcInput = document.getElementById("responsibility-cc");
        const responsibilityActionNotesInput = document.getElementById("responsibility-action-notes");
        const responsibilitySubmitButton = document.getElementById("responsibility-submit");
        const responsibilityModalOverlay = responsibilityModal?.querySelector("[data-modal-dismiss]");
        const responsibilityActionNotesModal = document.getElementById("responsibility-action-notes-modal");
        const responsibilityActionNotesClose = document.getElementById("responsibility-action-notes-close");
        const responsibilityActionNotesTextarea = document.getElementById("responsibility-action-notes-text");
        const responsibilityActionNotesError = document.getElementById("responsibility-action-notes-error");
        const responsibilityActionNotesSave = document.getElementById("responsibility-action-notes-save");
        const responsibilityActionNotesCancel = document.getElementById("responsibility-action-notes-cancel");
        const responsibilityActionNotesOverlay = responsibilityActionNotesModal?.querySelector("[data-modal-dismiss]");
        const responsibilityModalDefaultTitle =
            responsibilityModalTitle?.textContent?.trim() || "New responsibility";
        const responsibilitySubmitDefaultText =
            responsibilitySubmitButton?.textContent?.trim() || "Save responsibility";
        let responsibilityEditingTaskId = null;
        let responsibilityEditingTask = null;

        const RESPONSIBILITY_WEEKDAY_NAMES = [
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
            "Sunday",
        ];
        const ACTIONS_REQUIRING_NOTES = new Set(["discussed", "deferred", "deleted"]);
        let responsibilityActionPreviousValue = responsibilityActionSelect?.value || "";
        let responsibilityActionModalPreviousValue = null;

        let responsibilityTasks = [];
        let responsibilityAssignees = [];
        const responsibilityAssigneeLookup = new Map();
        let responsibilitySortKey = null;
        let responsibilitySortDirection = "ascending";
        let responsibilityFilterColumn = "all";
        let responsibilityFilterQuery = "";
        let responsibilityPeriodStart = "";
        let responsibilityPeriodEnd = "";
        const responsibilityEmptyDefaultText = responsibilityEmptyState?.textContent?.trim() || "";
        const responsibilityEmptyFilteredText = "No responsibilities match the selected filters.";

        const preferNonEmptyString = (...values) => {
            for (const value of values) {
                if (typeof value !== "string") {
                    continue;
                }

                const trimmed = value.trim();
                if (trimmed) {
                    return trimmed;
                }
            }

            return "";
        };

        const assignerNameFallback = (user) =>
            preferNonEmptyString(
                user?.nickname,
                user?.displayName,
                user?.name,
                user?.regNumber,
                user?.reg_number,
                user?.email,
            );

        const getMemberDisplayName = (member) => {
            const candidates = [member?.nickname, member?.name, member?.regNumber];

            for (const candidate of candidates) {
                if (typeof candidate === "string") {
                    const trimmed = candidate.trim();
                    if (trimmed) {
                        return trimmed;
                    }
                }
            }

            return "Team member";
        };

        const getCachedResponsibilityMember = (id) => {
            if (id === null || id === undefined) {
                return null;
            }

            const normalized = String(id).trim();
            if (!normalized) {
                return null;
            }

            const lookupRecord = responsibilityAssigneeLookup.get(normalized);
            if (lookupRecord) {
                return lookupRecord;
            }

            return responsibilityAssignees.find((assignee) => String(assignee.id) === normalized) || null;
        };

        const getCachedResponsibilityMemberDisplay = (id) => {
            if (id === null || id === undefined) {
                return "";
            }

            const normalized = String(id).trim();
            if (!normalized) {
                return "";
            }

            const record = getCachedResponsibilityMember(id);
            if (!record) {
                return "";
            }

            return assignerNameFallback(record) || normalized;
        };

        const getResponsibilityAssigneeDisplay = (task) => {
            if (!task) {
                return "";
            }

            const idCandidates = [task?.assigneeId, task?.assignee_id, task?.assignee?.id];
            for (const candidate of idCandidates) {
                const stored = getCachedResponsibilityMemberDisplay(candidate);
                if (stored) {
                    return stored;
                }
            }

            return (
                assignerNameFallback(task?.assignee) ||
                preferNonEmptyString(
                    task?.assigneeNickname,
                    task?.assigneeName,
                    task?.assigneeEmail,
                )
            );
        };

        const getResponsibilityAssignerDisplay = (task) => {
            if (!task) {
                return "";
            }

            return (
                assignerNameFallback(task?.assigner) ||
                preferNonEmptyString(
                    task?.assignerNickname,
                    task?.assignerName,
                    task?.assignerEmail,
                )
            );
        };

        const PERFORMANCE_DEFAULT_UNIT = "percentage_pct";
        const PERFORMANCE_UNIT_VALUES = [
            "date",
            "time",
            "hours",
            "minutes",
            "days",
            "weeks",
            "months",
            "years",
            "quantity_based",
            "qty",
            "units",
            "pieces",
            "batches",
            "items",
            "parcels",
            "orders",
            "amount_lkr",
            "revenue",
            "cost",
            "expense",
            "profit",
            "savings",
            "margin_pct",
            "number",
            "count",
            "score",
            "frequency",
            "rate",
            "index",
            "kg",
            "tonnes",
            "litres",
            "meters",
            "kwh",
            "rpm",
            "quality_metric",
            "percentage_pct",
            "error_rate_pct",
            "success_rate_pct",
            "defects_per_unit",
            "accuracy_pct",
            "compliance_pct",
            "time_per_unit",
            "units_per_hour",
            "cycle_time",
            "lead_time",
            "customer_count",
            "leads",
            "conversion_pct",
            "tickets_resolved",
            "response_time",
            "milestones",
            "stages",
            "completion_pct",
            "tasks_completed",
            "sla_pct",
        ];

        const PERFORMANCE_LABEL_OVERRIDES = {
            quantity_based: "Quantity-based",
            qty: "Quantity (Qty)",
            amount_lkr: "Amount (LKR)",
            kg: "Kilograms (kg)",
            kwh: "kWh",
            rpm: "RPM",
            quality_metric: "Quality Metrics",
            percentage_pct: "Percentage (%)",
            margin_pct: "Margin (%)",
            error_rate_pct: "Error Rate (%)",
            success_rate_pct: "Success Rate (%)",
            accuracy_pct: "Accuracy (%)",
            compliance_pct: "Compliance (%)",
            conversion_pct: "Conversion (%)",
            completion_pct: "Completion (%)",
            sla_pct: "SLA (%)",
            time_per_unit: "Time per Unit",
            units_per_hour: "Units per Hour",
            cycle_time: "Cycle Time",
            lead_time: "Lead Time",
            response_time: "Response Time (Minutes/Hours)",
            customer_count: "Customer Count",
            tickets_resolved: "Tickets Resolved",
            tasks_completed: "Tasks Completed",
        };

        const PERFORMANCE_INTEGER_UNITS = new Set([
            "quantity_based",
            "qty",
            "units",
            "pieces",
            "batches",
            "items",
            "parcels",
            "orders",
            "number",
            "count",
            "score",
            "frequency",
            "rate",
            "index",
            "customer_count",
            "leads",
            "tickets_resolved",
            "milestones",
            "stages",
            "tasks_completed",
        ]);

        const PERFORMANCE_PERCENT_UNITS = new Set([
            "margin_pct",
            "percentage_pct",
            "error_rate_pct",
            "success_rate_pct",
            "accuracy_pct",
            "compliance_pct",
            "conversion_pct",
            "completion_pct",
            "sla_pct",
        ]);

        const PERFORMANCE_CURRENCY_UNITS = new Set([
            "amount_lkr",
            "revenue",
            "cost",
            "expense",
            "profit",
            "savings",
        ]);

        const PERFORMANCE_DATE_UNITS = new Set(["date"]);
        const PERFORMANCE_TIME_UNITS = new Set(["time"]);
        const PERFORMANCE_DURATION_UNITS = new Set([
            "hours",
            "minutes",
            "days",
            "weeks",
            "months",
            "years",
            "time_per_unit",
            "units_per_hour",
            "cycle_time",
            "lead_time",
            "response_time",
        ]);

        const PERFORMANCE_DECIMAL_STEP_UNITS = new Set([
            "kg",
            "tonnes",
            "litres",
            "meters",
            "kwh",
            "rpm",
            "quality_metric",
            "defects_per_unit",
        ]);

        const populateDelegationSelectOptions = (select, selectedValue = "") => {
            if (!select) {
                return;
            }
            const selectedOption = select.selectedOptions?.[0];
            const previousLabel = selectedOption?.textContent ?? "";
            const previousValue = selectedValue || select.value;
            select.innerHTML = "";
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Select a team member";
            select.appendChild(placeholder);

            responsibilityAssignees.forEach((assignee) => {
                if (!assignee?.id) {
                    return;
                }
                const option = document.createElement("option");
                option.value = String(assignee.id);
                option.textContent = assignerNameFallback(assignee) || option.value;
                if (String(assignee.id) === String(previousValue)) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            if (previousValue && !select.value) {
                const fallbackOption = document.createElement("option");
                fallbackOption.value = String(previousValue);
                fallbackOption.textContent = previousLabel || String(previousValue);
                fallbackOption.selected = true;
                select.appendChild(fallbackOption);
            }
        };

        const clearResponsibilityDelegations = () => {
            if (responsibilityDelegationsList) {
                responsibilityDelegationsList.innerHTML = "";
            }
        };

        const createDelegationRow = (initialData = {}) => {
            if (!responsibilityDelegationsList) {
                return null;
            }

            let row = null;
            if (responsibilityDelegationTemplate?.content) {
                const clone = responsibilityDelegationTemplate.content.cloneNode(true);
                row = clone.querySelector(".responsibility-delegations__row");
            }

            if (!row) {
                row = document.createElement("div");
                row.className = "responsibility-delegations__row";
                const selectElement = document.createElement("select");
                selectElement.className = "edit-form__input responsibility-delegations__select";
                row.appendChild(selectElement);
                const valueElement = document.createElement("input");
                valueElement.type = "text";
                valueElement.className = "edit-form__input responsibility-delegations__value";
                row.appendChild(valueElement);
                const removeElement = document.createElement("button");
                removeElement.type = "button";
                removeElement.className = "button button--ghost button--small responsibility-delegations__remove";
                removeElement.textContent = "Remove";
                row.appendChild(removeElement);
            }

            const selectElement = row.querySelector(".responsibility-delegations__select");
            const valueElement = row.querySelector(".responsibility-delegations__value");
            const removeElement = row.querySelector(".responsibility-delegations__remove");

            const delegateId =
                initialData?.delegateId ?? initialData?.delegate_id ?? initialData?.delegate?.id ?? "";
            populateDelegationSelectOptions(selectElement, delegateId);

            if (
                delegateId &&
                selectElement &&
                selectElement.value !== String(delegateId)
            ) {
                const fallbackOption = document.createElement("option");
                fallbackOption.value = String(delegateId);
                fallbackOption.textContent =
                    assignerNameFallback(initialData?.delegate) || String(delegateId);
                selectElement.appendChild(fallbackOption);
                selectElement.value = String(delegateId);
            }

            if (valueElement) {
                const allocation =
                    initialData?.allocatedValue ??
                    initialData?.allocated_value ??
                    initialData?.allocation ??
                    "";
                valueElement.value = allocation !== null && allocation !== undefined ? String(allocation) : "";
            }

            if (removeElement) {
                removeElement.addEventListener("click", () => {
                    row.remove();
                });
            }

            responsibilityDelegationsList.appendChild(row);
            return row;
        };

        const ensureDelegationRow = () => {
            if (responsibilityDelegationsList?.childElementCount === 0) {
                createDelegationRow();
            }
        };

        const updateDelegationSelectOptions = () => {
            if (!responsibilityDelegationsList) {
                return;
            }
            responsibilityDelegationsList
                .querySelectorAll(".responsibility-delegations__select")
                .forEach((selectElement) => {
                    populateDelegationSelectOptions(selectElement);
                });
        };

        const PERFORMANCE_CURRENCY_FORMATTER = new Intl.NumberFormat(undefined, {
            style: "currency",
            currency: "LKR",
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        });

        const PERFORMANCE_NUMBER_FORMATTERS = new Map();
        const PERFORMANCE_EPOCH_MS = Date.UTC(1970, 0, 1);

        const getNumberFormatter = (decimals = 2) => {
            const key = Number(decimals);
            if (!PERFORMANCE_NUMBER_FORMATTERS.has(key)) {
                PERFORMANCE_NUMBER_FORMATTERS.set(
                    key,
                    new Intl.NumberFormat(undefined, {
                        minimumFractionDigits: Math.max(0, decimals),
                        maximumFractionDigits: Math.max(0, decimals),
                    }),
                );
            }
            return PERFORMANCE_NUMBER_FORMATTERS.get(key);
        };

        const toTitleCase = (value) =>
            String(value || "")
                .replace(/_/g, " ")
                .replace(/\b\w/g, (letter) => letter.toUpperCase());

        const getPerformanceConfig = (unitValue) => {
            const normalized = (unitValue || PERFORMANCE_DEFAULT_UNIT).toString().trim() || PERFORMANCE_DEFAULT_UNIT;
            const label = PERFORMANCE_LABEL_OVERRIDES[normalized] || toTitleCase(normalized);
            const config = {
                value: normalized,
                label,
                input: "number",
                format: "decimal",
                step: "0.1",
                decimals: 2,
                metricDecimals: 1,
            };

            if (PERFORMANCE_DATE_UNITS.has(normalized)) {
                config.input = "date";
                config.format = "date";
                config.decimals = 0;
                config.metricDecimals = 0;
            } else if (PERFORMANCE_TIME_UNITS.has(normalized)) {
                config.input = "time";
                config.format = "time";
                config.decimals = 0;
                config.metricDecimals = 0;
            } else if (PERFORMANCE_PERCENT_UNITS.has(normalized)) {
                config.format = "percentage";
                config.step = "0.1";
                config.decimals = 1;
                config.metricDecimals = 1;
            } else if (PERFORMANCE_CURRENCY_UNITS.has(normalized)) {
                config.format = "currency";
                config.step = "0.01";
                config.decimals = 2;
                config.metricDecimals = 2;
            } else if (PERFORMANCE_INTEGER_UNITS.has(normalized)) {
                config.format = "integer";
                config.step = "1";
                config.decimals = 0;
                config.metricDecimals = 0;
            } else if (PERFORMANCE_DURATION_UNITS.has(normalized)) {
                config.step = "0.1";
                config.decimals = 2;
                config.metricDecimals = 1;
            } else if (PERFORMANCE_DECIMAL_STEP_UNITS.has(normalized)) {
                config.step = "0.01";
                config.decimals = 2;
                config.metricDecimals = 2;
            }

            return config;
        };

        const roundHalfAwayFromZero = (value, decimals = 0) => {
            if (!Number.isFinite(value)) {
                return value;
            }
            const factor = 10 ** decimals;
            if (value >= 0) {
                return Math.round(value * factor) / factor;
            }
            return -Math.round(Math.abs(value) * factor) / factor;
        };

        const parsePerformanceInputValue = (rawValue, unitValue, config) => {
            const value = rawValue == null ? "" : rawValue.toString().trim();
            if (!value) {
                return { numeric: null, isBlank: true, isValid: true };
            }

            if (config.format === "date") {
                const parsed = new Date(`${value}T00:00:00Z`);
                if (Number.isNaN(parsed.getTime())) {
                    return { numeric: null, isBlank: false, isValid: false };
                }
                const days = Math.floor((parsed.getTime() - PERFORMANCE_EPOCH_MS) / 86_400_000);
                return { numeric: days, isBlank: false, isValid: true };
            }

            if (config.format === "time") {
                const parts = value.split(":");
                if (parts.length < 2) {
                    return { numeric: null, isBlank: false, isValid: false };
                }
                const hours = Number.parseInt(parts[0], 10);
                const minutes = Number.parseInt(parts[1], 10);
                if (!Number.isFinite(hours) || Number.isNaN(minutes)) {
                    return { numeric: null, isBlank: false, isValid: false };
                }
                return { numeric: hours * 60 + minutes, isBlank: false, isValid: true };
            }

            const numeric = Number.parseFloat(value);
            if (!Number.isFinite(numeric)) {
                return { numeric: null, isBlank: false, isValid: false };
            }
            return { numeric, isBlank: false, isValid: true };
        };

        const formatNumberWithDecimals = (value, decimals = 2) => {
            if (!Number.isFinite(value)) {
                return String(value ?? "");
            }
            return getNumberFormatter(decimals).format(value);
        };

        const formatPerformanceValueDisplay = (rawValue, unitValue, config) => {
            if (rawValue === null || rawValue === undefined || rawValue === "") {
                return "—";
            }
            if (config.format === "date" || config.format === "time") {
                return rawValue;
            }
            const numeric = Number.parseFloat(rawValue);
            if (!Number.isFinite(numeric)) {
                return rawValue;
            }
            if (config.format === "currency") {
                return PERFORMANCE_CURRENCY_FORMATTER.format(numeric);
            }
            if (config.format === "percentage") {
                return `${formatNumberWithDecimals(numeric, config.decimals ?? 1)}%`;
            }
            const decimals = config.format === "integer" ? 0 : config.decimals ?? 2;
            return formatNumberWithDecimals(numeric, decimals);
        };

        const formatTimeDifference = (minutes) => {
            if (!Number.isFinite(minutes)) {
                return "—";
            }
            if (minutes === 0) {
                return "0m";
            }
            const prefix = minutes > 0 ? "+" : "-";
            const absolute = Math.abs(Math.trunc(minutes));
            const hours = Math.floor(absolute / 60);
            const mins = absolute % 60;
            const parts = [];
            if (hours > 0) {
                parts.push(`${hours}h`);
            }
            if (mins > 0 || hours === 0) {
                parts.push(`${mins}m`);
            }
            return `${prefix}${parts.join(" ")}`;
        };

        const formatPerformanceMetricDisplay = (rawMetric, unitValue, config) => {
            if (rawMetric === null || rawMetric === undefined || rawMetric === "") {
                return "—";
            }
            const metric = Number.parseFloat(rawMetric);
            if (!Number.isFinite(metric)) {
                return "—";
            }
            if (config.format === "date") {
                if (metric === 0) {
                    return "0 days";
                }
                const suffix = Math.abs(metric) === 1 ? "day" : "days";
                return `${metric > 0 ? "+" : ""}${metric} ${suffix}`;
            }
            if (config.format === "time") {
                return formatTimeDifference(metric);
            }
            if (config.format === "currency") {
                const formatted = PERFORMANCE_CURRENCY_FORMATTER.format(metric);
                return metric > 0 ? `+${formatted}` : formatted;
            }
            if (config.format === "percentage") {
                const absolute = Math.abs(metric);
                const formatted = formatNumberWithDecimals(absolute, config.metricDecimals ?? 1);
                if (metric === 0) {
                    return `${formatted}%`;
                }
                return `${metric > 0 ? "+" : "-"}${formatted}%`;
            }
            const decimals = config.format === "integer" ? 0 : config.metricDecimals ?? 1;
            const formatted = formatNumberWithDecimals(Math.abs(metric), decimals);
            if (metric === 0) {
                return formatted;
            }
            return `${metric > 0 ? "+" : "-"}${formatted}`;
        };

        const calculatePerformanceMetricNumeric = (unitValue, responsibleNumeric, actualNumeric, config) => {
            if (!Number.isFinite(responsibleNumeric) || !Number.isFinite(actualNumeric)) {
                return null;
            }
            if (config.format === "date" || config.format === "time") {
                return actualNumeric - responsibleNumeric;
            }
            return roundHalfAwayFromZero(actualNumeric - responsibleNumeric, config.metricDecimals ?? 1);
        };

        const populatePerformanceUnitOptions = () => {
            if (!responsibilityPerformanceUnitSelect) {
                return;
            }
            responsibilityPerformanceUnitSelect.innerHTML = "";
            PERFORMANCE_UNIT_VALUES.forEach((unit) => {
                const config = getPerformanceConfig(unit);
                const option = document.createElement("option");
                option.value = unit;
                option.textContent = config.label;
                responsibilityPerformanceUnitSelect.appendChild(option);
            });
        };

        const getSelectedPerformanceConfig = () => {
            const unitValue = responsibilityPerformanceUnitSelect?.value || PERFORMANCE_DEFAULT_UNIT;
            return getPerformanceConfig(unitValue);
        };

        const applyPerformanceInputAttributes = (input, config) => {
            if (!input) {
                return;
            }
            if (config.input === "date") {
                input.type = "date";
                input.removeAttribute("step");
                input.removeAttribute("min");
                input.removeAttribute("max");
                input.removeAttribute("inputmode");
            } else if (config.input === "time") {
                input.type = "time";
                input.step = "60";
                input.removeAttribute("min");
                input.removeAttribute("max");
                input.removeAttribute("inputmode");
            } else {
                input.type = "number";
                if (config.step) {
                    input.step = config.step;
                } else {
                    input.removeAttribute("step");
                }
                if (config.min !== undefined) {
                    input.min = String(config.min);
                } else {
                    input.removeAttribute("min");
                }
                if (config.max !== undefined) {
                    input.max = String(config.max);
                } else {
                    input.removeAttribute("max");
                }
                input.inputMode = config.format === "integer" ? "numeric" : "decimal";
            }
        };

        const updatePerformanceUnitState = () => {
            const config = getSelectedPerformanceConfig();
            applyPerformanceInputAttributes(responsibilityPerformanceResponsibleInput, config);
            applyPerformanceInputAttributes(responsibilityPerformanceActualInput, config);
        };

        const updatePerformanceMetricDisplay = () => {
            if (!responsibilityPerformanceMetricInput) {
                return;
            }
            const config = getSelectedPerformanceConfig();
            const unitValue = config.value;
            const responsibleState = parsePerformanceInputValue(
                responsibilityPerformanceResponsibleInput?.value,
                unitValue,
                config,
            );
            const actualState = parsePerformanceInputValue(
                responsibilityPerformanceActualInput?.value,
                unitValue,
                config,
            );

            if (!responsibleState.isValid) {
                responsibilityPerformanceMetricInput.value = "—";
                return;
            }

            if (actualState.isBlank || !actualState.isValid) {
                responsibilityPerformanceMetricInput.value = "—";
                return;
            }

            const metricNumeric = calculatePerformanceMetricNumeric(
                unitValue,
                responsibleState.numeric,
                actualState.numeric,
                config,
            );
            responsibilityPerformanceMetricInput.value = formatPerformanceMetricDisplay(
                metricNumeric,
                unitValue,
                config,
            );
        };

        const responsibilityDateFormatter = new Intl.DateTimeFormat(undefined, {
            year: "numeric",
            month: "short",
            day: "2-digit",
        });

        const responsibilityDateTimeFormatter = new Intl.DateTimeFormat(undefined, {
            year: "numeric",
            month: "short",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
        });

        const toIsoDateString = (dateObj) => {
            if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) {
                return "";
            }
            const year = dateObj.getFullYear();
            const month = String(dateObj.getMonth() + 1).padStart(2, "0");
            const day = String(dateObj.getDate()).padStart(2, "0");
            return `${year}-${month}-${day}`;
        };

        const ordinalSuffix = (value) => {
            const v = Number.parseInt(value, 10);
            if (!Number.isFinite(v)) {
                return "";
            }
            const remainder = v % 100;
            if (remainder >= 11 && remainder <= 13) {
                return `${v}th`;
            }
            const lastDigit = v % 10;
            if (lastDigit === 1) return `${v}st`;
            if (lastDigit === 2) return `${v}nd`;
            if (lastDigit === 3) return `${v}rd`;
            return `${v}th`;
        };

        const formatResponsibilityDate = (iso) => {
            if (!iso) {
                return "—";
            }
            const parts = parseIsoDate(iso);
            if (!parts) {
                return "—";
            }
            const displayDate = new Date(Date.UTC(parts.year, parts.month - 1, parts.day));
            return responsibilityDateFormatter.format(displayDate);
        };

        const formatResponsibilityDateTime = (value) => {
            if (!value) {
                return "—";
            }
            const dateValue = new Date(value);
            if (Number.isNaN(dateValue.getTime())) {
                return "—";
            }
            return responsibilityDateTimeFormatter.format(dateValue);
        };

        const formatResponsibilityStatus = (status) => {
            if (!status) {
                return "Planned";
            }
            const normalized = String(status).replace(/_/g, " ").toLowerCase();
            return normalized.replace(/(^|\s)([a-z])/g, (_, space, letter) => `${space}${letter.toUpperCase()}`);
        };

        const formatResponsibilityAction = (action) => {
            if (!action) {
                return "—";
            }
            const normalized = String(action).replace(/_/g, " ").toLowerCase();
            return normalized.replace(/(^|\s)([a-z])/g, (_, space, letter) => `${space}${letter.toUpperCase()}`);
        };

        const formatResponsibilityDelegations = (delegations, unitValue, performanceConfig) => {
            if (!Array.isArray(delegations) || delegations.length === 0) {
                return "—";
            }

            const parts = delegations
                .map((entry) => {
                    if (!entry) {
                        return null;
                    }
                    const delegate =
                        entry.delegate ?? entry.delegate_member ?? entry.delegateMember ?? {};
                    const idCandidates = [
                        entry.delegateId,
                        entry.delegate_id,
                        entry.delegateMemberId,
                        entry.delegate_member_id,
                        delegate?.id,
                    ];

                    let name = "";
                    for (const candidate of idCandidates) {
                        const stored = getCachedResponsibilityMemberDisplay(candidate);
                        if (stored) {
                            name = stored;
                            break;
                        }
                    }

                    if (!name) {
                        name =
                            assignerNameFallback(delegate) ||
                            preferNonEmptyString(
                                entry?.delegateNickname,
                                entry?.delegateName,
                                entry?.delegateEmail,
                            );
                    }

                    if (!name) {
                        const fallbackId = idCandidates.find(
                            (value) => value !== null && value !== undefined && String(value).trim(),
                        );
                        if (fallbackId !== undefined) {
                            name = String(fallbackId).trim();
                        }
                    }

                    const rawValue =
                        entry.allocatedValue ??
                        entry.allocated_value ??
                        entry.value ??
                        "";
                    let formatted = rawValue;
                    if (rawValue !== null && rawValue !== undefined && rawValue !== "") {
                        formatted = formatPerformanceValueDisplay(rawValue, unitValue, performanceConfig);
                    }
                    if (name && formatted && formatted !== "—") {
                        return `${name} (${formatted})`;
                    }
                    return name || null;
                })
                .filter(Boolean);

            return parts.length > 0 ? parts.join(", ") : "—";
        };

        const PROGRESS_COLOR_RED = [217, 45, 32];
        const PROGRESS_COLOR_YELLOW = [254, 200, 75];
        const PROGRESS_COLOR_GREEN = [18, 183, 106];
        const PROGRESS_COLOR_GRAY = [152, 162, 179];

        const clampProgressValue = (value) => {
            if (value === null || value === undefined || value === "") {
                return 0;
            }
            const parsed = Number.parseFloat(value);
            if (Number.isNaN(parsed)) {
                return 0;
            }
            const rounded = Math.round(parsed);
            return Math.min(100, Math.max(0, rounded));
        };

        const interpolateProgressColor = (start, end, ratio) => {
            return start.map((component, index) => component + (end[index] - component) * ratio);
        };

        const toRgbString = (components) => {
            const [r, g, b] = components.map((component) => Math.round(component));
            return `rgb(${r}, ${g}, ${b})`;
        };

        const resolveProgressColor = (value, action) => {
            if (action === "deleted") {
                return toRgbString(PROGRESS_COLOR_GRAY);
            }
            if (value <= 0) {
                return toRgbString(PROGRESS_COLOR_RED);
            }
            if (value >= 100) {
                return toRgbString(PROGRESS_COLOR_GREEN);
            }
            if (value <= 50) {
                const ratio = value / 50;
                const color = interpolateProgressColor(PROGRESS_COLOR_RED, PROGRESS_COLOR_YELLOW, ratio);
                return toRgbString(color);
            }
            const ratio = (value - 50) / 50;
            const color = interpolateProgressColor(PROGRESS_COLOR_YELLOW, PROGRESS_COLOR_GREEN, ratio);
            return toRgbString(color);
        };

        const resolveProgressTextColor = (value, action) => {
            if (action === "deleted") {
                return "#1D2939";
            }
            return value >= 45 ? "#FFFFFF" : "#1D2939";
        };

        const renderResponsibilityProgress = (task) => {
            const action = task?.action || "";
            const progressValue = clampProgressValue(task?.progress);
            const statusText = formatResponsibilityStatus(task?.status);
            const displayText = `${progressValue}%`;
            const color = resolveProgressColor(progressValue, action);
            const textColor = resolveProgressTextColor(progressValue, action);
            const ariaText = statusText ? `${displayText} complete – ${statusText}` : `${displayText} complete`;
            const tooltipText = statusText ? `${displayText} complete • ${statusText}` : `${displayText} complete`;

            const container = document.createElement("div");
            container.className = "responsibility-progress";

            const track = document.createElement("div");
            track.className = "responsibility-progress__track";
            track.setAttribute("role", "progressbar");
            track.setAttribute("aria-valuemin", "0");
            track.setAttribute("aria-valuemax", "100");
            track.setAttribute("aria-valuenow", String(progressValue));
            track.setAttribute("aria-valuetext", ariaText);
            track.title = tooltipText;

            const fill = document.createElement("div");
            fill.className = "responsibility-progress__fill";
            fill.style.width = `${progressValue}%`;
            fill.style.backgroundColor = color;
            if (progressValue > 0) {
                fill.style.minWidth = "4px";
            }

            const text = document.createElement("span");
            text.className = "responsibility-progress__text";
            text.textContent = displayText;
            text.style.color = textColor;

            track.append(fill, text);
            container.append(track);

            return container;
        };

        const setResponsibilityActionNotesError = (message = "") => {
            if (!responsibilityActionNotesError) {
                return;
            }
            if (!message) {
                responsibilityActionNotesError.hidden = true;
                responsibilityActionNotesError.textContent = "";
                return;
            }
            responsibilityActionNotesError.hidden = false;
            responsibilityActionNotesError.textContent = message;
        };

        const updateDelegatedVisibility = (actionValue) => {
            if (!responsibilityDelegatedField) {
                return;
            }
            const requiresDelegated = actionValue === "delegated";
            responsibilityDelegatedField.hidden = !requiresDelegated;
            if (requiresDelegated) {
                ensureDelegationRow();
            } else {
                clearResponsibilityDelegations();
            }
        };

        const openResponsibilityActionNotesModal = (previousValue) => {
            if (!responsibilityActionNotesModal) {
                return;
            }
            responsibilityActionModalPreviousValue = previousValue ?? responsibilityActionPreviousValue;
            setResponsibilityActionNotesError();
            if (responsibilityActionNotesTextarea && responsibilityActionNotesInput) {
                responsibilityActionNotesTextarea.value = responsibilityActionNotesInput.value || "";
            }
            responsibilityActionNotesModal.removeAttribute("hidden");
            responsibilityActionNotesModal.setAttribute("aria-hidden", "false");
            responsibilityActionNotesModal.classList.add("modal--open");
            responsibilityActionNotesTextarea?.focus();
        };

        const closeResponsibilityActionNotesModal = (revertSelection = false) => {
            if (!responsibilityActionNotesModal) {
                return;
            }
            responsibilityActionNotesModal.classList.remove("modal--open");
            responsibilityActionNotesModal.setAttribute("hidden", "");
            responsibilityActionNotesModal.setAttribute("aria-hidden", "true");
            setResponsibilityActionNotesError();
            if (revertSelection && responsibilityActionSelect) {
                const fallback = responsibilityActionModalPreviousValue ?? "";
                responsibilityActionSelect.value = fallback;
                responsibilityActionPreviousValue = fallback;
                updateDelegatedVisibility(fallback);
                if (!ACTIONS_REQUIRING_NOTES.has(fallback) && responsibilityActionNotesInput) {
                    responsibilityActionNotesInput.value = "";
                }
            }
            responsibilityActionModalPreviousValue = null;
        };

        const handleResponsibilityActionChange = () => {
            if (!responsibilityActionSelect) {
                return;
            }
            const newValue = responsibilityActionSelect.value;
            const previousValue = responsibilityActionPreviousValue;
            responsibilityActionPreviousValue = newValue;
            updateDelegatedVisibility(newValue);

            if (responsibilityProgressInput) {
                if (newValue === "done" || newValue === "deleted") {
                    if (!responsibilityProgressInput.readOnly) {
                        responsibilityProgressInput.dataset.progressPrevious =
                            responsibilityProgressInput.value &&
                            responsibilityProgressInput.value !== "100"
                                ? responsibilityProgressInput.value
                                : responsibilityProgressInput.dataset.progressPrevious || "0";
                    }
                    responsibilityProgressInput.value = "100";
                    responsibilityProgressInput.readOnly = true;
                } else {
                    if (responsibilityProgressInput.readOnly) {
                        const previousProgress = responsibilityProgressInput.dataset.progressPrevious;
                        if (previousProgress !== undefined) {
                            responsibilityProgressInput.value = previousProgress || "0";
                        }
                    }
                    responsibilityProgressInput.readOnly = false;
                    delete responsibilityProgressInput.dataset.progressPrevious;
                }
            }

            if (!ACTIONS_REQUIRING_NOTES.has(newValue)) {
                if (responsibilityActionNotesInput) {
                    responsibilityActionNotesInput.value = "";
                }
                return;
            }

            openResponsibilityActionNotesModal(previousValue);
        };

        updateDelegatedVisibility(responsibilityActionPreviousValue);

        if (responsibilityPerformanceUnitSelect) {
            populatePerformanceUnitOptions();
            if (!responsibilityPerformanceUnitSelect.value) {
                responsibilityPerformanceUnitSelect.value = PERFORMANCE_DEFAULT_UNIT;
            }
            updatePerformanceUnitState();
        }
        if (responsibilityPerformanceMetricInput) {
            responsibilityPerformanceMetricInput.value = "—";
        }
        updatePerformanceMetricDisplay();

        responsibilityPerformanceUnitSelect?.addEventListener("change", () => {
            updatePerformanceUnitState();
            updatePerformanceMetricDisplay();
        });
        responsibilityPerformanceResponsibleInput?.addEventListener(
            "input",
            updatePerformanceMetricDisplay,
        );
        responsibilityPerformanceActualInput?.addEventListener(
            "input",
            updatePerformanceMetricDisplay,
        );

        const setPlanMessage = (element, message = "", tone = "info") => {
            if (!element) {
                return;
            }
            element.classList.remove(
                "responsibility-plan__message--error",
                "responsibility-plan__message--success",
            );
            if (!message) {
                element.hidden = true;
                element.textContent = "";
                return;
            }
            element.hidden = false;
            element.textContent = message;
            if (tone === "error") {
                element.classList.add("responsibility-plan__message--error");
            } else if (tone === "success") {
                element.classList.add("responsibility-plan__message--success");
            }
        };

        const extractFirstErrorMessage = (errors) => {
            if (!errors) {
                return null;
            }
            if (typeof errors === "string") {
                return errors.trim() || null;
            }
            if (Array.isArray(errors)) {
                for (const entry of errors) {
                    const message = extractFirstErrorMessage(entry);
                    if (message) {
                        return message;
                    }
                }
                return null;
            }
            if (typeof errors === "object") {
                for (const value of Object.values(errors)) {
                    const message = extractFirstErrorMessage(value);
                    if (message) {
                        return message;
                    }
                }
            }
            return null;
        };

        const clearResponsibilityFormError = () => {
            if (!responsibilityFormError) {
                return;
            }
            responsibilityFormError.hidden = true;
            responsibilityFormError.textContent = "";
        };

        const showResponsibilityFormError = (message) => {
            if (!responsibilityFormError) {
                return;
            }
            responsibilityFormError.hidden = false;
            responsibilityFormError.textContent = message;
        };

        const toggleCustomWeekdayFieldset = () => {
            if (!responsibilityCustomDays || !responsibilityRecurrenceSelect) {
                return;
            }
            const isCustom = responsibilityRecurrenceSelect.value === "custom";
            responsibilityCustomDays.hidden = !isCustom;
        };

        const updateRecurrenceOptionLabels = () => {
            if (!responsibilityRecurrenceSelect) {
                return;
            }
            const dateValue = responsibilityDateInput?.value?.trim();
            const parts = dateValue ? parseIsoDate(dateValue) : null;
            let weeklyLabel = "Weekly on (Today)";
            let monthlyLabel = "Monthly on (Today)";
            let annuallyLabel = "Annually on (Today)";

            if (parts) {
                const displayDate = new Date(Date.UTC(parts.year, parts.month - 1, parts.day));
                const weekdayName = RESPONSIBILITY_WEEKDAY_NAMES[displayDate.getUTCDay() === 0 ? 6 : displayDate.getUTCDay() - 1];
                weeklyLabel = `Weekly on ${weekdayName}`;
                monthlyLabel = `Monthly on the ${ordinalSuffix(parts.day)}`;
                annuallyLabel = displayDate.toLocaleDateString(undefined, {
                    month: "long",
                    day: "numeric",
                });
                annuallyLabel = `Annually on ${annuallyLabel}`;
            }

            Array.from(responsibilityRecurrenceSelect.options).forEach((option) => {
                if (option.value === "weekly") {
                    option.textContent = weeklyLabel;
                } else if (option.value === "monthly") {
                    option.textContent = monthlyLabel;
                } else if (option.value === "annually") {
                    option.textContent = annuallyLabel;
                }
            });
        };

        const resetResponsibilityFormState = () => {
            if (responsibilityForm) {
                responsibilityForm.reset();
            }
            responsibilityEditingTaskId = null;
            responsibilityEditingTask = null;
            clearResponsibilityDelegations();
            if (responsibilityModalTitle) {
                responsibilityModalTitle.textContent = responsibilityModalDefaultTitle;
            }
            if (responsibilitySubmitButton) {
                responsibilitySubmitButton.textContent = responsibilitySubmitDefaultText;
                responsibilitySubmitButton.disabled = false;
            }
            if (responsibilityCustomWeekdays) {
                responsibilityCustomWeekdays
                    .querySelectorAll("input[type='checkbox']")
                    .forEach((input) => {
                        input.checked = false;
                    });
            }
            if (responsibilityActionSelect) {
                responsibilityActionSelect.value = "";
            }
            responsibilityActionPreviousValue = responsibilityActionSelect?.value || "";
            updateDelegatedVisibility(responsibilityActionPreviousValue);
            if (responsibilityActionNotesInput) {
                responsibilityActionNotesInput.value = "";
            }
            if (responsibilityActionNotesTextarea) {
                responsibilityActionNotesTextarea.value = "";
            }
            if (responsibilityProgressInput) {
                responsibilityProgressInput.value = "0";
                responsibilityProgressInput.readOnly = false;
                delete responsibilityProgressInput.dataset.progressPrevious;
            }
            if (responsibilityPerformanceUnitSelect) {
                responsibilityPerformanceUnitSelect.value = PERFORMANCE_DEFAULT_UNIT;
            }
            if (responsibilityPerformanceResponsibleInput) {
                responsibilityPerformanceResponsibleInput.value = "";
            }
            if (responsibilityPerformanceActualInput) {
                responsibilityPerformanceActualInput.value = "";
            }
            if (responsibilityPerformanceMetricInput) {
                responsibilityPerformanceMetricInput.value = "—";
            }
            updatePerformanceUnitState();
            updatePerformanceMetricDisplay();
            toggleCustomWeekdayFieldset();
            updateRecurrenceOptionLabels();
            clearResponsibilityFormError();
            closeResponsibilityActionNotesModal();
        };

        const closeResponsibilityModal = () => {
            if (!responsibilityModal) {
                return;
            }
            responsibilityModal.classList.remove("modal--open");
            responsibilityModal.setAttribute("hidden", "");
            responsibilityModal.setAttribute("aria-hidden", "true");
            document.body.classList.remove("modal-open");
            resetResponsibilityFormState();
        };

        const openResponsibilityModal = (task = null) => {
            if (!responsibilityModal) {
                return;
            }
            resetResponsibilityFormState();

            const isEditing = task && typeof task === "object";

            if (isEditing) {
                const parsedId = Number.parseInt(task.id, 10);
                responsibilityEditingTaskId = Number.isNaN(parsedId) ? null : parsedId;
                responsibilityEditingTask = task;
                if (responsibilityModalTitle) {
                    responsibilityModalTitle.textContent = "Update responsibility";
                }
                if (responsibilitySubmitButton) {
                    responsibilitySubmitButton.textContent = "Update responsibility";
                }
                if (responsibilityTitleInput) {
                    responsibilityTitleInput.value = task.title ?? "";
                }
                if (responsibilityDetailInput) {
                    responsibilityDetailInput.value = task.detail ?? "";
                }
                if (responsibilityDateInput) {
                    responsibilityDateInput.value = task.scheduledFor ?? "";
                }
                if (responsibilityRecurrenceSelect) {
                    const recurrenceValue = task.recurrence || "does_not_repeat";
                    responsibilityRecurrenceSelect.value = recurrenceValue;
                }
                toggleCustomWeekdayFieldset();

                const performanceUnit = task.performanceUnit || PERFORMANCE_DEFAULT_UNIT;
                const performanceConfig = getPerformanceConfig(performanceUnit);
                if (responsibilityPerformanceUnitSelect) {
                    responsibilityPerformanceUnitSelect.value = performanceUnit;
                }
                updatePerformanceUnitState();
                if (responsibilityPerformanceResponsibleInput) {
                    responsibilityPerformanceResponsibleInput.value = task.performanceResponsible ?? "";
                }
                if (responsibilityPerformanceActualInput) {
                    responsibilityPerformanceActualInput.value = task.performanceActual ?? "";
                }
                if (responsibilityPerformanceMetricInput) {
                    responsibilityPerformanceMetricInput.value = formatPerformanceMetricDisplay(
                        task.performanceMetric,
                        performanceUnit,
                        performanceConfig,
                    );
                }
                updatePerformanceMetricDisplay();

                if (responsibilityCustomWeekdays) {
                    const selectedWeekdays = new Set(
                        Array.isArray(task.customWeekdays)
                            ? task.customWeekdays.map((value) => Number.parseInt(value, 10))
                            : [],
                    );
                    responsibilityCustomWeekdays
                        .querySelectorAll("input[type='checkbox']")
                        .forEach((input) => {
                            const inputValue = Number.parseInt(input.value, 10);
                            input.checked = selectedWeekdays.has(inputValue);
                        });
                }

                const ensureSelectOption = (select, taskData) => {
                    if (!select || !taskData) {
                        return;
                    }
                    const idCandidates = [
                        taskData?.assigneeId,
                        taskData?.assignee_id,
                        taskData?.assignee?.id,
                    ];
                    const candidateId = idCandidates.find(
                        (value) => value !== null && value !== undefined && String(value).trim() !== "",
                    );
                    if (candidateId === undefined) {
                        return;
                    }
                    const value = String(candidateId);
                    let option = select.querySelector(`option[value="${value}"]`);
                    const label =
                        assignerNameFallback(taskData?.assignee) ||
                        preferNonEmptyString(
                            taskData?.assigneeNickname,
                            taskData?.assigneeName,
                            taskData?.assigneeEmail,
                        );
                    if (!option) {
                        option = document.createElement("option");
                        option.value = value;
                        option.textContent = label ? label.trim() : value;
                        select.appendChild(option);
                    } else if (!option.textContent?.trim()) {
                        option.textContent = label ? label.trim() : value;
                    }
                    responsibilityAssigneeLookup.set(value, {
                        id: value,
                        name: option.textContent,
                        type:
                            taskData?.assigneeType ||
                            (taskData?.assignee && typeof taskData.assignee === "object"
                                ? "user"
                                : undefined),
                    });
                    select.value = value;
                };

                ensureSelectOption(responsibilityAssigneeSelect, task);

                clearResponsibilityDelegations();
                if (Array.isArray(task.delegations) && task.delegations.length > 0) {
                    task.delegations.forEach((delegation) => {
                        createDelegationRow({
                            delegateId:
                                delegation?.delegateId ??
                                delegation?.delegate_id ??
                                delegation?.delegate?.id ??
                                null,
                            allocatedValue:
                                delegation?.allocatedValue ??
                                delegation?.allocated_value ??
                                "",
                        });
                    });
                }

                const actionValue = task.action || "done";
                if (responsibilityActionSelect) {
                    responsibilityActionSelect.value = actionValue;
                }
                responsibilityActionPreviousValue = actionValue;
                updateDelegatedVisibility(actionValue);

                if (responsibilityProgressInput) {
                    const progressValue = clampProgressValue(task?.progress);
                    responsibilityProgressInput.value = String(progressValue);
                    if (actionValue === "done" || actionValue === "deleted") {
                        responsibilityProgressInput.readOnly = true;
                        delete responsibilityProgressInput.dataset.progressPrevious;
                    } else {
                        responsibilityProgressInput.readOnly = false;
                        delete responsibilityProgressInput.dataset.progressPrevious;
                    }
                }

                if (responsibilityActionNotesInput) {
                    responsibilityActionNotesInput.value = task.actionNotes || "";
                }
                if (responsibilityActionNotesTextarea) {
                    responsibilityActionNotesTextarea.value = task.actionNotes || "";
                }

                if (responsibilityRecipientInput) {
                    responsibilityRecipientInput.value = task.recipientEmail || "";
                }
                if (responsibilityCcInput) {
                    responsibilityCcInput.value = task.ccEmail || "";
                }
            } else {
                if (responsibilityDateInput) {
                    const today = new Date();
                    responsibilityDateInput.value = toIsoDateString(today);
                }
                responsibilityActionPreviousValue = responsibilityActionSelect?.value || "";
                clearResponsibilityDelegations();
                updateDelegatedVisibility(responsibilityActionPreviousValue);
                if (responsibilityProgressInput) {
                    responsibilityProgressInput.value = "0";
                    responsibilityProgressInput.readOnly = false;
                    delete responsibilityProgressInput.dataset.progressPrevious;
                }
                if (responsibilityPerformanceUnitSelect) {
                    responsibilityPerformanceUnitSelect.value = PERFORMANCE_DEFAULT_UNIT;
                }
                updatePerformanceUnitState();
                if (responsibilityPerformanceResponsibleInput) {
                    responsibilityPerformanceResponsibleInput.value = "";
                }
                if (responsibilityPerformanceActualInput) {
                    responsibilityPerformanceActualInput.value = "";
                }
                if (responsibilityPerformanceMetricInput) {
                    responsibilityPerformanceMetricInput.value = "—";
                }
                updatePerformanceMetricDisplay();
                if (responsibilityCcInput) {
                    responsibilityCcInput.value = "";
                }
            }

        updateRecurrenceOptionLabels();
        responsibilityModal.removeAttribute("hidden");
        responsibilityModal.setAttribute("aria-hidden", "false");
        responsibilityModal.classList.add("modal--open");
        document.body.classList.add("modal-open");
        responsibilityTitleInput?.focus();
        };

        const getNormalizedDateString = (value) => {
            if (!value) {
                return "";
            }

            if (value instanceof Date) {
                if (Number.isNaN(value.getTime())) {
                    return "";
                }
                const year = String(value.getFullYear()).padStart(4, "0");
                const month = String(value.getMonth() + 1).padStart(2, "0");
                const day = String(value.getDate()).padStart(2, "0");
                return `${year}-${month}-${day}`;
            }

            if (typeof value === "string") {
                const trimmed = value.trim();
                if (!trimmed) {
                    return "";
                }
                if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
                    return trimmed;
                }
                const parsed = new Date(trimmed);
                if (Number.isNaN(parsed.getTime())) {
                    return "";
                }
                const year = String(parsed.getFullYear()).padStart(4, "0");
                const month = String(parsed.getMonth() + 1).padStart(2, "0");
                const day = String(parsed.getDate()).padStart(2, "0");
                return `${year}-${month}-${day}`;
            }

            try {
                const parsed = new Date(value);
                if (Number.isNaN(parsed.getTime())) {
                    return "";
                }
                const year = String(parsed.getFullYear()).padStart(4, "0");
                const month = String(parsed.getMonth() + 1).padStart(2, "0");
                const day = String(parsed.getDate()).padStart(2, "0");
                return `${year}-${month}-${day}`;
            } catch (_) {
                return "";
            }
        };

        const sanitizeFilterValue = (value) => {
            if (value === null || value === undefined) {
                return "";
            }

            if (value instanceof Date) {
                return getNormalizedDateString(value);
            }

            if (typeof value === "number") {
                return Number.isFinite(value) ? String(value) : "";
            }

            if (typeof value === "string") {
                const trimmed = value.trim();
                if (!trimmed || trimmed === "—") {
                    return "";
                }
                return trimmed;
            }

            return String(value);
        };

        const getTaskPerformanceContext = (task) => {
            const unitValue = task?.performanceUnit || PERFORMANCE_DEFAULT_UNIT;
            return { unitValue, config: getPerformanceConfig(unitValue) };
        };

        const RESPONSIBILITY_TABLE_COLUMNS = {
            number: {
                label: "Responsibility No",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => sanitizeFilterValue(preferNonEmptyString(task?.number, task?.id)),
            },
            title: {
                label: "Title",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => sanitizeFilterValue(task?.title),
            },
            progress: {
                label: "Progress",
                type: "number",
                sortable: true,
                filterable: true,
                getValue: (task) => clampProgressValue(task?.progress),
                getFilterValue: (task) => String(clampProgressValue(task?.progress)),
            },
            assigner: {
                label: "Assigned by",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => sanitizeFilterValue(getResponsibilityAssignerDisplay(task)),
            },
            assignee: {
                label: "Assigned to",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => sanitizeFilterValue(getResponsibilityAssigneeDisplay(task)),
            },
            delegatedTo: {
                label: "Delegated to",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => {
                    const { unitValue, config } = getTaskPerformanceContext(task);
                    return sanitizeFilterValue(
                        formatResponsibilityDelegations(task?.delegations, unitValue, config),
                    );
                },
            },
            performanceUnit: {
                label: "Unit of Measure",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => {
                    const { config } = getTaskPerformanceContext(task);
                    return sanitizeFilterValue(config.label);
                },
            },
            performanceResponsible: {
                label: "Responsible",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => {
                    const { unitValue, config } = getTaskPerformanceContext(task);
                    return sanitizeFilterValue(
                        formatPerformanceValueDisplay(task?.performanceResponsible, unitValue, config),
                    );
                },
            },
            performanceActual: {
                label: "Actual",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => {
                    const { unitValue, config } = getTaskPerformanceContext(task);
                    return sanitizeFilterValue(
                        formatPerformanceValueDisplay(task?.performanceActual, unitValue, config),
                    );
                },
            },
            performanceMetric: {
                label: "Performance Metric",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => {
                    const { unitValue, config } = getTaskPerformanceContext(task);
                    return sanitizeFilterValue(
                        formatPerformanceMetricDisplay(task?.performanceMetric, unitValue, config),
                    );
                },
            },
            detail: {
                label: "Detail",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => sanitizeFilterValue(task?.detail),
            },
            scheduledFor: {
                label: "Scheduled for",
                type: "date",
                sortable: true,
                filterable: true,
                getValue: (task) => {
                    const dateKey = getNormalizedDateString(task?.scheduledFor);
                    if (!dateKey) {
                        return null;
                    }
                    return new Date(`${dateKey}T00:00:00Z`);
                },
                getFilterValue: (task) => {
                    const normalized = getNormalizedDateString(task?.scheduledFor);
                    const formatted = sanitizeFilterValue(formatResponsibilityDate(task?.scheduledFor));
                    return sanitizeFilterValue([normalized, formatted].filter(Boolean).join(" "));
                },
            },
            action: {
                label: "5D Action",
                type: "text",
                sortable: true,
                filterable: true,
                getValue: (task) => sanitizeFilterValue(formatResponsibilityAction(task?.action)),
            },
            createdAt: {
                label: "Created",
                type: "date",
                sortable: true,
                filterable: true,
                getValue: (task) => {
                    if (!task?.createdAt) {
                        return null;
                    }
                    const parsed = new Date(task.createdAt);
                    return Number.isNaN(parsed.getTime()) ? null : parsed;
                },
                getFilterValue: (task) => {
                    const formatted = sanitizeFilterValue(formatResponsibilityDateTime(task?.createdAt));
                    const normalized = getNormalizedDateString(task?.createdAt);
                    return sanitizeFilterValue([normalized, formatted].filter(Boolean).join(" "));
                },
            },
        };

        const RESPONSIBILITY_FILTERABLE_KEYS = Object.entries(RESPONSIBILITY_TABLE_COLUMNS)
            .filter(([, config]) => config?.filterable)
            .map(([key]) => key);

        const getColumnFilterValue = (task, key) => {
            const definition = RESPONSIBILITY_TABLE_COLUMNS[key];
            if (!definition) {
                return "";
            }
            const rawValue =
                typeof definition.getFilterValue === "function"
                    ? definition.getFilterValue(task)
                    : definition.getValue(task);
            return sanitizeFilterValue(rawValue);
        };

        const getTaskScheduledDateKey = (task) => getNormalizedDateString(task?.scheduledFor);

        const getSortValue = (task, key) => {
            const definition = RESPONSIBILITY_TABLE_COLUMNS[key];
            if (!definition) {
                return { value: null, isEmpty: true };
            }

            const rawValue = definition.getValue(task);
            if (definition.type === "number") {
                const numeric = Number(rawValue);
                if (!Number.isFinite(numeric)) {
                    return { value: 0, isEmpty: true };
                }
                return { value: numeric, isEmpty: false };
            }

            if (definition.type === "date") {
                if (!rawValue) {
                    return { value: 0, isEmpty: true };
                }
                const dateValue = rawValue instanceof Date ? rawValue : new Date(rawValue);
                const timestamp = dateValue.getTime();
                if (!Number.isFinite(timestamp)) {
                    return { value: 0, isEmpty: true };
                }
                return { value: timestamp, isEmpty: false };
            }

            const textValue = sanitizeFilterValue(rawValue).toLowerCase();
            if (!textValue) {
                return { value: "", isEmpty: true };
            }
            return { value: textValue, isEmpty: false };
        };

        const matchesPeriodFilter = (task) => {
            if (!responsibilityPeriodStart && !responsibilityPeriodEnd) {
                return true;
            }
            const scheduledKey = getTaskScheduledDateKey(task);
            if (!scheduledKey) {
                return false;
            }
            if (responsibilityPeriodStart && scheduledKey < responsibilityPeriodStart) {
                return false;
            }
            if (responsibilityPeriodEnd && scheduledKey > responsibilityPeriodEnd) {
                return false;
            }
            return true;
        };

        const matchesFilterQuery = (task) => {
            const query = responsibilityFilterQuery.trim().toLowerCase();
            if (!query) {
                return true;
            }

            if (responsibilityFilterColumn && responsibilityFilterColumn !== "all") {
                const value = getColumnFilterValue(task, responsibilityFilterColumn).toLowerCase();
                return value.includes(query);
            }

            return RESPONSIBILITY_FILTERABLE_KEYS.some((key) =>
                getColumnFilterValue(task, key).toLowerCase().includes(query),
            );
        };

        const getFilteredResponsibilities = () => {
            const tasks = Array.isArray(responsibilityTasks) ? responsibilityTasks : [];
            return tasks.filter((task) => matchesPeriodFilter(task) && matchesFilterQuery(task));
        };

        const sortResponsibilities = (tasks) => {
            if (!responsibilitySortKey) {
                return tasks.slice();
            }

            const definition = RESPONSIBILITY_TABLE_COLUMNS[responsibilitySortKey];
            if (!definition?.sortable) {
                return tasks.slice();
            }

            return tasks.slice().sort((a, b) => {
                const aValue = getSortValue(a, responsibilitySortKey);
                const bValue = getSortValue(b, responsibilitySortKey);

                if (aValue.isEmpty && bValue.isEmpty) {
                    return 0;
                }
                if (aValue.isEmpty) {
                    return responsibilitySortDirection === "ascending" ? 1 : -1;
                }
                if (bValue.isEmpty) {
                    return responsibilitySortDirection === "ascending" ? -1 : 1;
                }

                if (aValue.value < bValue.value) {
                    return responsibilitySortDirection === "ascending" ? -1 : 1;
                }
                if (aValue.value > bValue.value) {
                    return responsibilitySortDirection === "ascending" ? 1 : -1;
                }
                return 0;
            });
        };

        const RESPONSIBILITY_SORT_ICONS = {
            ascending: "▲",
            descending: "▼",
            none: "⇅",
        };

        const updateSortIndicators = () => {
            responsibilitySortButtons.forEach((button) => {
                const key = button.dataset.sortKey;
                const header = button.closest("th");
                const icon = button.querySelector(".responsibility-table__sort-icon");
                const isActive = Boolean(key) && key === responsibilitySortKey;

                if (header) {
                    header.setAttribute(
                        "aria-sort",
                        isActive && responsibilitySortKey
                            ? responsibilitySortDirection === "descending"
                                ? "descending"
                                : "ascending"
                            : "none",
                    );
                }

                if (icon) {
                    if (!isActive || !responsibilitySortKey) {
                        icon.textContent = RESPONSIBILITY_SORT_ICONS.none;
                    } else if (responsibilitySortDirection === "descending") {
                        icon.textContent = RESPONSIBILITY_SORT_ICONS.descending;
                    } else {
                        icon.textContent = RESPONSIBILITY_SORT_ICONS.ascending;
                    }
                }
            });
        };

        const updateFilterPlaceholder = () => {
            if (!responsibilityFilterValueInput) {
                return;
            }

            if (!responsibilityFilterColumn || responsibilityFilterColumn === "all") {
                responsibilityFilterValueInput.placeholder = "Search responsibilities";
                return;
            }

            const definition = RESPONSIBILITY_TABLE_COLUMNS[responsibilityFilterColumn];
            const label = definition?.label || "column";
            responsibilityFilterValueInput.placeholder = `Search ${label.toLowerCase()}`;
        };

        const populateResponsibilityFilterOptions = () => {
            if (!responsibilityFilterColumnSelect) {
                return;
            }

            responsibilityFilterColumnSelect.innerHTML = "";

            const allOption = document.createElement("option");
            allOption.value = "all";
            allOption.textContent = "All columns";
            responsibilityFilterColumnSelect.appendChild(allOption);

            Object.entries(RESPONSIBILITY_TABLE_COLUMNS)
                .filter(([, config]) => config?.filterable)
                .forEach(([key, config]) => {
                    const option = document.createElement("option");
                    option.value = key;
                    option.textContent = config.label;
                    responsibilityFilterColumnSelect.appendChild(option);
                });

            responsibilityFilterColumnSelect.value = responsibilityFilterColumn || "all";
        };

        const renderResponsibilities = () => {
            if (!responsibilityTableBody) {
                return;
            }
            const hasPeriodFilter = Boolean(responsibilityPeriodStart || responsibilityPeriodEnd);
            const hasTextFilter = Boolean(responsibilityFilterQuery.trim());
            const hasActiveFilter = hasPeriodFilter || hasTextFilter;

            if (responsibilityEmptyState) {
                const fallbackText = responsibilityEmptyDefaultText || responsibilityEmptyState.textContent || "";
                responsibilityEmptyState.textContent = hasActiveFilter
                    ? responsibilityEmptyFilteredText
                    : fallbackText;
            }

            const filteredTasks = sortResponsibilities(getFilteredResponsibilities());
            responsibilityTableBody.innerHTML = "";

            if (!Array.isArray(filteredTasks) || filteredTasks.length === 0) {
                if (responsibilityEmptyState) {
                    responsibilityEmptyState.hidden = false;
                }
                updateSortIndicators();
                return;
            }

            if (responsibilityEmptyState) {
                responsibilityEmptyState.hidden = true;
            }

            const fragment = document.createDocumentFragment();
            filteredTasks.forEach((task) => {
                const row = document.createElement("tr");

                const appendCell = (value, { title } = {}) => {
                    const cell = document.createElement("td");
                    cell.textContent = value ?? "—";
                    if (title) {
                        cell.title = title;
                    }
                    row.appendChild(cell);
                    return cell;
                };

                appendCell(task?.number ?? "—");
                appendCell(task?.title ?? "—", { title: task?.description });

                const progressCell = document.createElement("td");
                progressCell.classList.add("responsibility-table__progress");
                const progressIndicator = renderResponsibilityProgress(task);
                if (progressIndicator) {
                    progressCell.appendChild(progressIndicator);
                } else {
                    progressCell.textContent = "—";
                }
                row.appendChild(progressCell);

                const performanceUnitValue = task?.performanceUnit || PERFORMANCE_DEFAULT_UNIT;
                const performanceConfig = getPerformanceConfig(performanceUnitValue);

                const assignerDisplay = getResponsibilityAssignerDisplay(task);
                const assigneeDisplay = getResponsibilityAssigneeDisplay(task);
                appendCell(assignerDisplay || "—");
                appendCell(assigneeDisplay || "—");
                appendCell(
                    formatResponsibilityDelegations(
                        task?.delegations,
                        performanceUnitValue,
                        performanceConfig,
                    ),
                );
                appendCell(performanceConfig.label);
                appendCell(
                    formatPerformanceValueDisplay(
                        task?.performanceResponsible,
                        performanceUnitValue,
                        performanceConfig,
                    ),
                );
                appendCell(
                    formatPerformanceValueDisplay(
                        task?.performanceActual,
                        performanceUnitValue,
                        performanceConfig,
                    ),
                );
                appendCell(
                    formatPerformanceMetricDisplay(
                        task?.performanceMetric,
                        performanceUnitValue,
                        performanceConfig,
                    ),
                );

                appendCell(task?.detail ?? "—", { title: task?.detail });
                appendCell(formatResponsibilityDate(task?.scheduledFor));
                appendCell(formatResponsibilityAction(task?.action), { title: task?.actionNotes });

                const createdCell = document.createElement("td");
                createdCell.textContent = formatResponsibilityDateTime(task?.createdAt) ?? "—";
                row.appendChild(createdCell);

                const actionsCell = document.createElement("td");
                actionsCell.classList.add("responsibility-table__actions");

                const updateButton = document.createElement("button");
                updateButton.type = "button";
                updateButton.className = "button button--secondary button--small responsibility-table__update-button";
                updateButton.textContent = "Update";
                if (task?.id) {
                    updateButton.dataset.responsibilityId = String(task.id);
                } else {
                    updateButton.disabled = true;
                }

                actionsCell.appendChild(updateButton);
                row.appendChild(actionsCell);

                fragment.appendChild(row);
            });

            responsibilityTableBody.appendChild(fragment);
            updateSortIndicators();
        };

        const populateResponsibilityAssignees = () => {
            if (responsibilityAssigneeSelect) {
                const currentValue = responsibilityAssigneeSelect.value;
                responsibilityAssigneeSelect.innerHTML = "";
                responsibilityAssigneeLookup.clear();
                const placeholder = document.createElement("option");
                placeholder.value = "";
                placeholder.textContent = "Select a team member";
                responsibilityAssigneeSelect.appendChild(placeholder);

                responsibilityAssignees.forEach((assignee) => {
                    const option = document.createElement("option");
                    option.value = String(assignee.id);
                    option.textContent = assignerNameFallback(assignee) || option.value;
                    responsibilityAssigneeLookup.set(option.value, {
                        ...assignee,
                        type: assignee.type || "team_member",
                    });
                    if (currentValue && currentValue === option.value) {
                        option.selected = true;
                    }
                    responsibilityAssigneeSelect.appendChild(option);
                });
            }

            updateDelegationSelectOptions();
        };

        const fetchResponsibilityAssignees = async () => {
            if (!responsibilityAssigneeSelect && !responsibilityDelegationsList) {
                return;
            }
            try {
                const response = await fetch("/api/team/members", { headers: authHeaders });
                let data = [];
                try {
                    data = await response.json();
                } catch (_) {
                    data = [];
                }
                if (!response.ok) {
                    throw new Error(data?.msg || "Unable to load team members.");
                }

                const uniqueMembers = new Map();
                (Array.isArray(data) ? data : []).forEach((member) => {
                    if (!member) {
                        return;
                    }

                    const rawId =
                        member?.id ?? member?.memberId ?? member?.regNumber ?? member?.reg_number;
                    if (rawId === null || rawId === undefined) {
                        return;
                    }
                    const parsedId = Number.parseInt(String(rawId).trim(), 10);
                    if (!Number.isFinite(parsedId)) {
                        return;
                    }
                    const normalizedId = String(parsedId);
                    if (uniqueMembers.has(normalizedId)) {
                        return;
                    }

                    const displayName = getMemberDisplayName(member);
                    const assignee = {
                        id: normalizedId,
                        name: displayName,
                        nickname: typeof member?.nickname === "string" ? member.nickname : "",
                        regNumber:
                            typeof member?.regNumber === "string"
                                ? member.regNumber
                                : typeof member?.reg_number === "string"
                                ? member.reg_number
                                : "",
                        type: "team_member",
                    };
                    if (typeof member?.email === "string") {
                        const trimmedEmail = member.email.trim();
                        if (trimmedEmail) {
                            assignee.email = trimmedEmail;
                        }
                    }
                    uniqueMembers.set(normalizedId, assignee);
                });

                responsibilityAssignees = Array.from(uniqueMembers.values()).sort((a, b) =>
                    a.name.localeCompare(b.name, undefined, { sensitivity: "base" }),
                );
                populateResponsibilityAssignees();
            } catch (error) {
                console.error("Failed to load responsibility team members", error);
            }
        };

        const fetchResponsibilities = async () => {
            if (!responsibilityTableBody) {
                return;
            }
            setPlanMessage(responsibilityMessage, "Loading responsibilities…");
            try {
                const response = await fetch("/api/responsibilities", { headers: authHeaders });
                let data = [];
                try {
                    data = await response.json();
                } catch (_) {
                    data = [];
                }
                if (!response.ok) {
                    throw new Error(data?.msg || "Unable to load responsibilities.");
                }
                responsibilityTasks = Array.isArray(data) ? data : [];
                renderResponsibilities();
                if (responsibilityTasks.length === 0) {
                    setPlanMessage(
                        responsibilityMessage,
                        "Create responsibilities to build your weekly plan.",
                        "info",
                    );
                } else {
                    setPlanMessage(responsibilityMessage, "");
                }
            } catch (error) {
                console.error("Failed to load responsibilities", error);
                responsibilityTasks = [];
                renderResponsibilities();
                setPlanMessage(
                    responsibilityMessage,
                    error?.message || "Unable to load responsibilities.",
                    "error",
                );
            }
        };

        const gatherCustomWeekdays = () => {
            if (!responsibilityCustomWeekdays) {
                return [];
            }
            const values = [];
            responsibilityCustomWeekdays.querySelectorAll("input[type='checkbox']").forEach((input) => {
                if (input.checked) {
                    const number = Number.parseInt(input.value, 10);
                    if (!Number.isNaN(number)) {
                        values.push(number);
                    }
                }
            });
            return values;
        };

        const submitResponsibilityForm = async (event) => {
            event.preventDefault();
            if (!responsibilityForm) {
                return;
            }
            if (!responsibilityForm.checkValidity()) {
                responsibilityForm.reportValidity();
                return;
            }

            const isEditingResponsibility = responsibilityEditingTaskId !== null;
            const formData = new FormData(responsibilityForm);
            const existingDescription = responsibilityEditingTask?.description;
            const payload = {
                title: formData.get("title")?.toString().trim(),
                detail: formData.get("detail")?.toString().trim() || undefined,
                scheduledFor: formData.get("scheduledFor")?.toString(),
                recurrence: formData.get("recurrence")?.toString(),
                recipientEmail: formData.get("recipientEmail")?.toString().trim(),
            };

            if (existingDescription !== undefined) {
                payload.description = existingDescription;
            }

            if (responsibilityCcInput) {
                const ccRaw = formData.get("ccEmail")?.toString().trim() ?? "";
                payload.ccEmail = ccRaw || null;
            }

            const performanceUnitValue = responsibilityPerformanceUnitSelect?.value?.toString().trim();
            if (!performanceUnitValue) {
                showResponsibilityFormError("Select a unit of measure.");
                responsibilityPerformanceUnitSelect?.focus();
                return;
            }
            const performanceConfig = getPerformanceConfig(performanceUnitValue);
            payload.performanceUnit = performanceUnitValue;

            const responsibleRaw = responsibilityPerformanceResponsibleInput?.value?.toString().trim() ?? "";
            const responsibleState = parsePerformanceInputValue(
                responsibleRaw,
                performanceUnitValue,
                performanceConfig,
            );
            if (!responsibleRaw) {
                showResponsibilityFormError("Enter the responsible target value.");
                responsibilityPerformanceResponsibleInput?.focus();
                return;
            }
            if (!responsibleState.isValid) {
                showResponsibilityFormError("Enter a valid responsible value for the selected unit.");
                responsibilityPerformanceResponsibleInput?.focus();
                return;
            }
            payload.performanceResponsible = responsibleRaw;

            const actualRaw = responsibilityPerformanceActualInput?.value?.toString().trim() ?? "";
            const actualState = parsePerformanceInputValue(actualRaw, performanceUnitValue, performanceConfig);
            if (actualRaw && !actualState.isValid) {
                showResponsibilityFormError("Enter a valid actual value for the selected unit.");
                responsibilityPerformanceActualInput?.focus();
                return;
            }
            if (!actualState.isBlank) {
                payload.performanceActual = actualRaw;
            } else {
                payload.performanceActual = null;
            }

            const assigneeRaw = formData.get("assigneeId")?.toString().trim() ?? "";
            if (!assigneeRaw) {
                showResponsibilityFormError("Select a team member to assign this responsibility.");
                responsibilityAssigneeSelect?.focus();
                return;
            }
            const parsedAssignee = Number.parseInt(assigneeRaw, 10);
            if (Number.isNaN(parsedAssignee)) {
                showResponsibilityFormError("Select a valid team member for the assignment.");
                responsibilityAssigneeSelect?.focus();
                return;
            }
            payload.assigneeId = parsedAssignee;
            const assigneeRecord = responsibilityAssigneeLookup.get(String(parsedAssignee));
            if (assigneeRecord?.type) {
                payload.assigneeType = assigneeRecord.type;
            }

            const actionValue = formData.get("action")?.toString();
            if (actionValue) {
                payload.action = actionValue;
            }
            const isDelegatedAction = actionValue === "delegated";

            if (responsibilityProgressInput) {
                const progressRaw = formData.get("progress");
                const progressString = progressRaw?.toString().trim() ?? "";
                let progressValue = 0;
                if (progressString) {
                    const parsedProgress = Number.parseFloat(progressString);
                    if (Number.isNaN(parsedProgress)) {
                        showResponsibilityFormError("Enter a progress value between 0 and 100.");
                        responsibilityProgressInput.focus();
                        return;
                    }
                    if (parsedProgress < 0 || parsedProgress > 100) {
                        showResponsibilityFormError("Progress must be between 0 and 100.");
                        responsibilityProgressInput.focus();
                        return;
                    }
                    progressValue = Math.round(parsedProgress);
                }

                if (actionValue === "done" || actionValue === "deleted") {
                    progressValue = 100;
                }

                payload.progress = progressValue;
            }

            const delegationRows = Array.from(
                responsibilityDelegationsList?.querySelectorAll(".responsibility-delegations__row") ?? [],
            );
            const delegationsPayload = [];
            for (const row of delegationRows) {
                const managerSelect = row.querySelector(".responsibility-delegations__select");
                const valueInput = row.querySelector(".responsibility-delegations__value");
                const delegateValueRaw = managerSelect?.value?.toString().trim() ?? "";

                if (!delegateValueRaw) {
                    if (isDelegatedAction) {
                        showResponsibilityFormError(
                            "Select a team member for each delegated allocation.",
                        );
                        managerSelect?.focus();
                        return;
                    }
                    continue;
                }

                const parsedDelegated = Number.parseInt(delegateValueRaw, 10);
                if (Number.isNaN(parsedDelegated)) {
                    showResponsibilityFormError("Select a valid delegated team member.");
                    managerSelect?.focus();
                    return;
                }

                const allocationRaw = valueInput?.value?.toString().trim() ?? "";
                const delegateRecord = responsibilityAssigneeLookup.get(String(parsedDelegated));
                const delegateType = delegateRecord?.type || "team_member";
                delegationsPayload.push({
                    delegateId: parsedDelegated,
                    delegateType,
                    allocatedValue: allocationRaw || null,
                });
            }

            if (isDelegatedAction && delegationsPayload.length === 0) {
                showResponsibilityFormError("Add at least one delegated team member when the action is Delegated.");
                ensureDelegationRow();
                responsibilityDelegationsList
                    ?.querySelector(".responsibility-delegations__select")
                    ?.focus();
                return;
            }

            if (delegationsPayload.length > 0) {
                payload.delegations = delegationsPayload;
            }

            const actionNotesValue = formData.get("actionNotes")?.toString().trim();
            if (actionValue && ACTIONS_REQUIRING_NOTES.has(actionValue) && !actionNotesValue) {
                showResponsibilityFormError("Enter discussion points or reasons for the selected action.");
                openResponsibilityActionNotesModal(actionValue);
                setResponsibilityActionNotesError("Notes are required for this action.");
                return;
            }

            if (actionNotesValue) {
                payload.actionNotes = actionNotesValue;
            } else if (isEditingResponsibility) {
                payload.actionNotes = "";
            }

            payload.customWeekdays =
                payload.recurrence === "custom" ? gatherCustomWeekdays() : [];

            if (isEditingResponsibility && responsibilityEditingTask?.status) {
                payload.status = responsibilityEditingTask.status;
            }

            const requestUrl = isEditingResponsibility
                ? `/api/responsibilities/${responsibilityEditingTaskId}`
                : "/api/responsibilities";
            const requestMethod = isEditingResponsibility ? "PUT" : "POST";

            clearResponsibilityFormError();
            if (responsibilitySubmitButton) {
                responsibilitySubmitButton.disabled = true;
                responsibilitySubmitButton.textContent = isEditingResponsibility
                    ? "Updating…"
                    : "Saving…";
            }

            try {
                const response = await fetch(requestUrl, {
                    method: requestMethod,
                    headers: { ...authHeaders, "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                let data = null;
                try {
                    data = await response.json();
                } catch (_) {
                    data = null;
                }
                if (!response.ok) {
                    const messageFromResponse =
                        (typeof data?.msg === "string" && data.msg.trim()) ||
                        extractFirstErrorMessage(data?.errors);
                    throw new Error(
                        messageFromResponse ||
                            (isEditingResponsibility
                                ? "Unable to update responsibility."
                                : "Unable to save responsibility."),
                    );
                }
                closeResponsibilityModal();
                const successMessage = isEditingResponsibility
                    ? "Responsibility updated."
                    : "Responsibility saved and notification sent.";
                setPlanMessage(responsibilityMessage, successMessage, "success");
                await fetchResponsibilities();
            } catch (error) {
                console.error("Failed to save responsibility", error);
                const fallbackError = isEditingResponsibility
                    ? "Unable to update responsibility."
                    : "Unable to save responsibility.";
                showResponsibilityFormError(error?.message || fallbackError);
            } finally {
                if (responsibilitySubmitButton) {
                    responsibilitySubmitButton.disabled = false;
                    responsibilitySubmitButton.textContent = isEditingResponsibility
                        ? "Update responsibility"
                        : "Save responsibility";
                }
            }
        };

        responsibilityActionSelect?.addEventListener("change", handleResponsibilityActionChange);

        responsibilityAddDelegationButton?.addEventListener("click", () => {
            const row = createDelegationRow();
            row?.querySelector(".responsibility-delegations__select")?.focus();
        });

        responsibilityActionNotesSave?.addEventListener("click", () => {
            const value = responsibilityActionNotesTextarea?.value?.trim();
            if (!value) {
                setResponsibilityActionNotesError("Notes are required for this action.");
                responsibilityActionNotesTextarea?.focus();
                return;
            }
            if (responsibilityActionNotesInput) {
                responsibilityActionNotesInput.value = value;
            }
            clearResponsibilityFormError();
            closeResponsibilityActionNotesModal();
        });

        const dismissNotesModal = () => {
            setResponsibilityActionNotesError();
            closeResponsibilityActionNotesModal(true);
        };

        responsibilityActionNotesCancel?.addEventListener("click", dismissNotesModal);
        responsibilityActionNotesClose?.addEventListener("click", dismissNotesModal);
        responsibilityActionNotesOverlay?.addEventListener("click", dismissNotesModal);

        if (responsibilityForm) {
            responsibilityForm.addEventListener("submit", submitResponsibilityForm);
        }

        responsibilityCreateButton?.addEventListener("click", () => {
            openResponsibilityModal();
        });

        responsibilityTableBody?.addEventListener("click", (event) => {
            const { target } = event;
            if (!(target instanceof Element)) {
                return;
            }
            const updateButton = target.closest(".responsibility-table__update-button");
            if (!updateButton) {
                return;
            }
            const responsibilityId = Number.parseInt(
                updateButton.dataset.responsibilityId || "",
                10,
            );
            if (Number.isNaN(responsibilityId)) {
                return;
            }
            const taskToEdit = responsibilityTasks.find((task) => {
                const taskId = Number.parseInt(task?.id, 10);
                return !Number.isNaN(taskId) && taskId === responsibilityId;
            });
            if (!taskToEdit) {
                setPlanMessage(
                    responsibilityMessage,
                    "Unable to load the selected responsibility for editing.",
                    "error",
                );
                return;
            }
            openResponsibilityModal(taskToEdit);
        });

        responsibilityModalClose?.addEventListener("click", closeResponsibilityModal);
        responsibilityCancelButton?.addEventListener("click", closeResponsibilityModal);
        responsibilityModalOverlay?.addEventListener("click", closeResponsibilityModal);

        responsibilityRecurrenceSelect?.addEventListener("change", () => {
            toggleCustomWeekdayFieldset();
        });

        responsibilityDateInput?.addEventListener("change", () => {
            updateRecurrenceOptionLabels();
        });

        populateResponsibilityFilterOptions();
        updateFilterPlaceholder();
        updateSortIndicators();

        const applyPeriodFilters = () => {
            responsibilityPeriodStart = getNormalizedDateString(responsibilityPeriodStartInput?.value);
            responsibilityPeriodEnd = getNormalizedDateString(responsibilityPeriodEndInput?.value);
            renderResponsibilities();
        };

        responsibilityPeriodStartInput?.addEventListener("change", applyPeriodFilters);
        responsibilityPeriodEndInput?.addEventListener("change", applyPeriodFilters);

        responsibilityPeriodClearButton?.addEventListener("click", () => {
            if (responsibilityPeriodStartInput) {
                responsibilityPeriodStartInput.value = "";
            }
            if (responsibilityPeriodEndInput) {
                responsibilityPeriodEndInput.value = "";
            }
            responsibilityPeriodStart = "";
            responsibilityPeriodEnd = "";
            renderResponsibilities();
        });

        responsibilityFilterColumnSelect?.addEventListener("change", (event) => {
            const selected = event.target?.value || "all";
            responsibilityFilterColumn = selected;
            updateFilterPlaceholder();
            renderResponsibilities();
        });

        responsibilityFilterValueInput?.addEventListener("input", (event) => {
            responsibilityFilterQuery = event.target?.value || "";
            renderResponsibilities();
        });

        responsibilityFilterClearButton?.addEventListener("click", () => {
            responsibilityFilterColumn = "all";
            responsibilityFilterQuery = "";
            if (responsibilityFilterColumnSelect) {
                responsibilityFilterColumnSelect.value = "all";
            }
            if (responsibilityFilterValueInput) {
                responsibilityFilterValueInput.value = "";
            }
            updateFilterPlaceholder();
            renderResponsibilities();
        });

        responsibilitySortButtons.forEach((button) => {
            button.addEventListener("click", () => {
                const key = button.dataset.sortKey;
                if (!key || !RESPONSIBILITY_TABLE_COLUMNS[key]?.sortable) {
                    return;
                }

                if (responsibilitySortKey === key) {
                    if (responsibilitySortDirection === "ascending") {
                        responsibilitySortDirection = "descending";
                    } else if (responsibilitySortDirection === "descending") {
                        responsibilitySortKey = null;
                        responsibilitySortDirection = "ascending";
                    } else {
                        responsibilitySortDirection = "ascending";
                    }
                } else {
                    responsibilitySortKey = key;
                    responsibilitySortDirection = "ascending";
                }

                renderResponsibilities();
            });
        });

        if (responsibilityWeeklyForm) {
            responsibilityWeeklyForm.addEventListener("submit", async (event) => {
                event.preventDefault();
                const emailValue = responsibilityWeeklyEmailInput?.value?.trim();
                if (!emailValue) {
                    setPlanMessage(responsibilityWeeklyMessage, "Enter an email to send the plan.", "error");
                    return;
                }
                setPlanMessage(responsibilityWeeklyMessage, "Sending weekly plan…");
                if (responsibilityWeeklySendButton) {
                    responsibilityWeeklySendButton.disabled = true;
                }
                const payload = {
                    recipientEmail: emailValue,
                };
                const startValue = responsibilityWeeklyStartInput?.value?.trim();
                if (startValue) {
                    payload.startDate = startValue;
                }
                try {
                    const response = await fetch("/api/responsibilities/send-weekly", {
                        method: "POST",
                        headers: { ...authHeaders, "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    });
                    let data = null;
                    try {
                        data = await response.json();
                    } catch (_) {
                        data = null;
                    }
                    if (!response.ok) {
                        throw new Error(data?.msg || "Unable to send weekly plan.");
                    }
                    const rangeText = `${formatResponsibilityDate(data?.startDate)} – ${formatResponsibilityDate(
                        data?.endDate,
                    )}`;
                    setPlanMessage(
                        responsibilityWeeklyMessage,
                        `Weekly plan sent for ${rangeText}.`,
                        "success",
                    );
                } catch (error) {
                    console.error("Failed to send weekly plan", error);
                    setPlanMessage(
                        responsibilityWeeklyMessage,
                        error?.message || "Unable to send weekly plan.",
                        "error",
                    );
                } finally {
                    if (responsibilityWeeklySendButton) {
                        responsibilityWeeklySendButton.disabled = false;
                    }
                }
            });
        }

        const initializeResponsibilityWeeklyStart = () => {
            if (!responsibilityWeeklyStartInput) {
                return;
            }
            const today = new Date();
            const day = today.getDay();
            const offset = day === 0 ? -6 : 1 - day;
            const monday = new Date(today);
            monday.setDate(today.getDate() + offset);
            responsibilityWeeklyStartInput.value = toIsoDateString(monday);
        };

        initializeResponsibilityWeeklyStart();
        toggleCustomWeekdayFieldset();
        updateRecurrenceOptionLabels();
        fetchResponsibilityAssignees();
        fetchResponsibilities();

        // =====================
        // Helpers: normalize date & status for API
        // =====================
        function toYyyyMmDd(input) {
            if (!input) return null;
            const d = new Date(input);
            if (!isNaN(d.getTime())) return d.toISOString().slice(0, 10);
            const mdy = /^(\d{1,2})[\/-](\d{1,2})[\/-](\d{4})$/.exec(String(input).trim());
            if (mdy) {
                const [, m, dd, y] = mdy;
                return `${y}-${String(m).padStart(2, "0")}-${String(dd).padStart(2, "0")}`;
            }
            const ymd = /^(\d{4})[\/-](\d{1,2})[\/-](\d{1,2})$/.exec(String(input).trim());
            if (ymd) {
                const [, y, m, dd] = ymd;
                return `${y}-${String(m).padStart(2, "0")}-${String(dd).padStart(2, "0")}`;
            }
            return null;
        }

        function normalizeStatus(value) {
            if (!value) return "Active";
            const map = {
                "active": "Active",
                "inactive": "Inactive",
                "on leave": "On Leave",
                "on_leave": "On Leave",
                "on-leave": "On Leave",
            };
            return map[String(value).trim().toLowerCase()] ?? "Active";
        }

        const tableBody = document.getElementById("team-table-body");
        const emptyState = document.getElementById("team-empty-state");
        const formSection = document.getElementById("team-form-section");
        const teamForm = document.getElementById("team-form");
        const teamFormError = document.getElementById("team-form-error");
        const teamFormSuccess = document.getElementById("team-form-success");
        const teamFormSubmitButton = teamForm?.querySelector(".team-form__submit");
        const teamFormEditingBanner = document.getElementById("team-form-editing");
        const teamFormEditingName = document.getElementById("team-form-editing-name");
        const teamFormCancelEditBanner = document.getElementById("team-form-cancel-edit");
        const teamFormCancelEditFooter = document.getElementById(
            "team-form-cancel-edit-footer"
        );
        const updateColumnHeader = document.getElementById(
            "team-update-column-header"
        );
        const regNumberInput = document.getElementById("team-reg-number");
        const joinDateInput = document.getElementById("team-join-date");
        const payCategorySelect = document.getElementById("team-pay-category");
        const statusSelect = document.getElementById("team-status");
        const nameInput = document.getElementById("team-name");
        const nicknameInput = document.getElementById("team-nickname");
        const epfInput = document.getElementById("team-epf");
        const positionInput = document.getElementById("team-position");
        const imageInput = document.getElementById("team-image");
        const personalDetailInput = document.getElementById("team-personal-detail");
        const bankDetailButton = document.getElementById("team-bank-detail-button");
        const bankDetailSummary = document.getElementById("team-bank-detail-summary");
        const bankAccountNameHidden = document.getElementById("team-bank-account-name");
        const bankNameHidden = document.getElementById("team-bank-name");
        const branchNameHidden = document.getElementById("team-branch-name");
        const bankAccountNumberHidden = document.getElementById("team-bank-account-number");
        const assignmentsInput = document.getElementById("team-assignments");
        const trainingInput = document.getElementById("team-training");
        const employmentLogInput = document.getElementById("team-employment-log");
        const filesInput = document.getElementById("team-files");
        const assetsInput = document.getElementById("team-assets");
        const bankDetailModal = document.getElementById("bank-detail-modal");
        const bankDetailModalClose = document.getElementById("bank-detail-modal-close");
        const bankDetailModalCancel = document.getElementById("bank-detail-modal-cancel");
        const bankDetailEditToggle = document.getElementById("bank-detail-edit-toggle");
        const bankDetailForm = document.getElementById("bank-detail-form");
        const bankDetailError = document.getElementById("bank-detail-error");
        const bankDetailSuccess = document.getElementById("bank-detail-success");
        const bankDetailHint = document.getElementById("bank-detail-modal-hint");
        const bankDetailSaveButton = document.getElementById("bank-detail-save-button");
        const bankDetailAccountNameInput = document.getElementById("bank-detail-account-name");
        const bankDetailBankNameInput = document.getElementById("bank-detail-bank-name");
        const bankDetailBranchNameInput = document.getElementById("bank-detail-branch-name");
        const bankDetailAccountNumberInput = document.getElementById("bank-detail-account-number");
        const bankDetailFieldInputs = {
            bankAccountName: bankDetailAccountNameInput,
            bankName: bankDetailBankNameInput,
            branchName: bankDetailBranchNameInput,
            bankAccountNumber: bankDetailAccountNumberInput,
        };
        const salaryTableBody = document.getElementById("salary-table-body");
        const salaryEmptyState = document.getElementById("salary-empty-state");
        const salarySummaryContainer = document.getElementById("salary-summary");
        const salarySummaryTotal = document.getElementById("salary-summary-total");
        const salarySummaryFactory = document.getElementById(
            "salary-summary-factory",
        );
        const salarySummaryCasual = document.getElementById("salary-summary-casual");
        const salaryMonthSelector = document.getElementById("salary-month-selector");
        const loadingPayMonthSelect = document.getElementById("loading-pay-month");
        const loadingPayYearSelect = document.getElementById("loading-pay-year");
        const loadingPayTableBody = document.getElementById("loading-pay-table-body");
        const loadingPayEmptyState = document.getElementById("loading-pay-empty");
        const loadingPayMessage = document.getElementById("loading-pay-message");
        const loadingPayRateValue = document.getElementById("loading-pay-rate");
        const transportPayTableBody = document.getElementById("transport-pay-table-body");
        const transportPayEmptyState = document.getElementById("transport-pay-empty");
        const transportPayMessage = document.getElementById("transport-pay-message");
        const attendanceModal = document.getElementById("attendance-modal");
        const attendanceModalClose = document.getElementById("attendance-modal-close");
        const attendanceModalCancel = document.getElementById("attendance-modal-cancel");
        const attendanceForm = document.getElementById("attendance-form");
        const attendanceTableBody = document.getElementById("attendance-table-body");
        const attendanceFormMemberName = document.getElementById("attendance-form-member-name");
        const attendanceFormRegno = document.getElementById("attendance-form-regno");
        const attendanceSummaryMonth = document.getElementById("attendance-summary-month");
        const attendanceTotalPayHours = document.getElementById("attendance-total-pay-hours");
        const attendanceTotalRegularHours = document.getElementById(
            "attendance-total-regular-hours",
        );
        const attendanceTotalOvertimeHours = document.getElementById("attendance-total-ot-hours");
        const attendanceLeaveElements = {
            workDays: document.getElementById("attendance-leave-workdays"),
            noPayDays: document.getElementById("attendance-leave-nopay"),
            annualBroughtForward: document.getElementById("attendance-leave-annual-bf"),
            annualThisMonth: document.getElementById("attendance-leave-annual-this"),
            annualBalance: document.getElementById("attendance-leave-annual-balance"),
            medicalBroughtForward: document.getElementById("attendance-leave-medical-bf"),
            medicalThisMonth: document.getElementById("attendance-leave-medical-this"),
            medicalBalance: document.getElementById("attendance-leave-medical-balance"),
        };
        const salaryModal = document.getElementById("salary-modal");
        const salaryModalTitle = document.getElementById("salary-modal-title");
        const salaryModalClose = document.getElementById("salary-modal-close");
        const salaryModalCancel = document.getElementById("salary-modal-cancel");
        const salaryForm = document.getElementById("salary-form");
        const salaryFormMonth = document.getElementById("salary-form-month");
        const salaryFormMemberName = document.getElementById("salary-form-member-name");
        const salaryFormRegno = document.getElementById("salary-form-regno");
        const workCalendarYearSelect = document.getElementById("work-calendar-year");
        const workCalendarMonthSelect = document.getElementById("work-calendar-month");
        const workCalendarGrid = document.getElementById("work-calendar-grid");
        const workCalendarLoading = document.getElementById("work-calendar-loading");
        const workCalendarMessage = document.getElementById("work-calendar-message");
        const workdayModal = document.getElementById("workday-modal");
        const workdayModalClose = document.getElementById("workday-modal-close");
        const workdayModalCancel = document.getElementById("workday-modal-cancel");
        const workdayForm = document.getElementById("workday-form");
        const workdayDateDisplay = document.getElementById("workday-form-date");
        const workdayStatusWork = document.getElementById("workday-status-work");
        const workdayStatusOff = document.getElementById("workday-status-off");
        const workdayHolidayInput = document.getElementById("workday-holiday");
        const workdayFormError = document.getElementById("workday-form-error");
        const workdayModalSave = document.getElementById("workday-modal-save");

        const canManageMembers = ["admin", "production_manager"].includes(user?.role);
        const canManageSalary = [
            "admin",
            "production_manager",
            "finance_manager",
        ].includes(user?.role);

        if (!canManageMembers && formSection) {
            formSection.hidden = true;
        }

        if (!canManageMembers && updateColumnHeader) {
            updateColumnHeader.remove();
        }

        const salaryFieldDefinitions = [
            { name: "basicSalary", label: "Basic Salary" },
            { name: "daySalary", label: "Day Salary" },
            { name: "generalAllowance", label: "General Allowance" },
            { name: "transportAllowance", label: "Transport Allowance" },
            { name: "attendanceAllowance", label: "Attendance Allowance" },
            { name: "specialAllowance", label: "Special Allowance" },
            { name: "performanceBonus", label: "Performance Bonus" },
            { name: "production", label: "Total Day Salary" },
            { name: "targetAllowance", label: "Target Allowance" },
            { name: "overtime", label: "Overtime" },
            { name: "grossSalary", label: "Gross Salary" },
            { name: "providentFund", label: "Provident Fund" },
            { name: "loanDeduction", label: "Loan Deduction" },
            { name: "mealDeduction", label: "Meal Deduction" },
            { name: "otherDeduction", label: "Other Deduction" },
            { name: "salaryAdvance", label: "Salary Advance" },
            { name: "noPay", label: "No Pay" },
            { name: "totalDeduction", label: "Total Deduction" },
            { name: "netPay", label: "Net Pay" },
        ];

        const deductionFieldNames = [
            "providentFund",
            "loanDeduction",
            "mealDeduction",
            "otherDeduction",
            "salaryAdvance",
            "noPay",
        ];

        const refreshSalaryFormTotals = () => {
            if (!salaryForm) {
                return;
            }

            const totalDeductionInput = salaryForm.elements?.totalDeduction;
            const netPayInput = salaryForm.elements?.netPay;
            const grossSalaryInput = salaryForm.elements?.grossSalary;

            let total = 0;

            deductionFieldNames.forEach((name) => {
                const field = salaryForm.elements?.[name];
                if (!field) {
                    return;
                }

                const parsed = parseNumericAmount(field.value);
                if (Number.isFinite(parsed)) {
                    total += parsed;
                }
            });

            if (totalDeductionInput) {
                totalDeductionInput.readOnly = true;
                totalDeductionInput.setAttribute("aria-readonly", "true");
                totalDeductionInput.value = formatNumberForInput(total);
            }

            if (!netPayInput) {
                return;
            }

            netPayInput.readOnly = true;
            netPayInput.setAttribute("aria-readonly", "true");

            const grossValue = parseNumericAmount(grossSalaryInput?.value);
            if (Number.isFinite(grossValue)) {
                const netValue = grossValue - total;
                netPayInput.value = formatNumberForInput(netValue);
            } else {
                netPayInput.value = "";
            }
        };

        const salaryDataStore = Object.create(null);
        const casualOtRateStore = Object.create(null);
        const attendanceDataStore = Object.create(null);
        const computedAttendanceAllowanceStore = Object.create(null);
        const computedTargetAllowanceStore = Object.create(null);
        const attendanceLeaveSummaryStore = Object.create(null);
        const workCalendarStore = new Map();
        const memberKeyById = new Map();
        let activeMembers = [];
        let editingMemberId = null;
        let salaryModalContext = null;
        let attendanceModalContext = null;
        let bankDetailModalState = null;
        let workdayModalContext = null;
        let workCalendarState = { year: null, month: null, loading: false };
        let loadingPayState = { month: null, year: null, loading: false };
        let transportPayState = { month: null, year: null, loading: false };

        const WORK_CALENDAR_WEEKDAY_INDEX = {
            Mon: 0,
            Tue: 1,
            Wed: 2,
            Thu: 3,
            Fri: 4,
            Sat: 5,
            Sun: 6,
        };

        const numberFormatter = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        });
        const TIME_24_HOUR_PATTERN = /^(\d{1,2}):([0-5]\d)$/;
        const TIME_12_HOUR_PATTERN = /^(\d{1,2}):([0-5]\d)\s*(AM|PM)$/i;
        const TIME_COMPACT_PATTERN = /^(\d{1,2})([0-5]\d)$/;
        const attendanceDateFormatter = new Intl.DateTimeFormat(undefined, {
            year: "numeric",
            month: "short",
            day: "2-digit",
        });
        const attendanceMonthFormatter = new Intl.DateTimeFormat(undefined, {
            year: "numeric",
            month: "long",
        });
        const COLOMBO_TIME_ZONE = "Asia/Colombo";
        const workCalendarDateFormatter = new Intl.DateTimeFormat(undefined, {
            timeZone: COLOMBO_TIME_ZONE,
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
        });
        const workCalendarTodayFormatter = new Intl.DateTimeFormat("en-CA", {
            timeZone: COLOMBO_TIME_ZONE,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
        });
        const workCalendarWeekdayFormatter = new Intl.DateTimeFormat("en-GB", {
            timeZone: COLOMBO_TIME_ZONE,
            weekday: "short",
        });
        const WORK_CALENDAR_MONTH_NAMES = Array.from({ length: 12 }, (_, index) =>
            new Date(Date.UTC(2000, index, 1)).toLocaleString(undefined, { month: "long" })
        );

        const getInitialSalaryMonth = () => {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, "0");
            return `${year}-${month}`;
        };

        const getCurrentMonthYear = () => {
            const now = new Date();
            return { month: now.getMonth() + 1, year: now.getFullYear() };
        };

        const normalizeMonthValue = (value) => {
            if (typeof value !== "string") {
                return "";
            }
            const trimmed = value.trim();
            const match = /^(\d{4})-(\d{2})$/.exec(trimmed);
            if (!match) {
                return "";
            }
            const month = Number(match[2]);
            if (Number.isNaN(month) || month < 1 || month > 12) {
                return "";
            }
            return `${match[1]}-${String(month).padStart(2, "0")}`;
        };

        const formatIsoDate = (year, month, day) =>
            `${String(year).padStart(4, "0")}-${String(month).padStart(2, "0")}-${String(day).padStart(2, "0")}`;

        const parseIsoDate = (value) => {
            if (typeof value !== "string") {
                return null;
            }
            const match = /^(\d{4})-(\d{2})-(\d{2})$/.exec(value.trim());
            if (!match) {
                return null;
            }
            const year = Number(match[1]);
            const month = Number(match[2]);
            const day = Number(match[3]);
            if (
                !Number.isFinite(year) ||
                !Number.isFinite(month) ||
                !Number.isFinite(day) ||
                month < 1 ||
                month > 12 ||
                day < 1 ||
                day > 31
            ) {
                return null;
            }
            return { year, month, day };
        };

        const getMonthKey = (year, month) => `${year}-${String(month).padStart(2, "0")}`;

        const getTodayIso = () => {
            const parts = workCalendarTodayFormatter.formatToParts(new Date());
            const lookup = Object.create(null);
            for (const part of parts) {
                lookup[part.type] = part.value;
            }
            if (!lookup.year || !lookup.month || !lookup.day) {
                return "";
            }
            return `${lookup.year}-${lookup.month}-${lookup.day}`;
        };

        function setLoadingPayMessage(message, variant = "info") {
            if (!loadingPayMessage) {
                return;
            }

            loadingPayMessage.textContent = message || "";
            loadingPayMessage.hidden = !message;
            if (variant === "error") {
                loadingPayMessage.classList.add("loading-pay__message--error");
            } else {
                loadingPayMessage.classList.remove("loading-pay__message--error");
            }
        }

        function setTransportPayMessage(message, variant = "info") {
            if (!transportPayMessage) {
                return;
            }

            transportPayMessage.textContent = message || "";
            transportPayMessage.hidden = !message;
            if (variant === "error") {
                transportPayMessage.classList.add("loading-pay__message--error");
            } else {
                transportPayMessage.classList.remove("loading-pay__message--error");
            }
        }

        function renderLoadingPayTable(records) {
            if (!loadingPayTableBody) {
                return;
            }

            loadingPayTableBody.innerHTML = "";
            const safeRecords = Array.isArray(records) ? records : [];

            if (!safeRecords.length) {
                if (loadingPayEmptyState) {
                    loadingPayEmptyState.hidden = false;
                }
                return;
            }

            if (loadingPayEmptyState) {
                loadingPayEmptyState.hidden = true;
            }

            safeRecords.forEach((record) => {
                const row = document.createElement("tr");

                const regCell = document.createElement("td");
                regCell.textContent = record?.regNumber || "—";
                row.appendChild(regCell);

                const nameCell = document.createElement("td");
                nameCell.textContent = record?.name || "—";
                row.appendChild(nameCell);

                const quantityCell = document.createElement("td");
                quantityCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const quantityValue = Number(record?.loadingQuantity ?? record?.quantity ?? 0);
                quantityCell.textContent = numberFormatter.format(quantityValue);
                row.appendChild(quantityCell);

                const payCell = document.createElement("td");
                payCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const payValue = Number(record?.loadingPay ?? record?.pay ?? 0);
                payCell.textContent = numberFormatter.format(payValue);
                row.appendChild(payCell);

                loadingPayTableBody.appendChild(row);
            });
        }

        function renderTransportPayTable(records) {
            if (!transportPayTableBody) {
                return;
            }

            transportPayTableBody.innerHTML = "";
            const safeRecords = Array.isArray(records) ? records : [];

            if (!safeRecords.length) {
                if (transportPayEmptyState) {
                    transportPayEmptyState.hidden = false;
                }
                return;
            }

            if (transportPayEmptyState) {
                transportPayEmptyState.hidden = true;
            }

            safeRecords.forEach((record) => {
                const row = document.createElement("tr");

                const regCell = document.createElement("td");
                regCell.textContent = record?.regNumber || "—";
                row.appendChild(regCell);

                const nameCell = document.createElement("td");
                nameCell.textContent = record?.name || "—";
                row.appendChild(nameCell);

                const woodCell = document.createElement("td");
                woodCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const woodValue = Number(record?.woodShavingQuantity ?? 0);
                woodCell.textContent = numberFormatter.format(woodValue);
                row.appendChild(woodCell);

                const briquetteCell = document.createElement("td");
                briquetteCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const briquetteValue = Number(record?.briquetteQuantity ?? 0);
                briquetteCell.textContent = numberFormatter.format(briquetteValue);
                row.appendChild(briquetteCell);

                const driverCell = document.createElement("td");
                driverCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const driverValue = Number(record?.driverPayment ?? 0);
                driverCell.textContent = numberFormatter.format(driverValue);
                row.appendChild(driverCell);

                const helperCell = document.createElement("td");
                helperCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const helperValue = Number(record?.helperPayment ?? 0);
                helperCell.textContent = numberFormatter.format(helperValue);
                row.appendChild(helperCell);

                const extraCell = document.createElement("td");
                extraCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const extraValue = Number(record?.extraPayment ?? 0);
                extraCell.textContent = numberFormatter.format(extraValue);
                row.appendChild(extraCell);

                const totalCell = document.createElement("td");
                totalCell.classList.add("loading-pay__cell", "loading-pay__cell--number");
                const totalValue = Number(record?.totalPayment ?? 0);
                totalCell.textContent = numberFormatter.format(totalValue);
                row.appendChild(totalCell);

                transportPayTableBody.appendChild(row);
            });
        }

        function populateLoadingPayFilters() {
            if (!loadingPayMonthSelect || !loadingPayYearSelect) {
                return;
            }

            loadingPayMonthSelect.innerHTML = "";
            WORK_CALENDAR_MONTH_NAMES.forEach((name, index) => {
                const option = document.createElement("option");
                option.value = String(index + 1);
                option.textContent = name;
                loadingPayMonthSelect.appendChild(option);
            });

            const { year: currentYear, month: currentMonth } = getCurrentMonthYear();
            const years = [];
            for (let offset = -4; offset <= 1; offset += 1) {
                years.push(currentYear + offset);
            }

            loadingPayYearSelect.innerHTML = "";
            years.forEach((year) => {
                const option = document.createElement("option");
                option.value = String(year);
                option.textContent = String(year);
                loadingPayYearSelect.appendChild(option);
            });

            if (!years.includes(currentYear)) {
                const option = document.createElement("option");
                option.value = String(currentYear);
                option.textContent = String(currentYear);
                loadingPayYearSelect.appendChild(option);
            }

            loadingPayMonthSelect.value = String(currentMonth);
            loadingPayYearSelect.value = String(currentYear);
            loadingPayState = { month: currentMonth, year: currentYear, loading: false };
            transportPayState = { month: currentMonth, year: currentYear, loading: false };
        }

        async function loadLoadingPayData() {
            if (!loadingPayMonthSelect || !loadingPayYearSelect) {
                return;
            }

            const monthValue = Number.parseInt(loadingPayMonthSelect.value, 10);
            const yearValue = Number.parseInt(loadingPayYearSelect.value, 10);

            if (!Number.isFinite(monthValue) || !Number.isFinite(yearValue)) {
                return;
            }

            loadingPayState = { month: monthValue, year: yearValue, loading: true };

            if (loadingPayTableBody) {
                loadingPayTableBody.innerHTML = "";
            }
            if (loadingPayEmptyState) {
                loadingPayEmptyState.hidden = true;
            }
            setLoadingPayMessage("Loading loading pay details…");

            try {
                const params = new URLSearchParams({
                    month: String(monthValue),
                    year: String(yearValue),
                });
                const response = await fetch(`/api/team/loading-pay?${params.toString()}`, {
                    headers: authHeaders,
                });

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }

                const body = await response.json().catch(() => ({}));
                const records = Array.isArray(body?.records) ? body.records : [];
                const rate = Number(body?.rate);

                if (loadingPayRateValue) {
                    loadingPayRateValue.textContent = Number.isFinite(rate)
                        ? numberFormatter.format(rate)
                        : "—";
                }

                renderLoadingPayTable(records);
                setLoadingPayMessage("");
            } catch (error) {
                console.error("Failed to load loading pay data", error);
                if (loadingPayRateValue) {
                    loadingPayRateValue.textContent = "—";
                }
                setLoadingPayMessage("Unable to load loading pay details right now.", "error");
            } finally {
                loadingPayState = { month: monthValue, year: yearValue, loading: false };
            }
        }

        async function loadTransportPayData() {
            if (!loadingPayMonthSelect || !loadingPayYearSelect) {
                return;
            }

            const monthValue = Number.parseInt(loadingPayMonthSelect.value, 10);
            const yearValue = Number.parseInt(loadingPayYearSelect.value, 10);

            if (!Number.isFinite(monthValue) || !Number.isFinite(yearValue)) {
                return;
            }

            transportPayState = { month: monthValue, year: yearValue, loading: true };

            if (transportPayTableBody) {
                transportPayTableBody.innerHTML = "";
            }
            if (transportPayEmptyState) {
                transportPayEmptyState.hidden = true;
            }
            setTransportPayMessage("Loading transport pay details…");

            try {
                const params = new URLSearchParams({
                    month: String(monthValue),
                    year: String(yearValue),
                });
                const response = await fetch(`/api/team/transport-pay?${params.toString()}`, {
                    headers: authHeaders,
                });

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }

                const body = await response.json().catch(() => ({}));
                const records = Array.isArray(body?.records) ? body.records : [];

                renderTransportPayTable(records);
                setTransportPayMessage("");
            } catch (error) {
                console.error("Failed to load transport pay data", error);
                setTransportPayMessage("Unable to load transport pay details right now.", "error");
            } finally {
                transportPayState = { month: monthValue, year: yearValue, loading: false };
            }
        }

        const getWeekdayIndex = (year, month, day) => {
            const date = new Date(Date.UTC(year, month - 1, day));
            const label = workCalendarWeekdayFormatter.format(date);
            return WORK_CALENDAR_WEEKDAY_INDEX[label] ?? 0;
        };

        const buildCalendarCells = (year, month) => {
            const monthIndex = month - 1;
            const firstDayIndex = getWeekdayIndex(year, month, 1);
            const cells = [];

            const previousMonthDate = new Date(Date.UTC(year, monthIndex, 0));
            const previousMonthDays = previousMonthDate.getUTCDate();
            const previousMonthYear = previousMonthDate.getUTCFullYear();
            const previousMonthIndex = previousMonthDate.getUTCMonth();

            for (let offset = firstDayIndex - 1; offset >= 0; offset -= 1) {
                const dayNumber = previousMonthDays - offset;
                const iso = formatIsoDate(
                    previousMonthYear,
                    previousMonthIndex + 1,
                    dayNumber,
                );
                cells.push({
                    iso,
                    dayNumber,
                    year: previousMonthYear,
                    month: previousMonthIndex + 1,
                    inCurrentMonth: false,
                });
            }

            const daysInMonth = new Date(Date.UTC(year, monthIndex + 1, 0)).getUTCDate();
            for (let day = 1; day <= daysInMonth; day += 1) {
                const iso = formatIsoDate(year, month, day);
                cells.push({
                    iso,
                    dayNumber: day,
                    year,
                    month,
                    inCurrentMonth: true,
                });
            }

            const totalCells = 42;
            let nextDate = new Date(Date.UTC(year, monthIndex + 1, 1));
            while (cells.length < totalCells) {
                const nextYear = nextDate.getUTCFullYear();
                const nextMonth = nextDate.getUTCMonth() + 1;
                const nextDay = nextDate.getUTCDate();
                cells.push({
                    iso: formatIsoDate(nextYear, nextMonth, nextDay),
                    dayNumber: nextDay,
                    year: nextYear,
                    month: nextMonth,
                    inCurrentMonth: false,
                });
                nextDate.setUTCDate(nextDate.getUTCDate() + 1);
            }

            return cells;
        };

        const createColomboDate = (iso) => new Date(`${iso}T00:00:00+05:30`);

        const truncateHolidayName = (value) => {
            if (typeof value !== "string") {
                return "";
            }
            const trimmed = value.trim();
            if (trimmed.length <= 28) {
                return trimmed;
            }
            return `${trimmed.slice(0, 27)}…`;
        };

        const setWorkCalendarLoading = (isLoading) => {
            workCalendarState = {
                ...workCalendarState,
                loading: Boolean(isLoading),
            };

            if (workCalendarLoading) {
                workCalendarLoading.hidden = !isLoading;
                workCalendarLoading.style.display = isLoading ? "flex" : "none";
            }
            if (workCalendarGrid) {
                workCalendarGrid.setAttribute("aria-busy", isLoading ? "true" : "false");
            }
            if (workCalendarYearSelect) {
                workCalendarYearSelect.disabled = isLoading;
            }
            if (workCalendarMonthSelect) {
                workCalendarMonthSelect.disabled = isLoading;
            }
        };

        const showWorkCalendarMessage = (message, tone = "info") => {
            if (!workCalendarMessage) {
                return;
            }
            workCalendarMessage.textContent = message;
            workCalendarMessage.hidden = false;
            workCalendarMessage.classList.remove(
                "work-calendar__message--error",
                "work-calendar__message--success",
            );
            if (tone === "error") {
                workCalendarMessage.classList.add("work-calendar__message--error");
            } else if (tone === "success") {
                workCalendarMessage.classList.add("work-calendar__message--success");
            }
        };

        const hideWorkCalendarMessage = () => {
            if (!workCalendarMessage) {
                return;
            }
            workCalendarMessage.hidden = true;
            workCalendarMessage.textContent = "";
            workCalendarMessage.classList.remove(
                "work-calendar__message--error",
                "work-calendar__message--success",
            );
        };

        const ensureWorkCalendarYearOptions = (activeYear) => {
            if (!workCalendarYearSelect) {
                return;
            }
            const baseYear = Number.isFinite(activeYear) ? activeYear : new Date().getFullYear();
            const years = [];
            for (let year = baseYear - 2; year <= baseYear + 2; year += 1) {
                years.push(year);
            }

            let requiresUpdate = workCalendarYearSelect.options.length !== years.length;
            if (!requiresUpdate) {
                requiresUpdate = years.some((year, index) => {
                    const option = workCalendarYearSelect.options[index];
                    return Number.parseInt(option.value, 10) !== year;
                });
            }

            if (requiresUpdate) {
                workCalendarYearSelect.innerHTML = "";
                years.forEach((year) => {
                    const option = document.createElement("option");
                    option.value = String(year);
                    option.textContent = String(year);
                    workCalendarYearSelect.appendChild(option);
                });
            }

            workCalendarYearSelect.value = String(activeYear);
        };

        const ensureWorkCalendarMonthOptions = (activeMonth) => {
            if (!workCalendarMonthSelect) {
                return;
            }
            if (workCalendarMonthSelect.options.length !== 12) {
                workCalendarMonthSelect.innerHTML = "";
                WORK_CALENDAR_MONTH_NAMES.forEach((name, index) => {
                    const option = document.createElement("option");
                    option.value = String(index + 1);
                    option.textContent = name;
                    workCalendarMonthSelect.appendChild(option);
                });
            }
            workCalendarMonthSelect.value = String(activeMonth);
        };

        const setWorkCalendarSelectors = (year, month) => {
            ensureWorkCalendarYearOptions(year);
            ensureWorkCalendarMonthOptions(month);
        };

        const getWorkCalendarMonthStore = (year, month) =>
            workCalendarStore.get(getMonthKey(year, month));

        const ensureWorkCalendarMonthData = async (year, month, { force = false } = {}) => {
            const key = getMonthKey(year, month);
            if (!force && workCalendarStore.has(key)) {
                return workCalendarStore.get(key);
            }

            setWorkCalendarLoading(true);

            try {
                const params = new URLSearchParams({
                    year: String(year),
                    month: String(month),
                });
                const response = await fetch(`/api/team/work-calendar?${params.toString()}`, {
                    headers: authHeaders,
                });

                let data = null;
                try {
                    data = await response.json();
                } catch (_error) {
                    data = null;
                }

                if (!response.ok) {
                    const message = data?.msg || "Unable to load the work calendar.";
                    throw new Error(message);
                }

                const map = new Map();
                if (data && Array.isArray(data.days)) {
                    data.days.forEach((item) => {
                        if (!item || typeof item.date !== "string") {
                            return;
                        }
                        map.set(item.date, {
                            isWorkDay: item.isWorkDay !== false,
                            holidayName:
                                typeof item.holidayName === "string" && item.holidayName
                                    ? item.holidayName
                                    : null,
                            updatedAt: item.updatedAt || null,
                        });
                    });
                }

                workCalendarStore.set(key, map);
                return map;
            } finally {
                setWorkCalendarLoading(false);
            }
        };

        const updateWorkCalendarStoreEntry = (iso, entry) => {
            const parts = parseIsoDate(iso);
            if (!parts) {
                return;
            }
            const key = getMonthKey(parts.year, parts.month);
            if (!workCalendarStore.has(key)) {
                workCalendarStore.set(key, new Map());
            }
            const store = workCalendarStore.get(key);

            if (!entry || (entry.isWorkDay !== false && !entry.holidayName)) {
                store.delete(iso);
            } else {
                store.set(iso, {
                    isWorkDay: entry.isWorkDay !== false,
                    holidayName: entry.holidayName ? String(entry.holidayName) : null,
                    updatedAt: entry.updatedAt || null,
                });
            }

            if (store.size === 0) {
                workCalendarStore.delete(key);
            }
        };

        const renderWorkCalendar = () => {
            if (!workCalendarGrid || !workCalendarState.year || !workCalendarState.month) {
                return;
            }

            const { year, month } = workCalendarState;
            const cells = buildCalendarCells(year, month);
            const monthStore = getWorkCalendarMonthStore(year, month);
            const todayIso = getTodayIso();

            workCalendarGrid.innerHTML = "";
            workCalendarGrid.dataset.month = getMonthKey(year, month);

            cells.forEach((cell) => {
                const button = document.createElement("button");
                button.type = "button";
                button.className = "work-calendar__day";
                button.dataset.date = cell.iso;

                if (!cell.inCurrentMonth) {
                    button.classList.add("work-calendar__day--muted");
                }

                const entry = monthStore?.get(cell.iso);
                const isWorkDay = entry ? entry.isWorkDay !== false : true;

                if (!isWorkDay) {
                    button.classList.add("work-calendar__day--off");
                }

                if (cell.iso === todayIso) {
                    button.classList.add("work-calendar__day--today");
                }

                const numberEl = document.createElement("span");
                numberEl.className = "work-calendar__day-number";
                numberEl.textContent = String(cell.dayNumber);
                button.appendChild(numberEl);

                const badge = document.createElement("span");
                badge.className = `work-calendar__badge ${
                    isWorkDay ? "work-calendar__badge--work" : "work-calendar__badge--off"
                }`;
                badge.textContent = isWorkDay ? "✅ Work day" : "❌ Not work day";
                button.appendChild(badge);

                if (!isWorkDay && entry?.holidayName) {
                    const holiday = document.createElement("span");
                    holiday.className = "work-calendar__holiday";
                    holiday.textContent = truncateHolidayName(entry.holidayName);
                    holiday.title = entry.holidayName;
                    button.appendChild(holiday);
                }

                const labelDate = workCalendarDateFormatter.format(createColomboDate(cell.iso));
                button.setAttribute(
                    "aria-label",
                    `${labelDate}: ${isWorkDay ? "Work day" : "Not work day"}`,
                );

                button.addEventListener("click", async () => {
                    if (!cell.inCurrentMonth) {
                        try {
                            await setWorkCalendarMonth(cell.year, cell.month);
                        } catch (error) {
                            console.error("Failed to change calendar month", error);
                            return;
                        }
                    }
                    openWorkdayModal(cell.iso);
                });

                workCalendarGrid.appendChild(button);
            });
        };

        const setWorkCalendarMonth = async (year, month, { force = false } = {}) => {
            if (!Number.isFinite(year) || !Number.isFinite(month)) {
                return;
            }
            if (month < 1 || month > 12) {
                return;
            }

            workCalendarState = {
                ...workCalendarState,
                year,
                month,
            };

            setWorkCalendarSelectors(year, month);

            try {
                await ensureWorkCalendarMonthData(year, month, { force });
                hideWorkCalendarMessage();
            } catch (error) {
                console.error("Unable to load work calendar", error);
                showWorkCalendarMessage(
                    error?.message || "Unable to load the work calendar.",
                    "error",
                );
            }

            renderWorkCalendar();
        };

        const updateHolidayInputState = (isNotWorkDay, value = "") => {
            if (!workdayHolidayInput) {
                return;
            }
            workdayHolidayInput.disabled = !isNotWorkDay;
            if (isNotWorkDay) {
                workdayHolidayInput.value = value || "";
            } else {
                workdayHolidayInput.value = "";
            }
        };

        const closeWorkdayModal = () => {
            if (!workdayModal) {
                return;
            }
            workdayModal.classList.remove("modal--open");
            workdayModal.setAttribute("hidden", "");
            workdayModal.setAttribute("aria-hidden", "true");
            document.body.classList.remove("modal-open");
            if (workdayForm) {
                workdayForm.reset();
            }
            updateHolidayInputState(false);
            if (workdayFormError) {
                workdayFormError.hidden = true;
                workdayFormError.textContent = "";
            }
            workdayModalContext = null;
            if (workdayModal.dataset) {
                delete workdayModal.dataset.date;
            }
        };

        const openWorkdayModal = (iso) => {
            if (!workdayModal || !workdayForm) {
                return;
            }
            const parts = parseIsoDate(iso);
            if (!parts) {
                return;
            }
            const key = getMonthKey(parts.year, parts.month);
            const store = workCalendarStore.get(key);
            const entry = store?.get(iso);
            const isWorkDay = entry ? entry.isWorkDay !== false : true;

            workdayForm.reset();

            if (workdayDateDisplay) {
                workdayDateDisplay.textContent = workCalendarDateFormatter.format(
                    createColomboDate(iso),
                );
            }
            if (workdayFormError) {
                workdayFormError.hidden = true;
                workdayFormError.textContent = "";
            }

            if (workdayStatusWork) {
                workdayStatusWork.checked = isWorkDay;
            }
            if (workdayStatusOff) {
                workdayStatusOff.checked = !isWorkDay;
            }

            updateHolidayInputState(!isWorkDay, entry?.holidayName ?? "");

            workdayModalContext = {
                iso,
                year: parts.year,
                month: parts.month,
            };

            workdayModal.removeAttribute("hidden");
            workdayModal.setAttribute("aria-hidden", "false");
            workdayModal.classList.add("modal--open");
            document.body.classList.add("modal-open");
            workdayModal.dataset.date = iso;

            const focusTarget = !isWorkDay && workdayHolidayInput ? workdayHolidayInput : workdayStatusOff;
            if (focusTarget) {
                setTimeout(() => focusTarget.focus(), 0);
            }
        };

        const normalizeTimeValue = (value) => {
            if (typeof value !== "string") {
                return "";
            }

            let text = value.trim();
            if (!text) {
                return "";
            }

            text = text.replace(/[.]/g, ":").replace(/\s+/g, " ");

            const twelveHourMatch = TIME_12_HOUR_PATTERN.exec(text);
            if (twelveHourMatch) {
                let [_, hours, minutes, meridiem] = twelveHourMatch;
                let hourNumber = Number.parseInt(hours, 10);
                if (Number.isNaN(hourNumber)) {
                    return "";
                }

                meridiem = meridiem.toUpperCase();
                if (meridiem === "AM") {
                    if (hourNumber === 12) {
                        hourNumber = 0;
                    }
                } else if (meridiem === "PM") {
                    if (hourNumber !== 12) {
                        hourNumber += 12;
                    }
                }

                if (hourNumber < 0 || hourNumber > 23) {
                    return "";
                }

                return `${String(hourNumber).padStart(2, "0")}:${minutes}`;
            }

            const twentyFourHourMatch = TIME_24_HOUR_PATTERN.exec(text);
            if (twentyFourHourMatch) {
                const [, hours, minutes] = twentyFourHourMatch;
                const hourNumber = Number.parseInt(hours, 10);

                if (!Number.isNaN(hourNumber) && hourNumber >= 0 && hourNumber <= 23) {
                    return `${String(hourNumber).padStart(2, "0")}:${minutes}`;
                }
            }

            const compactMatch = TIME_COMPACT_PATTERN.exec(text);
            if (compactMatch) {
                const [, hours, minutes] = compactMatch;
                const hourNumber = Number.parseInt(hours, 10);

                if (!Number.isNaN(hourNumber) && hourNumber >= 0 && hourNumber <= 23) {
                    return `${String(hourNumber).padStart(2, "0")}:${minutes}`;
                }
            }

            return "";
        };

        const MINUTES_PER_DAY = 24 * 60;

        const parseTimeToMinutes = (value) => {
            if (typeof value !== "string") {
                return null;
            }

            const match = /^(\d{1,2}):([0-5]\d)$/.exec(value.trim());
            if (!match) {
                return null;
            }

            const hours = Number.parseInt(match[1], 10);
            const minutes = Number.parseInt(match[2], 10);

            if (
                Number.isNaN(hours) ||
                Number.isNaN(minutes) ||
                hours < 0 ||
                hours > 23 ||
                minutes < 0 ||
                minutes > 59
            ) {
                return null;
            }

            return hours * 60 + minutes;
        };

        const buildTimeAdjustments = (rules) =>
            rules
                .map(({ start, end, target }) => {
                    const startMinutes = parseTimeToMinutes(start);
                    const endMinutes = parseTimeToMinutes(end);
                    const targetMinutes = parseTimeToMinutes(target);

                    if (
                        startMinutes == null ||
                        endMinutes == null ||
                        targetMinutes == null
                    ) {
                        return null;
                    }

                    return {
                        start: Math.min(startMinutes, endMinutes),
                        end: Math.max(startMinutes, endMinutes),
                        target: targetMinutes,
                    };
                })
                .filter(Boolean);

        const ON_TIME_ADJUSTMENTS = buildTimeAdjustments([
            { start: "06:36", end: "07:04", target: "07:00" },
            { start: "07:05", end: "07:16", target: "07:15" },
            { start: "07:17", end: "07:31", target: "07:30" },
            { start: "07:32", end: "07:46", target: "07:45" },
            { start: "07:46", end: "08:04", target: "08:00" },
        ]);

        const OFF_TIME_ADJUSTMENTS = buildTimeAdjustments([
            { start: "18:59", end: "19:14", target: "19:00" },
            { start: "18:44", end: "18:58", target: "18:45" },
            { start: "18:29", end: "18:43", target: "18:30" },
            { start: "18:14", end: "18:28", target: "18:15" },
            { start: "17:58", end: "18:13", target: "18:00" },
        ]);

        const applyTimeAdjustment = (minutes, adjustments) => {
            if (!Number.isFinite(minutes)) {
                return null;
            }

            for (const adjustment of adjustments) {
                if (minutes >= adjustment.start && minutes <= adjustment.end) {
                    return adjustment.target;
                }
            }

            return minutes;
        };

        const formatMinutesAsDuration = (minutes) => {
            if (!Number.isFinite(minutes) || minutes < 0) {
                return "—";
            }

            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;

            return `${String(hours).padStart(2, "0")}:${String(remainingMinutes).padStart(
                2,
                "0"
            )}`;
        };

        const computeDurationMinutes = (startMinutes, endMinutes) => {
            if (!Number.isFinite(startMinutes) || !Number.isFinite(endMinutes)) {
                return null;
            }

            let difference = endMinutes - startMinutes;
            if (difference < 0) {
                difference += MINUTES_PER_DAY;
            }

            if (difference < 0) {
                return null;
            }

            return difference;
        };

        const computeActualMinutes = (onValue, offValue) => {
            const onMinutes = parseTimeToMinutes(onValue);
            const offMinutes = parseTimeToMinutes(offValue);

            if (onMinutes == null || offMinutes == null) {
                return null;
            }

            return computeDurationMinutes(onMinutes, offMinutes);
        };

        const computePayMinutes = (onValue, offValue) => {
            const onMinutes = parseTimeToMinutes(onValue);
            const offMinutes = parseTimeToMinutes(offValue);

            if (onMinutes == null || offMinutes == null) {
                return null;
            }

            const adjustedOn = applyTimeAdjustment(onMinutes, ON_TIME_ADJUSTMENTS);
            const adjustedOff = applyTimeAdjustment(offMinutes, OFF_TIME_ADJUSTMENTS);

            if (adjustedOn == null || adjustedOff == null) {
                return null;
            }

            return computeDurationMinutes(adjustedOn, adjustedOff);
        };

        const MEAL_BREAK_START_MINUTES = parseTimeToMinutes("12:45") ?? 12 * 60 + 45;
        const MEAL_BREAK_END_MINUTES = parseTimeToMinutes("13:45") ?? 13 * 60 + 45;

        const getWorkCalendarDayInfo = (iso) => {
            const parts = parseIsoDate(iso);
            if (!parts) {
                return { isWorkDay: true, parts: null };
            }

            const store = getWorkCalendarMonthStore(parts.year, parts.month);
            const entry = store?.get(iso);

            return {
                isWorkDay: entry ? entry.isWorkDay !== false : true,
                parts,
            };
        };

        const doesPeriodIncludeMealBreak = (startMinutes, endMinutes) => {
            if (!Number.isFinite(startMinutes) || !Number.isFinite(endMinutes)) {
                return false;
            }

            let adjustedEnd = endMinutes;
            if (adjustedEnd <= startMinutes) {
                adjustedEnd += MINUTES_PER_DAY;
            }

            const intervals = [
                [MEAL_BREAK_START_MINUTES, MEAL_BREAK_END_MINUTES],
                [
                    MEAL_BREAK_START_MINUTES + MINUTES_PER_DAY,
                    MEAL_BREAK_END_MINUTES + MINUTES_PER_DAY,
                ],
            ];

            return intervals.some(
                ([mealStart, mealEnd]) => startMinutes < mealEnd && adjustedEnd > mealStart,
            );
        };

        const computeRegularAndOvertimeMinutes = (
            iso,
            onValue,
            offValue,
            payMinutes,
            payCategory,
        ) => {
            if (!iso || !Number.isFinite(payMinutes) || payMinutes < 0) {
                return { regularMinutes: null, overtimeMinutes: null };
            }

            const info = getWorkCalendarDayInfo(iso);
            if (!info.parts) {
                return {
                    regularMinutes: payMinutes,
                    overtimeMinutes: 0,
                };
            }

            if (!info.isWorkDay) {
                const onMinutes = parseTimeToMinutes(onValue);
                const offMinutes = parseTimeToMinutes(offValue);
                let overtimeMinutes = payMinutes;

                if (
                    Number.isFinite(onMinutes) &&
                    Number.isFinite(offMinutes) &&
                    doesPeriodIncludeMealBreak(onMinutes, offMinutes) &&
                    overtimeMinutes > 0
                ) {
                    overtimeMinutes = Math.max(overtimeMinutes - 60, 0);
                }

                return {
                    regularMinutes: 0,
                    overtimeMinutes,
                };
            }

            const date = new Date(Date.UTC(info.parts.year, info.parts.month - 1, info.parts.day));
            const dayOfWeek = date.getUTCDay();
            const normalizedCategory =
                typeof payCategory === "string" ? payCategory.trim().toLowerCase() : "";
            let regularLimitMinutes = 9 * 60;

            if (dayOfWeek === 6 && normalizedCategory === "factory") {
                regularLimitMinutes = 5 * 60;
            }

            const overtimeMinutes = Math.max(payMinutes - regularLimitMinutes, 0);
            const regularMinutes = Math.max(Math.min(payMinutes, regularLimitMinutes), 0);

            return { regularMinutes, overtimeMinutes };
        };

        const setAttendanceRowMinutes = (row, key, minutes) => {
            if (!row || !row.dataset || !key) {
                return;
            }

            if (Number.isFinite(minutes) && minutes >= 0) {
                row.dataset[key] = String(Math.round(minutes));
            } else if (Object.prototype.hasOwnProperty.call(row.dataset, key)) {
                delete row.dataset[key];
            }
        };

        const ATTENDANCE_DAY_STATUS_OPTIONS = [
            "Work Day",
            "Not Work Day",
            "Annual Leave",
            "Medical Leave",
            "Special Company Holiday",
            "No Pay Leave",
        ];
        const ATTENDANCE_DAY_STATUS_DEFAULT = ATTENDANCE_DAY_STATUS_OPTIONS[0];

        const normalizeDayStatusValue = (value) => {
            if (typeof value !== "string") {
                return "";
            }
            const trimmed = value.trim();
            return ATTENDANCE_DAY_STATUS_OPTIONS.includes(trimmed) ? trimmed : "";
        };

        const isWorkDayStatus = (value) => {
            if (typeof value !== "string") {
                return false;
            }

            const normalized = normalizeDayStatusValue(value);
            if (normalized) {
                return normalized.toLowerCase().startsWith("work");
            }

            const trimmed = value.trim().toLowerCase();
            return trimmed === "work" || trimmed === "work day";
        };

        const resolveDayStatusValue = (value) => {
            const normalized = normalizeDayStatusValue(value);
            if (normalized) {
                return normalized;
            }
            return ATTENDANCE_DAY_STATUS_DEFAULT;
        };

        const isWorkCalendarDateWorkDay = (iso) => {
            const parts = parseIsoDate(iso);
            if (!parts) {
                return true;
            }
            const store = getWorkCalendarMonthStore(parts.year, parts.month);
            if (!store) {
                return true;
            }
            const entry = store.get(iso);
            return entry ? entry.isWorkDay !== false : true;
        };

        const setDayStatusValue = (select, hiddenInput, value) => {
            const resolved = resolveDayStatusValue(value);
            if (select) {
                select.value = resolved;
            }
            if (hiddenInput) {
                hiddenInput.value = resolved;
            }
            return resolved;
        };

        const applyDayStatusRules = (select, hiddenInput, iso, { payMinutes } = {}) => {
            if (!select && !hiddenInput) {
                return;
            }

            const calendarIsWorkDay = isWorkCalendarDateWorkDay(iso);
            const validPayMinutes = Number.isFinite(payMinutes) && payMinutes >= 0 ? payMinutes : null;

            if (!calendarIsWorkDay) {
                const value = setDayStatusValue(select, hiddenInput, "Not Work Day");
                if (select) {
                    select.disabled = true;
                    select.setAttribute("aria-disabled", "true");
                }
                if (hiddenInput) {
                    hiddenInput.disabled = false;
                    hiddenInput.value = value;
                }
                return;
            }

            if (validPayMinutes != null && validPayMinutes > 0) {
                const value = setDayStatusValue(select, hiddenInput, "Work Day");
                if (select) {
                    select.disabled = true;
                    select.setAttribute("aria-disabled", "true");
                }
                if (hiddenInput) {
                    hiddenInput.disabled = false;
                    hiddenInput.value = value;
                }
                return;
            }

            const candidateValues = [
                select?.dataset?.userValue,
                select?.dataset?.initialValue,
            ];
            let target = "";
            for (const candidate of candidateValues) {
                const normalized = normalizeDayStatusValue(candidate);
                if (normalized) {
                    target = normalized;
                    break;
                }
            }

            const value = setDayStatusValue(select, hiddenInput, target);
            if (select) {
                select.disabled = false;
                select.removeAttribute("aria-disabled");
            }
            if (hiddenInput) {
                hiddenInput.disabled = true;
                hiddenInput.value = value;
            }
        };

        const refreshAttendanceTotals = () => {
            if (!attendanceTableBody) {
                return;
            }

            const rows = Array.from(attendanceTableBody.querySelectorAll("tr[data-date]")) || [];
            let totalPay = 0;
            let totalRegular = 0;
            let totalOvertime = 0;
            let hasPay = false;
            let hasRegular = false;
            let hasOvertime = false;

            rows.forEach((row) => {
                const pay = Number.parseInt(row.dataset.payMinutes ?? "", 10);
                if (Number.isFinite(pay)) {
                    totalPay += pay;
                    hasPay = true;
                }

                const regular = Number.parseInt(row.dataset.regularMinutes ?? "", 10);
                if (Number.isFinite(regular)) {
                    totalRegular += regular;
                    hasRegular = true;
                }

                const overtime = Number.parseInt(row.dataset.overtimeMinutes ?? "", 10);
                if (Number.isFinite(overtime)) {
                    totalOvertime += overtime;
                    hasOvertime = true;
                }
            });

            if (attendanceTotalPayHours) {
                attendanceTotalPayHours.textContent = hasPay
                    ? formatMinutesAsDuration(totalPay)
                    : "00:00";
            }

            if (attendanceTotalRegularHours) {
                attendanceTotalRegularHours.textContent = hasRegular
                    ? formatMinutesAsDuration(totalRegular)
                    : "00:00";
            }

            if (attendanceTotalOvertimeHours) {
                attendanceTotalOvertimeHours.textContent = hasOvertime
                    ? formatMinutesAsDuration(totalOvertime)
                    : "00:00";
            }

            updateAttendanceLeaveSummaryDisplay();
        };

        const resetAttendanceTotals = () => {
            if (attendanceTotalPayHours) {
                attendanceTotalPayHours.textContent = "00:00";
            }
            if (attendanceTotalRegularHours) {
                attendanceTotalRegularHours.textContent = "00:00";
            }
            if (attendanceTotalOvertimeHours) {
                attendanceTotalOvertimeHours.textContent = "00:00";
            }
        };

        const ensureIntegerValue = (value) => {
            if (typeof value === "number" && Number.isFinite(value)) {
                return Math.trunc(value);
            }
            if (typeof value === "string") {
                const trimmed = value.trim();
                if (!trimmed) {
                    return null;
                }
                const parsed = Number.parseInt(trimmed, 10);
                return Number.isFinite(parsed) ? parsed : null;
            }
            return null;
        };

        const cloneLeaveSummary = (summary) => {
            if (!summary || typeof summary !== "object") {
                return null;
            }
            const annual = summary.annual && typeof summary.annual === "object" ? summary.annual : {};
            const medical = summary.medical && typeof summary.medical === "object" ? summary.medical : {};
            return {
                workDays: ensureIntegerValue(summary.workDays),
                noPayDays: ensureIntegerValue(summary.noPayDays),
                annual: {
                    broughtForward: ensureIntegerValue(annual.broughtForward),
                    thisMonth: ensureIntegerValue(annual.thisMonth),
                    balance: ensureIntegerValue(annual.balance),
                },
                medical: {
                    broughtForward: ensureIntegerValue(medical.broughtForward),
                    thisMonth: ensureIntegerValue(medical.thisMonth),
                    balance: ensureIntegerValue(medical.balance),
                },
            };
        };

        const getAttendanceLeaveSummaryRecord = (month, memberKey) => {
            if (!month || !memberKey) {
                return null;
            }
            return attendanceLeaveSummaryStore[month]?.[memberKey] || null;
        };

        const resetAttendanceLeaveSummaryDisplay = () => {
            Object.values(attendanceLeaveElements).forEach((element) => {
                if (element) {
                    element.textContent = "—";
                }
            });
        };

        const computeAttendanceDraftLeaveCounts = () => {
            if (!attendanceTableBody) {
                return null;
            }

            const rows = Array.from(attendanceTableBody.querySelectorAll("tr[data-date]"));
            if (rows.length === 0) {
                return { workDays: 0, noPayDays: 0, annualLeave: 0, medicalLeave: 0 };
            }

            const counts = { workDays: 0, noPayDays: 0, annualLeave: 0, medicalLeave: 0 };

            rows.forEach((row) => {
                const payMinutes = Number.parseInt(row.dataset.payMinutes ?? "", 10);
                if (Number.isFinite(payMinutes) && payMinutes > 0) {
                    counts.workDays += 1;
                }

                const statusInput = row.querySelector(
                    ".attendance-table__status input[type='hidden'][name^='status-']",
                );
                const status = normalizeDayStatusValue(statusInput?.value ?? "");
                if (status === "No Pay Leave") {
                    counts.noPayDays += 1;
                } else if (status === "Annual Leave") {
                    counts.annualLeave += 1;
                } else if (status === "Medical Leave") {
                    counts.medicalLeave += 1;
                }
            });

            return counts;
        };

        const formatLeaveDisplayValue = (value) => {
            if (value == null || Number.isNaN(value)) {
                return "—";
            }
            return String(value);
        };

        const applyAttendanceLeaveSummary = (storedSummary) => {
            const result = {
                workDays: ensureIntegerValue(storedSummary?.workDays),
                noPayDays: ensureIntegerValue(storedSummary?.noPayDays),
                annual: {
                    broughtForward: ensureIntegerValue(storedSummary?.annual?.broughtForward),
                    thisMonth: ensureIntegerValue(storedSummary?.annual?.thisMonth),
                    balance: ensureIntegerValue(storedSummary?.annual?.balance),
                },
                medical: {
                    broughtForward: ensureIntegerValue(storedSummary?.medical?.broughtForward),
                    thisMonth: ensureIntegerValue(storedSummary?.medical?.thisMonth),
                    balance: ensureIntegerValue(storedSummary?.medical?.balance),
                },
            };

            const draftCounts = computeAttendanceDraftLeaveCounts();

            if (draftCounts) {
                result.workDays = draftCounts.workDays;
                result.noPayDays = draftCounts.noPayDays;

                const annualBroughtForward = ensureIntegerValue(result.annual.broughtForward);
                if (annualBroughtForward != null) {
                    result.annual.broughtForward = annualBroughtForward;
                    result.annual.thisMonth = draftCounts.annualLeave;
                    result.annual.balance = annualBroughtForward - draftCounts.annualLeave;
                } else {
                    result.annual.thisMonth = draftCounts.annualLeave;
                    result.annual.balance = null;
                }

                const medicalBroughtForward = ensureIntegerValue(result.medical.broughtForward);
                if (medicalBroughtForward != null) {
                    result.medical.broughtForward = medicalBroughtForward;
                    result.medical.thisMonth = draftCounts.medicalLeave;
                    result.medical.balance = medicalBroughtForward - draftCounts.medicalLeave;
                } else {
                    result.medical.thisMonth = draftCounts.medicalLeave;
                    result.medical.balance = null;
                }
            }

            if (attendanceLeaveElements.workDays) {
                attendanceLeaveElements.workDays.textContent = formatLeaveDisplayValue(
                    result.workDays,
                );
            }
            if (attendanceLeaveElements.noPayDays) {
                attendanceLeaveElements.noPayDays.textContent = formatLeaveDisplayValue(
                    result.noPayDays,
                );
            }
            if (attendanceLeaveElements.annualBroughtForward) {
                attendanceLeaveElements.annualBroughtForward.textContent = formatLeaveDisplayValue(
                    result.annual.broughtForward,
                );
            }
            if (attendanceLeaveElements.annualThisMonth) {
                attendanceLeaveElements.annualThisMonth.textContent = formatLeaveDisplayValue(
                    result.annual.thisMonth,
                );
            }
            if (attendanceLeaveElements.annualBalance) {
                attendanceLeaveElements.annualBalance.textContent = formatLeaveDisplayValue(
                    result.annual.balance,
                );
            }
            if (attendanceLeaveElements.medicalBroughtForward) {
                attendanceLeaveElements.medicalBroughtForward.textContent = formatLeaveDisplayValue(
                    result.medical.broughtForward,
                );
            }
            if (attendanceLeaveElements.medicalThisMonth) {
                attendanceLeaveElements.medicalThisMonth.textContent = formatLeaveDisplayValue(
                    result.medical.thisMonth,
                );
            }
            if (attendanceLeaveElements.medicalBalance) {
                attendanceLeaveElements.medicalBalance.textContent = formatLeaveDisplayValue(
                    result.medical.balance,
                );
            }
        };

        const updateAttendanceLeaveSummaryDisplay = () => {
            if (!attendanceModalContext?.memberKey) {
                resetAttendanceLeaveSummaryDisplay();
                return;
            }

            const normalizedMonth =
                normalizeMonthValue(currentSalaryMonth) || currentSalaryMonth;
            const summary = getAttendanceLeaveSummaryRecord(
                normalizedMonth,
                attendanceModalContext.memberKey,
            );
            applyAttendanceLeaveSummary(summary);
        };

        const setAttendanceLeaveSummaryRecord = (month, memberKey, summary) => {
            const normalizedMonth = normalizeMonthValue(month);
            if (!normalizedMonth || !memberKey) {
                return;
            }

            if (!attendanceLeaveSummaryStore[normalizedMonth]) {
                attendanceLeaveSummaryStore[normalizedMonth] = {};
            }

            const store = attendanceLeaveSummaryStore[normalizedMonth];
            const cloned = cloneLeaveSummary(summary);

            if (cloned) {
                store[memberKey] = cloned;
            } else if (store[memberKey]) {
                delete store[memberKey];
                if (Object.keys(store).length === 0) {
                    delete attendanceLeaveSummaryStore[normalizedMonth];
                }
            } else if (Object.keys(store).length === 0) {
                delete attendanceLeaveSummaryStore[normalizedMonth];
            }

            if (
                attendanceModalContext?.memberKey === memberKey &&
                (normalizeMonthValue(currentSalaryMonth) || currentSalaryMonth) === normalizedMonth
            ) {
                updateAttendanceLeaveSummaryDisplay();
            }
        };

        const fetchAttendanceLeaveSummary = async (memberId, month) => {
            const normalizedMonth = normalizeMonthValue(month);
            if (memberId == null || !normalizedMonth) {
                return null;
            }

            try {
                const response = await fetch(
                    `/api/team/attendance/${memberId}/summary?month=${encodeURIComponent(normalizedMonth)}`,
                    { headers: authHeaders },
                );

                if (response.status === 401) {
                    logoutButton.click();
                    return null;
                }

                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }

                const body = await response.json().catch(() => ({}));
                return body?.leaveSummary || null;
            } catch (error) {
                console.error("Failed to load leave summary", error);
                return null;
            }
        };

        const loadAttendanceLeaveSummaryForModal = async () => {
            if (!attendanceModalContext?.memberKey) {
                return;
            }

            const normalizedMonth =
                normalizeMonthValue(currentSalaryMonth) || currentSalaryMonth;
            updateAttendanceLeaveSummaryDisplay();

            const memberId = attendanceModalContext.memberId;
            if (memberId == null || !normalizedMonth) {
                return;
            }

            const summary = await fetchAttendanceLeaveSummary(memberId, normalizedMonth);
            if (summary) {
                setAttendanceLeaveSummaryRecord(normalizedMonth, attendanceModalContext.memberKey, summary);
            }
        };

        const updateAttendanceHoursDisplay = (
            row,
            iso,
            onInput,
            offInput,
            actualNode,
            payNode,
            overtimeNode,
            options = {},
        ) => {
            if (!row || !iso || !onInput || !offInput || !actualNode || !payNode || !overtimeNode) {
                return;
            }

            const normalizedOn = normalizeTimeValue(onInput.value ?? "");
            const normalizedOff = normalizeTimeValue(offInput.value ?? "");

            const actualMinutes = computeActualMinutes(normalizedOn, normalizedOff);
            const payMinutes = computePayMinutes(normalizedOn, normalizedOff);

            let regularMinutes = null;
            let overtimeMinutes = null;

            if (Number.isFinite(payMinutes)) {
                const result = computeRegularAndOvertimeMinutes(
                    iso,
                    normalizedOn,
                    normalizedOff,
                    payMinutes,
                    getMemberPayCategory(attendanceModalContext?.member),
                );
                regularMinutes = result.regularMinutes;
                overtimeMinutes = result.overtimeMinutes;
            }

            actualNode.textContent =
                actualMinutes != null ? formatMinutesAsDuration(actualMinutes) : "—";
            payNode.textContent = payMinutes != null ? formatMinutesAsDuration(payMinutes) : "—";
            overtimeNode.textContent =
                overtimeMinutes != null ? formatMinutesAsDuration(overtimeMinutes) : "—";

            setAttendanceRowMinutes(row, "payMinutes", payMinutes);
            setAttendanceRowMinutes(row, "regularMinutes", regularMinutes);
            setAttendanceRowMinutes(row, "overtimeMinutes", overtimeMinutes);

            if (options?.dayStatus) {
                applyDayStatusRules(
                    options.dayStatus.select,
                    options.dayStatus.hiddenInput,
                    iso,
                    { payMinutes },
                );
            }

            refreshAttendanceTotals();

            return {
                actualMinutes,
                payMinutes,
                regularMinutes,
                overtimeMinutes,
            };
        };

        const parseMemberId = (value) => {
            if (typeof value === "number" && Number.isFinite(value)) {
                return value;
            }
            if (typeof value === "string") {
                const trimmed = value.trim();
                if (trimmed) {
                    const parsed = Number.parseInt(trimmed, 10);
                    if (Number.isFinite(parsed)) {
                        return parsed;
                    }
                }
            }
            return null;
        };

        const fetchAttendanceRecords = async (month) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized) {
                return;
            }

            try {
                const response = await fetch(`/api/team/attendance?month=${encodeURIComponent(normalized)}`, {
                    headers: authHeaders,
                });

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }

                const body = await response.json().catch(() => ({}));
                const records = Array.isArray(body?.records) ? body.records : [];
                const monthStore = Object.create(null);

                if (casualOtRateStore[normalized]) {
                    delete casualOtRateStore[normalized];
                }

                records.forEach((record) => {
                    const memberId = parseMemberId(record?.memberId);
                    if (memberId == null) {
                        return;
                    }
                    const storeKey = memberKeyById.get(memberId);
                    if (!storeKey) {
                        return;
                    }
                    const entries = record?.entries;
                    if (
                        entries &&
                        typeof entries === "object" &&
                        Object.keys(entries).length > 0
                    ) {
                        monthStore[storeKey] = entries;
                    }

                    if (record?.leaveSummary) {
                        setAttendanceLeaveSummaryRecord(
                            normalized,
                            storeKey,
                            record.leaveSummary,
                        );
                    }
                });

                attendanceDataStore[normalized] = monthStore;
            } catch (error) {
                console.error("Failed to load attendance records", error);
            }
        };

        const fetchSalaryRecords = async (month) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized) {
                return;
            }

            try {
                const response = await fetch(`/api/team/salary?month=${encodeURIComponent(normalized)}`, {
                    headers: authHeaders,
                });

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }

                const body = await response.json().catch(() => ({}));
                const records = Array.isArray(body?.records) ? body.records : [];
                const monthStore = Object.create(null);

                records.forEach((record) => {
                    const memberId = parseMemberId(record?.memberId);
                    if (memberId == null) {
                        return;
                    }
                    const storeKey = memberKeyById.get(memberId);
                    if (!storeKey) {
                        return;
                    }
                    const components = record?.components;
                    if (
                        components &&
                        typeof components === "object" &&
                        Object.keys(components).length > 0
                    ) {
                        monthStore[storeKey] = components;

                        const rateValue = components.casualOtRate;
                        if (rateValue != null && rateValue !== "") {
                            setCasualOtRate(normalized, storeKey, rateValue);
                        } else {
                            removeCasualOtRate(normalized, storeKey);
                        }
                    }
                });

                salaryDataStore[normalized] = monthStore;

                const targetAllowances =
                    body && typeof body === "object" ? body.targetAllowances : null;
                if (targetAllowances && typeof targetAllowances === "object") {
                    const allowanceStore = Object.create(null);

                    Object.entries(targetAllowances).forEach(([memberIdValue, rawValue]) => {
                        const memberId = parseMemberId(memberIdValue);
                        if (memberId == null) {
                            return;
                        }
                        const storeKey = memberKeyById.get(memberId);
                        if (!storeKey) {
                            return;
                        }

                        let numericValue = null;
                        if (typeof rawValue === "number") {
                            numericValue = rawValue;
                        } else if (typeof rawValue === "string") {
                            const trimmed = rawValue.trim();
                            if (!trimmed) {
                                numericValue = 0;
                            } else {
                                const parsed = Number.parseFloat(trimmed);
                                if (Number.isFinite(parsed)) {
                                    numericValue = parsed;
                                }
                            }
                        }

                        if (Number.isFinite(numericValue)) {
                            allowanceStore[storeKey] = numericValue;
                        }
                    });

                    computedTargetAllowanceStore[normalized] = allowanceStore;
                } else {
                    delete computedTargetAllowanceStore[normalized];
                }
            } catch (error) {
                console.error("Failed to load salary records", error);
                delete computedTargetAllowanceStore[normalized];
            }
        };

        const ATTENDANCE_ALLOWANCE_AMOUNTS = {
            0: 11000,
            1: 9000,
            2: 7500,
            3: 5500,
        };
        const ATTENDANCE_ALLOWANCE_DAILY_RATE = 5500 / 22;
        const MIN_ATTENDANCE_ALLOWANCE_WORK_DAYS = 18;

        const getMonthParts = (value) => {
            const normalized = normalizeMonthValue(value);
            if (!normalized) {
                return null;
            }

            const [yearStr, monthStr] = normalized.split("-");
            const year = Number.parseInt(yearStr, 10);
            const month = Number.parseInt(monthStr, 10);

            if (!Number.isFinite(year) || !Number.isFinite(month)) {
                return null;
            }

            return { normalized, year, month };
        };

        const getMemberPayCategory = (member) => {
            if (!member || typeof member !== "object") {
                return "";
            }
            const raw = member.payCategory ?? member.pay_category;
            if (typeof raw !== "string") {
                return "";
            }
            return raw.trim();
        };

        const isFactoryPayCategory = (member) =>
            getMemberPayCategory(member).toLowerCase() === "factory";

        const isCasualPayCategory = (member) =>
            getMemberPayCategory(member).toLowerCase() === "casual";

        const getWorkCalendarSummaryForMonth = async (month) => {
            const parts = getMonthParts(month);
            if (!parts) {
                return null;
            }

            let store = getWorkCalendarMonthStore(parts.year, parts.month);
            if (!store) {
                try {
                    store = await ensureWorkCalendarMonthData(parts.year, parts.month);
                } catch (error) {
                    console.error(
                        "Unable to load work calendar for attendance allowance calculations",
                        error,
                    );
                    store = getWorkCalendarMonthStore(parts.year, parts.month);
                }
            }

            if (!store) {
                store = new Map();
            }

            const todayIso = getTodayIso();
            const todayParts = parseIsoDate(todayIso);
            const isCurrentMonth =
                todayParts &&
                todayParts.year === parts.year &&
                todayParts.month === parts.month;

            const workDaySet = new Set();
            const futureWorkDaySet = new Set();
            const daysInMonth = new Date(parts.year, parts.month, 0).getDate();

            for (let day = 1; day <= daysInMonth; day += 1) {
                const iso = formatIsoDate(parts.year, parts.month, day);
                const entry = store.get(iso);
                const isWorkDay = entry ? entry.isWorkDay !== false : true;
                if (isWorkDay) {
                    workDaySet.add(iso);
                    if (isCurrentMonth && todayIso && iso >= todayIso) {
                        futureWorkDaySet.add(iso);
                    }
                }
            }

            return {
                workDaySet,
                totalWorkDays: workDaySet.size,
                futureWorkDaySet,
                futureWorkDayCount: futureWorkDaySet.size,
                isCurrentMonth,
            };
        };

        const countWorkedDaysForRecord = (record, workDaySet) => {
            const workedDaySet = new Set();

            if (!record || typeof record !== "object") {
                return { count: 0, workedDaySet };
            }

            let count = 0;
            Object.entries(record).forEach(([iso, entry]) => {
                if (workDaySet && workDaySet.size > 0 && !workDaySet.has(iso)) {
                    return;
                }
                if (!entry || typeof entry !== "object") {
                    return;
                }
                const on = typeof entry.onTime === "string" ? entry.onTime.trim() : "";
                const off = typeof entry.offTime === "string" ? entry.offTime.trim() : "";
                if (on || off) {
                    count += 1;
                    workedDaySet.add(iso);
                }
            });
            return { count, workedDaySet };
        };

        const computeAttendanceAllowanceAmount = (workedDays, totalWorkDays) => {
            if (!Number.isFinite(workedDays) || !Number.isFinite(totalWorkDays)) {
                return null;
            }

            if (totalWorkDays <= 0) {
                return null;
            }

            if (workedDays < MIN_ATTENDANCE_ALLOWANCE_WORK_DAYS) {
                return 0;
            }

            const absences = Math.max(totalWorkDays - workedDays, 0);

            if (Object.prototype.hasOwnProperty.call(ATTENDANCE_ALLOWANCE_AMOUNTS, absences)) {
                return ATTENDANCE_ALLOWANCE_AMOUNTS[absences];
            }

            if (absences >= 4) {
                const computed = ATTENDANCE_ALLOWANCE_DAILY_RATE * workedDays;
                const rounded = Math.round((computed + Number.EPSILON) * 100) / 100;
                return rounded;
            }

            return null;
        };

        const getComputedAttendanceAllowance = (month, memberKey) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized || !memberKey) {
                return null;
            }

            const monthStore = computedAttendanceAllowanceStore[normalized];
            if (!monthStore) {
                return null;
            }

            if (Object.prototype.hasOwnProperty.call(monthStore, memberKey)) {
                return monthStore[memberKey];
            }

            return null;
        };

        const getComputedTargetAllowance = (month, memberKey) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized || !memberKey) {
                return null;
            }

            const monthStore = computedTargetAllowanceStore[normalized];
            if (!monthStore) {
                return null;
            }

            if (Object.prototype.hasOwnProperty.call(monthStore, memberKey)) {
                return monthStore[memberKey];
            }

            return null;
        };

        const updateComputedAttendanceAllowances = async (month) => {
            const parts = getMonthParts(month);
            if (!parts) {
                return;
            }

            computedAttendanceAllowanceStore[parts.normalized] = {};

            if (!Array.isArray(activeMembers) || activeMembers.length === 0) {
                return;
            }

            const calendarSummary = await getWorkCalendarSummaryForMonth(parts.normalized);
            if (!calendarSummary || calendarSummary.totalWorkDays <= 0) {
                return;
            }

            const monthAttendanceStore = attendanceDataStore[parts.normalized] || {};
            const allowances = Object.create(null);

            activeMembers.forEach((member, index) => {
                if (!isFactoryPayCategory(member)) {
                    return;
                }

                const memberKey = computeMemberKey(member, index);
                if (!memberKey) {
                    return;
                }

                const record = monthAttendanceStore[memberKey] || {};
                const { count: recordedWorkedDays, workedDaySet } =
                    countWorkedDaysForRecord(record, calendarSummary.workDaySet);

                let effectiveWorkedDays = recordedWorkedDays;

                if (
                    calendarSummary.isCurrentMonth &&
                    calendarSummary.futureWorkDaySet &&
                    calendarSummary.futureWorkDaySet.size > 0
                ) {
                    calendarSummary.futureWorkDaySet.forEach((iso) => {
                        if (workedDaySet.has(iso)) {
                            return;
                        }
                        if (Object.prototype.hasOwnProperty.call(record, iso)) {
                            return;
                        }
                        effectiveWorkedDays += 1;
                    });
                }

                if (calendarSummary.totalWorkDays > 0) {
                    effectiveWorkedDays = Math.min(
                        effectiveWorkedDays,
                        calendarSummary.totalWorkDays,
                    );
                }

                const computedValue = computeAttendanceAllowanceAmount(
                    effectiveWorkedDays,
                    calendarSummary.totalWorkDays,
                );

                if (computedValue != null) {
                    allowances[memberKey] = computedValue;
                }
            });

            computedAttendanceAllowanceStore[parts.normalized] = allowances;
        };

        const refreshMonthData = async (month = currentSalaryMonth) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized) {
                return;
            }

            await Promise.all([
                fetchAttendanceRecords(normalized),
                fetchSalaryRecords(normalized),
            ]);

            await updateComputedAttendanceAllowances(normalized);

            renderSalarySheet();
            refreshAttendanceModalContents();

            if (
                salaryModalContext?.memberKey &&
                normalizeMonthValue(salaryFormMonth?.value || normalized) === normalized
            ) {
                populateSalaryFormFields(
                    getSalaryRecord(normalized, salaryModalContext.memberKey),
                    {
                        memberKey: salaryModalContext.memberKey,
                        month: normalized,
                        member: salaryModalContext.member,
                    },
                );
            }
        };

        const getMonthDateEntries = (month) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized) {
                return [];
            }

            const [yearStr, monthStr] = normalized.split("-");
            const year = Number(yearStr);
            const monthIndex = Number(monthStr) - 1;

            if (!Number.isFinite(year) || !Number.isFinite(monthIndex)) {
                return [];
            }

            if (monthIndex < 0 || monthIndex > 11) {
                return [];
            }

            const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
            const entries = [];

            for (let day = 1; day <= daysInMonth; day += 1) {
                const iso = `${year}-${String(monthIndex + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
                const display = attendanceDateFormatter.format(
                    new Date(year, monthIndex, day)
                );
                entries.push({ iso, display });
            }

            return entries;
        };

        const formatAttendanceMonthLabel = (month) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized) {
                return "—";
            }

            const [yearStr, monthStr] = normalized.split("-");
            const year = Number(yearStr);
            const monthIndex = Number(monthStr) - 1;
            if (!Number.isFinite(year) || !Number.isFinite(monthIndex)) {
                return "—";
            }

            const date = new Date(year, monthIndex, 1);
            if (Number.isNaN(date.getTime())) {
                return "—";
            }

            return attendanceMonthFormatter.format(date);
        };

        const formatSalaryValue = (value) => {
            if (value == null) {
                return "—";
            }
            const stringValue = String(value).trim();
            if (!stringValue) {
                return "—";
            }
            const numeric = Number(stringValue);
            if (Number.isFinite(numeric)) {
                return numberFormatter.format(numeric);
            }
            return stringValue;
        };

        const formatNumberForInput = (value) => {
            if (!Number.isFinite(value)) {
                return "";
            }

            const rounded = Math.round((value + Number.EPSILON) * 100) / 100;
            const normalized = Math.abs(rounded) < 0.005 ? 0 : rounded;
            return normalized.toFixed(2);
        };

        const memberHasEpfNumber = (member) => {
            if (!member || typeof member !== "object") {
                return false;
            }

            const value = member.epf;
            if (typeof value === "string") {
                return value.trim().length > 0;
            }

            return value != null;
        };

        const parseNumericAmount = (value) => {
            if (typeof value === "number") {
                return Number.isFinite(value) ? value : null;
            }

            if (typeof value === "string") {
                const normalized = value.replace(/,/g, "").trim();
                if (!normalized) {
                    return null;
                }

                const parsed = Number.parseFloat(normalized);
                return Number.isFinite(parsed) ? parsed : null;
            }

            return null;
        };

        const computeTotalDeductionAmountFromComponents = (components) => {
            if (!components || typeof components !== "object") {
                return 0;
            }

            let total = 0;

            deductionFieldNames.forEach((name) => {
                const parsed = parseNumericAmount(components[name]);
                if (Number.isFinite(parsed)) {
                    total += parsed;
                }
            });

            return total;
        };

        const computeNetPayAmountFromComponents = (components, totalDeductionOverride) => {
            if (!components || typeof components !== "object") {
                return null;
            }

            const grossValue = parseNumericAmount(components.grossSalary);
            if (!Number.isFinite(grossValue)) {
                return null;
            }

            let deductionTotal = totalDeductionOverride;

            if (!Number.isFinite(deductionTotal)) {
                deductionTotal = computeTotalDeductionAmountFromComponents(components);
            }

            return grossValue - deductionTotal;
        };

        const computeProvidentFundAmount = (member, basicSalaryValue) => {
            if (!memberHasEpfNumber(member)) {
                return null;
            }

            const numericBasic = parseNumericAmount(basicSalaryValue);
            if (!Number.isFinite(numericBasic)) {
                return null;
            }

            const amount = numericBasic * 0.08;
            return Math.round((amount + Number.EPSILON) * 100) / 100;
        };

        const computeMemberKey = (member, fallbackIndex = null) => {
            if (!member || typeof member !== "object") {
                return fallbackIndex != null ? `idx:${fallbackIndex}` : null;
            }
            if (member.id != null) {
                return `id:${member.id}`;
            }
            if (member.regNumber != null) {
                return `reg:${member.regNumber}`;
            }
            if (member.name) {
                return `name:${member.name}`;
            }
            return fallbackIndex != null ? `idx:${fallbackIndex}` : null;
        };

        let currentSalaryMonth = getInitialSalaryMonth();

        if (salaryMonthSelector) {
            const normalizedExisting = normalizeMonthValue(salaryMonthSelector.value);
            if (normalizedExisting) {
                currentSalaryMonth = normalizedExisting;
            } else {
                salaryMonthSelector.value = currentSalaryMonth;
            }

            salaryMonthSelector.addEventListener("change", async (event) => {
                const nextValue = normalizeMonthValue(event.target.value);
                if (!nextValue) {
                    event.target.value = currentSalaryMonth;
                    return;
                }
                currentSalaryMonth = nextValue;
                try {
                    await refreshMonthData(currentSalaryMonth);
                } catch (error) {
                    console.error("Failed to refresh monthly data", error);
                }
            });
        }

        if (loadingPayMonthSelect) {
            loadingPayMonthSelect.addEventListener("change", () => {
                loadLoadingPayData();
                loadTransportPayData();
            });
        }

        if (loadingPayYearSelect) {
            loadingPayYearSelect.addEventListener("change", () => {
                loadLoadingPayData();
                loadTransportPayData();
            });
        }

        populateLoadingPayFilters();
        loadLoadingPayData();
        loadTransportPayData();

        const todayIso = getTodayIso();
        const todayParts = parseIsoDate(todayIso);
        const fallbackDate = new Date();
        const initialCalendarYear = todayParts?.year ?? fallbackDate.getFullYear();
        const initialCalendarMonth = todayParts?.month ?? fallbackDate.getMonth() + 1;

        const initializeWorkCalendar = async () => {
            try {
                await setWorkCalendarMonth(initialCalendarYear, initialCalendarMonth, {
                    force: true,
                });
            } catch (error) {
                console.error("Failed to initialize work calendar", error);
                showWorkCalendarMessage(
                    "Unable to load the work calendar. Refresh to try again.",
                    "error",
                );
            }
        };

        initializeWorkCalendar();

        if (workCalendarYearSelect) {
            workCalendarYearSelect.addEventListener("change", async (event) => {
                const nextYear = Number.parseInt(event.target.value, 10);
                if (!Number.isFinite(nextYear)) {
                    if (workCalendarState.year) {
                        event.target.value = String(workCalendarState.year);
                    }
                    return;
                }
                const month = workCalendarState.month ?? initialCalendarMonth;
                await setWorkCalendarMonth(nextYear, month);
            });
        }

        if (workCalendarMonthSelect) {
            workCalendarMonthSelect.addEventListener("change", async (event) => {
                const nextMonth = Number.parseInt(event.target.value, 10);
                if (!Number.isFinite(nextMonth) || nextMonth < 1 || nextMonth > 12) {
                    if (workCalendarState.month) {
                        event.target.value = String(workCalendarState.month);
                    }
                    return;
                }
                const year = workCalendarState.year ?? initialCalendarYear;
                await setWorkCalendarMonth(year, nextMonth);
            });
        }

        if (workdayStatusWork) {
            workdayStatusWork.addEventListener("change", () => {
                if (workdayStatusWork.checked) {
                    updateHolidayInputState(false);
                }
            });
        }

        if (workdayStatusOff) {
            workdayStatusOff.addEventListener("change", () => {
                if (workdayStatusOff.checked) {
                    updateHolidayInputState(true);
                    if (workdayHolidayInput) {
                        workdayHolidayInput.focus();
                    }
                }
            });
        }

        const sanitizeText = (value, fallback = "—") => {
            if (typeof value === "string") {
                const trimmed = value.trim();
                return trimmed || fallback;
            }

            if (value == null) {
                return fallback;
            }

            const stringValue = String(value).trim();
            return stringValue || fallback;
        };

        const BANK_DETAIL_FIELDS = [
            "bankAccountName",
            "bankName",
            "branchName",
            "bankAccountNumber",
        ];

        const getBankDetailValues = (source = {}) => {
            const values = {};
            BANK_DETAIL_FIELDS.forEach((field) => {
                const value = source?.[field];
                if (typeof value === "string") {
                    values[field] = value.trim();
                } else if (value == null) {
                    values[field] = "";
                } else {
                    values[field] = String(value).trim();
                }
            });
            return values;
        };

        const getMemberBankDetails = (member) =>
            getBankDetailValues({
                bankAccountName: member?.bankAccountName ?? member?.bank_account_name,
                bankName: member?.bankName ?? member?.bank_name,
                branchName: member?.branchName ?? member?.branch_name,
                bankAccountNumber: member?.bankAccountNumber ?? member?.bank_account_number,
            });

        const hasBankDetail = (detail) => {
            if (!detail) {
                return false;
            }
            return BANK_DETAIL_FIELDS.some((field) => {
                const value = detail[field];
                return typeof value === "string" && value.trim();
            });
        };

        const getHiddenBankDetailValues = () =>
            getBankDetailValues({
                bankAccountName: bankAccountNameHidden?.value ?? "",
                bankName: bankNameHidden?.value ?? "",
                branchName: branchNameHidden?.value ?? "",
                bankAccountNumber: bankAccountNumberHidden?.value ?? "",
            });

        const formatBankDetailSummary = (values) => {
            const parts = [];
            const namePart = values.bankAccountName?.trim();
            if (namePart) {
                parts.push(namePart);
            }
            const bankParts = [values.bankName, values.branchName]
                .map((part) => (typeof part === "string" ? part.trim() : ""))
                .filter(Boolean);
            if (bankParts.length) {
                parts.push(bankParts.join(" – "));
            }
            const numberPart = values.bankAccountNumber?.trim();
            if (numberPart) {
                parts.push(`Acc: ${numberPart}`);
            }
            return parts.join(" • ") || "";
        };

        const updateBankDetailSummary = () => {
            if (!bankDetailSummary) {
                return;
            }
            const values = getHiddenBankDetailValues();
            if (hasBankDetail(values)) {
                bankDetailSummary.textContent = formatBankDetailSummary(values);
                bankDetailSummary.classList.remove("team-form__bank-summary--empty");
            } else {
                bankDetailSummary.textContent = "No personal detail added yet.";
                bankDetailSummary.classList.add("team-form__bank-summary--empty");
            }
        };

        const setHiddenBankDetailValues = (values = {}) => {
            const resolved = getBankDetailValues(values);
            if (bankAccountNameHidden) {
                bankAccountNameHidden.value = resolved.bankAccountName;
            }
            if (bankNameHidden) {
                bankNameHidden.value = resolved.bankName;
            }
            if (branchNameHidden) {
                branchNameHidden.value = resolved.branchName;
            }
            if (bankAccountNumberHidden) {
                bankAccountNumberHidden.value = resolved.bankAccountNumber;
            }
            updateBankDetailSummary();
        };

        updateBankDetailSummary();

        const resolveImageUrl = (value) => {
            if (typeof value !== "string") {
                return "";
            }

            const trimmed = value.trim();
            if (!trimmed) {
                return "";
            }

            if (/^https?:\/\//i.test(trimmed)) {
                try {
                    const parsed = new URL(trimmed);
                    if (parsed.hostname === "github.com") {
                        const segments = parsed.pathname.split("/").filter(Boolean);
                        const pivotIndex = segments.findIndex((segment) =>
                            ["blob", "raw"].includes(segment.toLowerCase())
                        );
                        if (pivotIndex !== -1 && pivotIndex + 1 < segments.length) {
                            const rawSegments = [
                                ...segments.slice(0, pivotIndex),
                                ...segments.slice(pivotIndex + 1),
                            ];
                            return `https://raw.githubusercontent.com/${rawSegments.join("/")}`;
                        }
                    }

                    return parsed.toString();
                } catch (_error) {
                    return trimmed;
                }
            }

            return trimmed;
        };

        const formatJoinDate = (value) => {
            if (!value) {
                return "—";
            }

            try {
                const parsed = new Date(value);
                if (Number.isNaN(parsed.getTime())) {
                    return sanitizeText(value);
                }

                return parsed.toLocaleDateString(undefined, {
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                });
            } catch (error) {
                console.warn("Unable to format join date", error);
                return sanitizeText(value);
            }
        };

        const formatDateTime = (value) => {
            if (!value) {
                return "—";
            }

            try {
                const parsed = new Date(value);
                if (Number.isNaN(parsed.getTime())) {
                    return sanitizeText(value);
                }

                return parsed.toLocaleString(undefined, {
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                    hour: "2-digit",
                    minute: "2-digit",
                });
            } catch (error) {
                console.warn("Unable to format date/time", error);
                return sanitizeText(value);
            }
        };

        const renderEmptyState = (message) => {
            if (!emptyState) {
                return;
            }

            if (typeof message === "string") {
                emptyState.textContent = message;
            }

            emptyState.hidden = false;
        };

        const hideEmptyState = () => {
            if (emptyState) {
                emptyState.hidden = true;
            }
        };

        const createCell = (label, value) => {
            const cell = document.createElement("td");
            cell.setAttribute("data-label", label);

            if (value instanceof Node) {
                cell.appendChild(value);
            } else {
                cell.textContent = value;
            }

            return cell;
        };

        const createAvatarElement = (member) => {
            const wrapper = document.createElement("div");
            wrapper.className = "team-table__avatar";

            const displayName = getMemberDisplayName(member);
            const imageUrl = resolveImageUrl(
                typeof member?.image === "string" ? member.image : ""
            );

            const setPlaceholder = () => {
                wrapper.innerHTML = "";
                wrapper.setAttribute("role", "img");
                wrapper.setAttribute(
                    "aria-label",
                    `${displayName} profile placeholder`
                );

                const placeholder = document.createElement("div");
                placeholder.className = "team-table__avatar-placeholder";
                const [firstChar] = Array.from(displayName);
                placeholder.textContent = firstChar
                    ? firstChar.toUpperCase()
                    : "?";
                placeholder.setAttribute("aria-hidden", "true");
                wrapper.appendChild(placeholder);
            };

            if (imageUrl) {
                const img = document.createElement("img");
                img.src = imageUrl;
                img.alt = `${displayName} profile photo`;
                img.loading = "lazy";
                img.decoding = "async";
                img.referrerPolicy = "no-referrer";
                img.addEventListener("error", () => {
                    setPlaceholder();
                });
                wrapper.appendChild(img);
            } else {
                setPlaceholder();
            }

            wrapper.title = `${displayName}'s profile`;

            return wrapper;
        };

        const createPersonalDetailCell = (member) => {
            const container = document.createElement("div");
            container.className = "team-table__personal-detail";

            const detailValues = getMemberBankDetails(member);
            const hasDetail = hasBankDetail(detailValues);

            const actionButton = document.createElement("button");
            actionButton.type = "button";
            actionButton.className =
                "button button--secondary button--small team-table__personal-detail-button";
            actionButton.textContent = hasDetail ? "View" : "Add";
            actionButton.setAttribute(
                "aria-label",
                `${hasDetail ? "View" : "Add"} personal detail for ${getMemberDisplayName(member)}`
            );
            actionButton.addEventListener("click", () => {
                openBankDetailModalForMember(member);
            });
            container.appendChild(actionButton);

            const personalDetailText =
                typeof member?.personalDetail === "string"
                    ? member.personalDetail.trim()
                    : "";
            if (personalDetailText) {
                const note = document.createElement("div");
                note.className = "team-table__personal-detail-note";
                note.textContent = personalDetailText;
                container.appendChild(note);
            }

            return container;
        };

        const getAttendanceRecord = (month, memberKey) => {
            if (!month || !memberKey) {
                return null;
            }
            return attendanceDataStore[month]?.[memberKey] || null;
        };

        const setAttendanceRecord = (month, memberKey, record) => {
            if (!month || !memberKey) {
                return;
            }
            if (!attendanceDataStore[month]) {
                attendanceDataStore[month] = {};
            }
            attendanceDataStore[month][memberKey] = record;
        };

        const removeAttendanceRecord = (month, memberKey) => {
            if (!month || !memberKey || !attendanceDataStore[month]) {
                return;
            }
            delete attendanceDataStore[month][memberKey];
            if (Object.keys(attendanceDataStore[month]).length === 0) {
                delete attendanceDataStore[month];
            }
        };

        const getSalaryRecord = (month, memberKey) => {
            if (!month || !memberKey) {
                return null;
            }
            return salaryDataStore[month]?.[memberKey] || null;
        };

        const getCasualOtRate = (month, memberKey) => {
            if (!month || !memberKey) {
                return "";
            }
            return casualOtRateStore[month]?.[memberKey] ?? "";
        };

        const setCasualOtRate = (month, memberKey, value) => {
            if (!month || !memberKey) {
                return;
            }

            let normalizedValue = "";
            if (typeof value === "string") {
                normalizedValue = value.trim();
            } else if (typeof value === "number" && Number.isFinite(value)) {
                normalizedValue = String(value);
            }

            if (!normalizedValue) {
                removeCasualOtRate(month, memberKey);
                return;
            }

            if (!casualOtRateStore[month]) {
                casualOtRateStore[month] = {};
            }

            casualOtRateStore[month][memberKey] = normalizedValue;
        };

        const removeCasualOtRate = (month, memberKey) => {
            if (!month || !memberKey || !casualOtRateStore[month]) {
                return;
            }
            delete casualOtRateStore[month][memberKey];
            if (Object.keys(casualOtRateStore[month]).length === 0) {
                delete casualOtRateStore[month];
            }
        };

        const setSalaryRecord = (month, memberKey, record) => {
            const normalizedMonth = normalizeMonthValue(month) || month;
            if (!normalizedMonth || !memberKey) {
                return;
            }

            if (!salaryDataStore[normalizedMonth]) {
                salaryDataStore[normalizedMonth] = {};
            }

            salaryDataStore[normalizedMonth][memberKey] = record;

            if (record && typeof record === "object" && record.casualOtRate != null) {
                setCasualOtRate(normalizedMonth, memberKey, record.casualOtRate);
            } else {
                removeCasualOtRate(normalizedMonth, memberKey);
            }
        };

        const removeSalaryRecord = (month, memberKey) => {
            const normalizedMonth = normalizeMonthValue(month) || month;
            if (!normalizedMonth || !memberKey || !salaryDataStore[normalizedMonth]) {
                return;
            }
            delete salaryDataStore[normalizedMonth][memberKey];
            if (Object.keys(salaryDataStore[normalizedMonth]).length === 0) {
                delete salaryDataStore[normalizedMonth];
            }
            removeCasualOtRate(normalizedMonth, memberKey);
        };

        const computeCasualTotalDaySalaryAmount = (
            month,
            memberKey,
            member,
            options = {},
        ) => {
            if (!isCasualPayCategory(member)) {
                return null;
            }

            const normalizedMonth = normalizeMonthValue(month) || month;
            if (!normalizedMonth || !memberKey) {
                return null;
            }

            let daySalaryValue = null;
            if (Object.prototype.hasOwnProperty.call(options, "daySalaryOverride")) {
                daySalaryValue = parseNumericAmount(options.daySalaryOverride);
            }

            if (!Number.isFinite(daySalaryValue) || daySalaryValue < 0) {
                const recordSources = [];
                if (options.record && typeof options.record === "object") {
                    recordSources.push(options.record);
                }

                const storedRecord = getSalaryRecord(normalizedMonth, memberKey);
                if (storedRecord && typeof storedRecord === "object") {
                    recordSources.push(storedRecord);
                }

                for (const source of recordSources) {
                    if (!source || typeof source !== "object") {
                        continue;
                    }
                    if (!Object.prototype.hasOwnProperty.call(source, "daySalary")) {
                        continue;
                    }
                    const parsed = parseNumericAmount(source.daySalary);
                    if (Number.isFinite(parsed) && parsed >= 0) {
                        daySalaryValue = parsed;
                        break;
                    }
                }
            }

            if (!Number.isFinite(daySalaryValue) || daySalaryValue < 0) {
                return null;
            }

            let workDays = null;
            const summary = getAttendanceLeaveSummaryRecord(normalizedMonth, memberKey);
            if (summary && Number.isFinite(summary.workDays)) {
                workDays = summary.workDays;
            } else {
                const attendanceRecord = getAttendanceRecord(normalizedMonth, memberKey);
                if (attendanceRecord && typeof attendanceRecord === "object") {
                    let count = 0;
                    Object.entries(attendanceRecord).forEach(([iso, entry]) => {
                        if (typeof iso !== "string" || !iso.startsWith(normalizedMonth)) {
                            return;
                        }
                        if (!entry || typeof entry !== "object") {
                            return;
                        }

                        if (isWorkDayStatus(entry.dayStatus)) {
                            count += 1;
                            return;
                        }

                        const onValue =
                            typeof entry.onTime === "string" ? entry.onTime : "";
                        const offValue =
                            typeof entry.offTime === "string" ? entry.offTime : "";
                        const payMinutes = computePayMinutes(onValue, offValue);
                        if (Number.isFinite(payMinutes) && payMinutes > 0) {
                            count += 1;
                        }
                    });
                    workDays = count;
                }
            }

            if (!Number.isFinite(workDays) || workDays < 0) {
                return null;
            }

            return daySalaryValue * workDays;
        };

        const parseNumericValue = (value) => {
            if (typeof value === "number" && Number.isFinite(value)) {
                return value;
            }
            if (typeof value === "string") {
                const normalized = value.replace(/,/g, "").trim();
                if (!normalized) {
                    return 0;
                }
                const parsed = Number.parseFloat(normalized);
                if (Number.isFinite(parsed)) {
                    return parsed;
                }
            }
            return 0;
        };

        const roundCurrencyValue = (value) => {
            if (!Number.isFinite(value)) {
                return 0;
            }
            const rounded = Math.round((value + Number.EPSILON) * 100) / 100;
            return Math.abs(rounded) < 0.005 ? 0 : rounded;
        };

        const computeOvertimeMinutesForEntry = (iso, entry, member) => {
            if (!iso || !entry || typeof entry !== "object") {
                return 0;
            }

            const onValue = typeof entry.onTime === "string" ? entry.onTime : "";
            const offValue = typeof entry.offTime === "string" ? entry.offTime : "";

            if (!onValue && !offValue) {
                return 0;
            }

            const payMinutes = computePayMinutes(onValue, offValue);
            if (!Number.isFinite(payMinutes)) {
                return 0;
            }

            const { overtimeMinutes } = computeRegularAndOvertimeMinutes(
                iso,
                onValue,
                offValue,
                payMinutes,
                getMemberPayCategory(member),
            );

            return Number.isFinite(overtimeMinutes) ? overtimeMinutes : 0;
        };

        const getMonthlyOvertimeMinutes = (month, memberKey, member) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized || !memberKey) {
                return 0;
            }

            const record = getAttendanceRecord(normalized, memberKey);
            if (!record || typeof record !== "object") {
                return 0;
            }

            let total = 0;
            Object.entries(record).forEach(([iso, entry]) => {
                if (typeof iso !== "string" || !iso.startsWith(normalized)) {
                    return;
                }
                const minutes = computeOvertimeMinutesForEntry(iso, entry, member);
                if (Number.isFinite(minutes)) {
                    total += minutes;
                }
            });

            return total;
        };

        const getComputedOvertimeAmount = (month, memberKey, member, overrides = {}) => {
            const normalized = normalizeMonthValue(month);
            if (!normalized || !memberKey) {
                return 0;
            }

            const totalMinutes = getMonthlyOvertimeMinutes(normalized, memberKey, member);
            if (!Number.isFinite(totalMinutes) || totalMinutes <= 0) {
                return 0;
            }

            const totalHours = totalMinutes / 60;
            if (!Number.isFinite(totalHours) || totalHours <= 0) {
                return 0;
            }

            const salaryRecord = getSalaryRecord(normalized, memberKey) || {};
            const payCategory = getMemberPayCategory(member).toLowerCase();
            if (payCategory === "factory") {
                const overrideBasicSalary =
                    overrides && Object.prototype.hasOwnProperty.call(overrides, "basicSalary")
                        ? overrides.basicSalary
                        : salaryRecord?.basicSalary;
                const basicSalary = parseNumericValue(overrideBasicSalary);
                if (!Number.isFinite(basicSalary) || basicSalary <= 0) {
                    return 0;
                }
                return roundCurrencyValue((basicSalary / 200) * 1.5 * totalHours);
            }

            if (payCategory === "casual") {
                if (
                    overrides &&
                    Object.prototype.hasOwnProperty.call(overrides, "casualOtRate")
                ) {
                    const overrideRate = parseNumericValue(overrides.casualOtRate);
                    if (!Number.isFinite(overrideRate) || overrideRate <= 0) {
                        return 0;
                    }
                    return roundCurrencyValue(overrideRate * totalHours);
                }

                let casualRate = parseNumericValue(
                    getCasualOtRate(normalized, memberKey),
                );

                if (!Number.isFinite(casualRate) || casualRate <= 0) {
                    casualRate = parseNumericValue(salaryRecord?.casualOtRate);
                }

                if (!Number.isFinite(casualRate) || casualRate <= 0) {
                    return 0;
                }

                return roundCurrencyValue(casualRate * totalHours);
            }

            return 0;
        };

        const updateAttendanceSummary = (member) => {
            if (attendanceFormMemberName) {
                attendanceFormMemberName.textContent = getMemberDisplayName(member);
            }
            if (attendanceFormRegno) {
                attendanceFormRegno.textContent = sanitizeText(member?.regNumber);
            }
            if (attendanceSummaryMonth) {
                attendanceSummaryMonth.textContent = formatAttendanceMonthLabel(
                    currentSalaryMonth
                );
            }
        };

        const renderAttendanceTableRows = () => {
            if (!attendanceTableBody) {
                return;
            }

            attendanceTableBody.innerHTML = "";
            resetAttendanceTotals();

            const memberKey = attendanceModalContext?.memberKey;
            if (!memberKey) {
                return;
            }

            const entries = getMonthDateEntries(currentSalaryMonth);
            const record = getAttendanceRecord(currentSalaryMonth, memberKey) || {};

            if (entries.length === 0) {
                const row = document.createElement("tr");
                const cell = document.createElement("td");
                cell.colSpan = 7;
                cell.textContent = "No calendar days available for the selected month.";
                row.appendChild(cell);
                attendanceTableBody.appendChild(row);
                resetAttendanceTotals();
                return;
            }

            entries.forEach(({ iso, display }) => {
                const row = document.createElement("tr");
                row.dataset.date = iso;

                row.appendChild(createCell("Date", display));

                const onInput = document.createElement("input");
                onInput.type = "text";
                onInput.name = `on-${iso}`;
                onInput.className = "attendance-table__time-input edit-form__input";
                onInput.placeholder = "HH:MM";
                onInput.pattern = "^(?:[01]?\\d|2[0-3]):[0-5]\\d$";
                onInput.inputMode = "numeric";
                onInput.autocomplete = "off";
                onInput.spellcheck = false;
                onInput.maxLength = 5;
                onInput.setAttribute(
                    "aria-label",
                    `On time for ${display} (24-hour format)`
                );
                const normalizedOnTime = normalizeTimeValue(record?.[iso]?.onTime ?? "");
                if (normalizedOnTime) {
                    onInput.value = normalizedOnTime;
                }

                const offInput = document.createElement("input");
                offInput.type = "text";
                offInput.name = `off-${iso}`;
                offInput.className = "attendance-table__time-input edit-form__input";
                offInput.placeholder = "HH:MM";
                offInput.pattern = "^(?:[01]?\\d|2[0-3]):[0-5]\\d$";
                offInput.inputMode = "numeric";
                offInput.autocomplete = "off";
                offInput.spellcheck = false;
                offInput.maxLength = 5;
                offInput.setAttribute(
                    "aria-label",
                    `Off time for ${display} (24-hour format)`
                );
                const normalizedOffTime = normalizeTimeValue(record?.[iso]?.offTime ?? "");
                if (normalizedOffTime) {
                    offInput.value = normalizedOffTime;
                }

                const actualValue = document.createElement("span");
                actualValue.className = "attendance-table__hours-value";
                actualValue.textContent = "—";

                const payValue = document.createElement("span");
                payValue.className = "attendance-table__hours-value";
                payValue.textContent = "—";

                const overtimeValue = document.createElement("span");
                overtimeValue.className = "attendance-table__hours-value";
                overtimeValue.textContent = "—";

                row.appendChild(createCell("On time", onInput));
                row.appendChild(createCell("Off time", offInput));

                const actualCell = createCell("Actual hours", actualValue);
                actualCell.classList.add("attendance-table__hours-cell");
                row.appendChild(actualCell);

                const payCell = createCell("Pay hours", payValue);
                payCell.classList.add("attendance-table__hours-cell");
                row.appendChild(payCell);

                const overtimeCell = createCell("OT hours", overtimeValue);
                overtimeCell.classList.add("attendance-table__hours-cell");
                row.appendChild(overtimeCell);

                const dayStatusSelect = document.createElement("select");
                dayStatusSelect.name = `status-${iso}`;
                dayStatusSelect.className = "attendance-table__status-select edit-form__input";
                dayStatusSelect.setAttribute("aria-label", `Day status for ${display}`);
                ATTENDANCE_DAY_STATUS_OPTIONS.forEach((label) => {
                    const option = document.createElement("option");
                    option.value = label;
                    option.textContent = label;
                    dayStatusSelect.appendChild(option);
                });

                const dayStatusHidden = document.createElement("input");
                dayStatusHidden.type = "hidden";
                dayStatusHidden.name = `status-${iso}`;
                dayStatusHidden.disabled = true;

                const savedDayStatus = normalizeDayStatusValue(record?.[iso]?.dayStatus);
                if (savedDayStatus) {
                    dayStatusSelect.dataset.initialValue = savedDayStatus;
                    dayStatusSelect.dataset.userValue = savedDayStatus;
                } else {
                    dayStatusSelect.dataset.initialValue = "";
                }
                setDayStatusValue(dayStatusSelect, dayStatusHidden, savedDayStatus);

                dayStatusSelect.addEventListener("change", () => {
                    const normalized = normalizeDayStatusValue(dayStatusSelect.value);
                    if (normalized) {
                        dayStatusSelect.dataset.userValue = normalized;
                    } else {
                        delete dayStatusSelect.dataset.userValue;
                    }
                    setDayStatusValue(dayStatusSelect, dayStatusHidden, normalized);
                });

                const statusContainer = document.createElement("div");
                statusContainer.className = "attendance-table__status";
                statusContainer.appendChild(dayStatusSelect);
                statusContainer.appendChild(dayStatusHidden);
                row.appendChild(createCell("Day Status", statusContainer));

                const refreshHours = () => {
                    updateAttendanceHoursDisplay(
                        row,
                        iso,
                        onInput,
                        offInput,
                        actualValue,
                        payValue,
                        overtimeValue,
                        {
                            dayStatus: {
                                select: dayStatusSelect,
                                hiddenInput: dayStatusHidden,
                            },
                        },
                    );
                };

                onInput.addEventListener("input", refreshHours);
                offInput.addEventListener("input", refreshHours);

                refreshHours();

                attendanceTableBody.appendChild(row);
            });

            updateAttendanceLeaveSummaryDisplay();
        };

        const refreshAttendanceModalContents = () => {
            if (!attendanceModal || attendanceModal.hasAttribute("hidden")) {
                return;
            }

            if (!attendanceModalContext?.member) {
                return;
            }

            updateAttendanceSummary(attendanceModalContext.member);
            renderAttendanceTableRows();
            loadAttendanceLeaveSummaryForModal();
        };

        const closeAttendanceModal = () => {
            if (!attendanceModal) {
                return;
            }

            attendanceModal.classList.remove("modal--open");
            attendanceModal.setAttribute("hidden", "");
            attendanceModal.setAttribute("aria-hidden", "true");
            document.body.classList.remove("modal-open");
            if (attendanceForm) {
                attendanceForm.reset();
            }
            if (attendanceTableBody) {
                attendanceTableBody.innerHTML = "";
                resetAttendanceTotals();
            }
            resetAttendanceLeaveSummaryDisplay();
            if (attendanceFormMemberName) {
                attendanceFormMemberName.textContent = "—";
            }
            if (attendanceFormRegno) {
                attendanceFormRegno.textContent = "—";
            }
            if (attendanceSummaryMonth) {
                attendanceSummaryMonth.textContent = "—";
            }
            attendanceModalContext = null;
            if (attendanceModal?.dataset) {
                delete attendanceModal.dataset.memberKey;
            }
        };

        const openAttendanceModal = (member, providedKey) => {
            if (!attendanceModal || !attendanceForm) {
                return;
            }

            if (salaryModal && !salaryModal.hasAttribute("hidden")) {
                closeSalaryModal();
            }

            const memberKey = providedKey ?? computeMemberKey(member);
            if (!memberKey) {
                return;
            }

            const memberId = parseMemberId(member?.id);
            attendanceModalContext = { member, memberKey, memberId };
            attendanceModal.removeAttribute("hidden");
            attendanceModal.setAttribute("aria-hidden", "false");
            attendanceModal.classList.add("modal--open");
            attendanceModal.dataset.memberKey = memberKey;
            document.body.classList.add("modal-open");

            attendanceForm.reset();
            resetAttendanceLeaveSummaryDisplay();
            updateAttendanceSummary(member);
            renderAttendanceTableRows();
            loadAttendanceLeaveSummaryForModal();

            window.requestAnimationFrame(() => {
                const firstField = attendanceTableBody?.querySelector(
                    ".attendance-table__time-input"
                );
                if (firstField) {
                    firstField.focus();
                }
            });
        };

        const renderSalarySheet = () => {
            if (!salaryTableBody) {
                return;
            }

            salaryTableBody.innerHTML = "";

            if (salarySummaryContainer) {
                salarySummaryContainer.hidden = true;
            }

            if (!Array.isArray(activeMembers) || activeMembers.length === 0) {
                if (salaryEmptyState) {
                    salaryEmptyState.hidden = false;
                }
                return;
            }

            if (salaryEmptyState) {
                salaryEmptyState.hidden = true;
            }

            const monthStore = salaryDataStore[currentSalaryMonth] || {};
            let factoryGrossTotal = 0;
            let casualGrossTotal = 0;
            let hasFactoryMembers = false;
            let hasCasualMembers = false;

            activeMembers.forEach((member, index) => {
                const normalizedPayCategory = getMemberPayCategory(member)
                    .trim()
                    .toLowerCase();
                const isFactoryCategory =
                    normalizedPayCategory === "factory" ||
                    normalizedPayCategory === "production";

                if (isFactoryCategory) {
                    hasFactoryMembers = true;
                } else if (normalizedPayCategory === "casual") {
                    hasCasualMembers = true;
                }

                const memberKey = computeMemberKey(member, index);
                const record = memberKey ? monthStore[memberKey] || {} : {};
                const isFactoryMember = isFactoryPayCategory(member);
                const computedAllowance = isFactoryMember
                    ? getComputedAttendanceAllowance(currentSalaryMonth, memberKey)
                    : null;
                const computedTargetAllowance = isFactoryMember
                    ? getComputedTargetAllowance(currentSalaryMonth, memberKey)
                    : null;
                let displayRecord = record;

                if (isFactoryMember) {
                    if (computedAllowance != null) {
                        displayRecord = {
                            ...record,
                            attendanceAllowance: computedAllowance,
                        };
                    }
                    if (computedTargetAllowance != null) {
                        if (displayRecord && typeof displayRecord === "object") {
                            displayRecord = {
                                ...displayRecord,
                                targetAllowance: computedTargetAllowance,
                            };
                        } else {
                            displayRecord = { targetAllowance: computedTargetAllowance };
                        }
                    }
                } else if (record?.attendanceAllowance != null) {
                    displayRecord = {
                        ...record,
                        attendanceAllowance: null,
                    };
                    if (record?.targetAllowance != null) {
                        displayRecord.targetAllowance = null;
                    }
                } else if (record?.targetAllowance != null) {
                    displayRecord = {
                        ...record,
                        targetAllowance: null,
                    };
                }

                const computedOvertimeAmount = getComputedOvertimeAmount(
                    currentSalaryMonth,
                    memberKey,
                    member,
                );
                if (Number.isFinite(computedOvertimeAmount)) {
                    const formattedOvertime = formatNumberForInput(computedOvertimeAmount);
                    if (displayRecord && typeof displayRecord === "object") {
                        displayRecord = {
                            ...displayRecord,
                            overtime: formattedOvertime,
                        };
                    } else {
                        displayRecord = { overtime: formattedOvertime };
                    }
                }
                const combinedRecord =
                    record && typeof record === "object" ? { ...record } : {};

                if (displayRecord && typeof displayRecord === "object") {
                    Object.assign(combinedRecord, displayRecord);
                }

                const totalDeductionAmount =
                    computeTotalDeductionAmountFromComponents(combinedRecord);
                combinedRecord.totalDeduction = formatNumberForInput(totalDeductionAmount);

                const netPayAmount = computeNetPayAmountFromComponents(
                    combinedRecord,
                    totalDeductionAmount,
                );
                if (Number.isFinite(netPayAmount)) {
                    combinedRecord.netPay = formatNumberForInput(netPayAmount);
                }

                const grossSalaryAmount = parseNumericAmount(
                    combinedRecord?.grossSalary,
                );
                if (Number.isFinite(grossSalaryAmount)) {
                    if (isFactoryCategory) {
                        factoryGrossTotal += grossSalaryAmount;
                    } else if (normalizedPayCategory === "casual") {
                        casualGrossTotal += grossSalaryAmount;
                    }
                }

                const row = document.createElement("tr");

                row.appendChild(createCell("Reg No", sanitizeText(member?.regNumber)));

                const nameButton = document.createElement("button");
                nameButton.type = "button";
                nameButton.className = "salary-table__name-button";
                nameButton.textContent = getMemberDisplayName(member);
                nameButton.addEventListener("click", () => {
                    if (!canManageSalary) {
                        return;
                    }
                    openSalaryModal(member, memberKey);
                });
                row.appendChild(createCell("Name", nameButton));

                const computedProvidentFundAmount = computeProvidentFundAmount(
                    member,
                    displayRecord &&
                        typeof displayRecord === "object" &&
                        displayRecord.basicSalary != null
                        ? displayRecord.basicSalary
                        : record?.basicSalary,
                );

                if (computedProvidentFundAmount != null) {
                    const formattedProvidentFund = formatNumberForInput(
                        computedProvidentFundAmount,
                    );

                    if (displayRecord && typeof displayRecord === "object") {
                        displayRecord = {
                            ...displayRecord,
                            providentFund: formattedProvidentFund,
                        };
                    } else {
                        displayRecord = { providentFund: formattedProvidentFund };
                    }
                } else if (
                    displayRecord &&
                    typeof displayRecord === "object" &&
                    displayRecord.providentFund != null
                ) {
                    displayRecord = { ...displayRecord, providentFund: null };
                }

                const casualTotalDaySalaryAmount = computeCasualTotalDaySalaryAmount(
                    currentSalaryMonth,
                    memberKey,
                    member,
                    {
                        record:
                            displayRecord && typeof displayRecord === "object"
                                ? displayRecord
                                : record && typeof record === "object"
                                ? record
                                : null,
                    },
                );

                if (Number.isFinite(casualTotalDaySalaryAmount)) {
                    const formattedTotalDaySalary = formatNumberForInput(
                        casualTotalDaySalaryAmount,
                    );

                    if (displayRecord && typeof displayRecord === "object") {
                        displayRecord = {
                            ...displayRecord,
                            production: formattedTotalDaySalary,
                        };
                    } else if (record && typeof record === "object") {
                        displayRecord = {
                            ...record,
                            production: formattedTotalDaySalary,
                        };
                    } else {
                        displayRecord = { production: formattedTotalDaySalary };
                    }
                }

                salaryFieldDefinitions.forEach(({ label, name }) => {
                    row.appendChild(
                        createCell(label, formatSalaryValue(combinedRecord?.[name])),
                    );
                });

                const attendanceButton = document.createElement("button");
                attendanceButton.type = "button";
                attendanceButton.className = "salary-table__action-button";
                attendanceButton.textContent = "Record attendance";
                attendanceButton.addEventListener("click", () => {
                    openAttendanceModal(member, memberKey);
                });
                row.appendChild(createCell("Record Attendance", attendanceButton));

                const salaryButton = document.createElement("button");
                salaryButton.type = "button";
                salaryButton.className = "salary-table__action-button";
                salaryButton.textContent = "Update salary";
                if (canManageSalary) {
                    salaryButton.addEventListener("click", () => {
                        openSalaryModal(member, memberKey);
                    });
                } else {
                    salaryButton.disabled = true;
                    salaryButton.setAttribute("aria-disabled", "true");
                    salaryButton.title = "You do not have permission to update salary details.";
                }
                row.appendChild(createCell("Manage Salary", salaryButton));

                salaryTableBody.appendChild(row);
            });

            if (salarySummaryContainer) {
                const shouldShowSummary = hasFactoryMembers || hasCasualMembers;
                if (!shouldShowSummary) {
                    salarySummaryContainer.hidden = true;
                } else {
                    salarySummaryContainer.hidden = false;

                    if (salarySummaryTotal) {
                        salarySummaryTotal.textContent = numberFormatter.format(
                            factoryGrossTotal + casualGrossTotal,
                        );
                    }
                    if (salarySummaryFactory) {
                        salarySummaryFactory.textContent = numberFormatter.format(
                            factoryGrossTotal,
                        );
                    }
                    if (salarySummaryCasual) {
                        salarySummaryCasual.textContent = numberFormatter.format(
                            casualGrossTotal,
                        );
                    }
                }
            }
        };

        const setActiveMembers = (members) => {
            if (!Array.isArray(members)) {
                activeMembers = [];
                memberKeyById.clear();
                renderSalarySheet();
                return;
            }

            activeMembers = members.filter(
                (member) => normalizeStatus(member?.status) === "Active"
            );

            memberKeyById.clear();
            activeMembers.forEach((member, index) => {
                const key = computeMemberKey(member, index);
                const memberId = parseMemberId(member?.id);
                if (key && memberId != null) {
                    memberKeyById.set(memberId, key);
                }
            });
            renderSalarySheet();
        };

        const populateSalaryFormFields = (record, { memberKey, month, member } = {}) => {
            if (!salaryForm) {
                return;
            }

            const contextMember = member ?? salaryModalContext?.member ?? null;
            const targetMemberKey = memberKey ?? salaryModalContext?.memberKey ?? null;
            const targetMonth =
                normalizeMonthValue(month) ||
                normalizeMonthValue(salaryFormMonth?.value) ||
                normalizeMonthValue(currentSalaryMonth) ||
                currentSalaryMonth;
            const isFactoryMember = isFactoryPayCategory(contextMember);
            const computedAllowance = isFactoryMember
                ? getComputedAttendanceAllowance(targetMonth, targetMemberKey)
                : null;
            const computedTargetAllowance = isFactoryMember
                ? getComputedTargetAllowance(targetMonth, targetMemberKey)
                : null;

            salaryFieldDefinitions.forEach(({ name }) => {
                const input = salaryForm.elements[name];
                if (input) {
                    let value = record?.[name] ?? "";

                    input.readOnly = false;
                    input.removeAttribute("aria-readonly");
                    input.disabled = false;

                    if (name === "attendanceAllowance") {
                        input.disabled = !isFactoryMember;

                        if (!isFactoryMember) {
                            input.value = "";
                            return;
                        }

                        if (computedAllowance != null) {
                            value = formatNumberForInput(computedAllowance);
                        }
                    } else if (name === "production") {
                        if (isCasualPayCategory(contextMember)) {
                            input.readOnly = true;
                            input.setAttribute("aria-readonly", "true");

                            const computedCasualTotal = computeCasualTotalDaySalaryAmount(
                                targetMonth,
                                targetMemberKey,
                                contextMember,
                                { record },
                            );

                            if (Number.isFinite(computedCasualTotal)) {
                                value = formatNumberForInput(computedCasualTotal);
                            }
                        }
                    } else if (name === "targetAllowance") {
                        input.disabled = !isFactoryMember;

                        if (!isFactoryMember) {
                            input.value = "";
                            return;
                        }

                        if (computedTargetAllowance != null) {
                            value = formatNumberForInput(computedTargetAllowance);
                        }
                    } else if (name === "overtime") {
                        input.disabled = false;
                        input.readOnly = true;
                        input.setAttribute("aria-readonly", "true");

                        const overtimeAmount = getComputedOvertimeAmount(
                            targetMonth,
                            targetMemberKey,
                            contextMember,
                            record || {},
                        );
                        if (Number.isFinite(overtimeAmount)) {
                            value = formatNumberForInput(overtimeAmount);
                        } else {
                            value = "";
                        }
                    } else if (name === "providentFund") {
                        input.readOnly = true;
                        input.setAttribute("aria-readonly", "true");

                        const computedAmount = computeProvidentFundAmount(
                            contextMember,
                            record?.basicSalary ??
                                salaryForm.elements?.basicSalary?.value ??
                                value,
                        );

                        if (computedAmount == null) {
                            input.value = "";
                            return;
                        }

                        value = formatNumberForInput(computedAmount);
                    }

                    input.value = value ?? "";
                }
            });

            const casualOtRateInput = salaryForm.elements?.casualOtRate;
            if (casualOtRateInput) {
                let storedCasualOtRate = getCasualOtRate(targetMonth, targetMemberKey);
                if (!storedCasualOtRate && record?.casualOtRate != null) {
                    setCasualOtRate(targetMonth, targetMemberKey, record.casualOtRate);
                    storedCasualOtRate = getCasualOtRate(targetMonth, targetMemberKey);
                }

                if (!storedCasualOtRate) {
                    removeCasualOtRate(targetMonth, targetMemberKey);
                }

                casualOtRateInput.value = storedCasualOtRate;
            }

            refreshSalaryFormOvertime();
            refreshSalaryFormProvidentFund({ basicSalary: record?.basicSalary });
            refreshSalaryFormTotals();
        };

        const refreshSalaryFormOvertime = () => {
            if (!salaryForm) {
                return;
            }

            const overtimeInput = salaryForm.elements?.overtime;
            if (!overtimeInput) {
                return;
            }

            const member = salaryModalContext?.member ?? null;
            const memberKey = salaryModalContext?.memberKey ?? null;
            const normalizedMonth =
                normalizeMonthValue(salaryFormMonth?.value) ||
                normalizeMonthValue(currentSalaryMonth) ||
                currentSalaryMonth;

            const overrides = {};
            const basicSalaryInput = salaryForm.elements?.basicSalary;
            if (basicSalaryInput && typeof basicSalaryInput.value === "string") {
                overrides.basicSalary = basicSalaryInput.value;
            }

            const casualOtRateInput = salaryForm.elements?.casualOtRate;
            if (casualOtRateInput && typeof casualOtRateInput.value === "string") {
                overrides.casualOtRate = casualOtRateInput.value;
            }

            const amount = getComputedOvertimeAmount(
                normalizedMonth,
                memberKey,
                member,
                overrides,
            );

            overtimeInput.value = Number.isFinite(amount)
                ? formatNumberForInput(amount)
                : "";
        };

        const refreshSalaryFormProvidentFund = (overrides = {}) => {
            if (!salaryForm) {
                return;
            }

            const providentFundInput = salaryForm.elements?.providentFund;
            if (!providentFundInput) {
                return;
            }

            providentFundInput.readOnly = true;
            providentFundInput.setAttribute("aria-readonly", "true");

            const member = salaryModalContext?.member ?? null;
            const basicOverride = overrides?.basicSalary;
            const basicValue =
                basicOverride != null
                    ? basicOverride
                    : salaryForm.elements?.basicSalary?.value;

            const amount = computeProvidentFundAmount(member, basicValue);

            if (amount == null) {
                providentFundInput.value = "";
                refreshSalaryFormTotals();
                return;
            }

            providentFundInput.value = formatNumberForInput(amount);
            refreshSalaryFormTotals();
        };

        const refreshSalaryFormCasualTotalDaySalary = (overrides = {}) => {
            if (!salaryForm) {
                return;
            }

            const productionInput = salaryForm.elements?.production;
            if (!productionInput) {
                return;
            }

            const member = salaryModalContext?.member ?? null;
            if (!isCasualPayCategory(member)) {
                return;
            }

            const memberKey = salaryModalContext?.memberKey ?? null;
            if (!memberKey) {
                return;
            }

            const normalizedMonth =
                normalizeMonthValue(salaryFormMonth?.value) ||
                normalizeMonthValue(currentSalaryMonth) ||
                currentSalaryMonth;

            if (!normalizedMonth) {
                productionInput.value = "";
                return;
            }

            const baseRecord =
                overrides.record && typeof overrides.record === "object"
                    ? overrides.record
                    : getSalaryRecord(normalizedMonth, memberKey) || null;

            const amount = computeCasualTotalDaySalaryAmount(
                normalizedMonth,
                memberKey,
                member,
                {
                    ...overrides,
                    record: baseRecord,
                },
            );

            if (Number.isFinite(amount)) {
                productionInput.value = formatNumberForInput(amount);
            } else if (Object.prototype.hasOwnProperty.call(overrides, "daySalaryOverride")) {
                productionInput.value = "";
            }
        };

        if (salaryForm?.elements?.basicSalary) {
            salaryForm.elements.basicSalary.addEventListener(
                "input",
                (event) => {
                    refreshSalaryFormOvertime();
                    refreshSalaryFormProvidentFund({
                        basicSalary:
                            typeof event?.target?.value === "string"
                                ? event.target.value
                                : undefined,
                    });
                    refreshSalaryFormCasualTotalDaySalary();
                },
            );
        }

        if (salaryForm?.elements?.daySalary) {
            const daySalaryInput = salaryForm.elements.daySalary;
            const updateCasualTotalDaySalary = () => {
                refreshSalaryFormCasualTotalDaySalary({
                    daySalaryOverride:
                        typeof daySalaryInput.value === "string"
                            ? daySalaryInput.value
                            : "",
                });
            };

            daySalaryInput.addEventListener("input", updateCasualTotalDaySalary);
            daySalaryInput.addEventListener("change", updateCasualTotalDaySalary);
        }

        if (salaryForm?.elements?.casualOtRate) {
            const casualOtRateInput = salaryForm.elements.casualOtRate;
            const persistCasualOtRate = () => {
                if (!salaryModalContext?.memberKey) {
                    return;
                }

                const normalizedMonth =
                    normalizeMonthValue(salaryFormMonth?.value) ||
                    normalizeMonthValue(currentSalaryMonth) ||
                    currentSalaryMonth;
                const value =
                    typeof casualOtRateInput.value === "string"
                        ? casualOtRateInput.value
                        : "";

                if (value.trim()) {
                    setCasualOtRate(normalizedMonth, salaryModalContext.memberKey, value);
                } else {
                    removeCasualOtRate(normalizedMonth, salaryModalContext.memberKey);
                }

                refreshSalaryFormOvertime();
            };

            casualOtRateInput.addEventListener("input", persistCasualOtRate);
            casualOtRateInput.addEventListener("change", persistCasualOtRate);
        }

        if (salaryForm) {
            deductionFieldNames.forEach((name) => {
                const field = salaryForm.elements?.[name];
                if (!field) {
                    return;
                }

                field.addEventListener("input", refreshSalaryFormTotals);
                field.addEventListener("change", refreshSalaryFormTotals);
            });

            const grossSalaryInput = salaryForm.elements?.grossSalary;
            if (grossSalaryInput) {
                grossSalaryInput.addEventListener("input", refreshSalaryFormTotals);
                grossSalaryInput.addEventListener("change", refreshSalaryFormTotals);
            }
        }

        const closeSalaryModal = () => {
            if (!salaryModal) {
                return;
            }
            salaryModal.setAttribute("hidden", "");
            salaryModal.setAttribute("aria-hidden", "true");
            salaryModal.classList.remove("modal--open");
            document.body.classList.remove("modal-open");
            if (salaryForm) {
                salaryForm.reset();
            }
            if (salaryFormMonth) {
                salaryFormMonth.value = currentSalaryMonth;
            }
            salaryModalContext = null;
            if (salaryModal?.dataset) {
                delete salaryModal.dataset.memberKey;
            }
        };

        const openSalaryModal = (member, providedKey) => {
            if (!canManageSalary) {
                return;
            }

            if (!salaryModal || !salaryForm) {
                return;
            }

            if (attendanceModal && !attendanceModal.hasAttribute("hidden")) {
                closeAttendanceModal();
            }

            const memberKey = providedKey ?? computeMemberKey(member);
            if (!memberKey) {
                return;
            }

            const memberId = parseMemberId(member?.id);
            salaryModalContext = { member, memberKey, memberId };
            salaryModal.removeAttribute("hidden");
            salaryModal.setAttribute("aria-hidden", "false");
            salaryModal.classList.add("modal--open");
            salaryModal.dataset.memberKey = memberKey;
            document.body.classList.add("modal-open");

            const displayName = getMemberDisplayName(member);
            if (salaryModalTitle) {
                salaryModalTitle.textContent = `Update salary for ${displayName}`;
            }
            if (salaryFormMemberName) {
                salaryFormMemberName.textContent = displayName;
            }
            if (salaryFormRegno) {
                salaryFormRegno.textContent = sanitizeText(member?.regNumber);
            }
            if (salaryFormMonth) {
                salaryFormMonth.value = currentSalaryMonth;
            }

            populateSalaryFormFields(getSalaryRecord(currentSalaryMonth, memberKey), {
                memberKey,
                month: currentSalaryMonth,
                member,
            });

            window.requestAnimationFrame(() => {
                const firstEditableField = salaryForm.querySelector(
                    "input[name='basicSalary']"
                );
                if (firstEditableField) {
                    firstEditableField.focus();
                }
            });
        };

        const setBankDetailFormValues = (values = {}) => {
            const resolved = getBankDetailValues(values);
            Object.entries(bankDetailFieldInputs).forEach(([field, input]) => {
                if (!input) {
                    return;
                }
                input.value = resolved[field];
            });
        };

        const getBankDetailFormValues = () => {
            const values = {};
            Object.entries(bankDetailFieldInputs).forEach(([field, input]) => {
                values[field] = input?.value ?? "";
            });
            return getBankDetailValues(values);
        };

        const resetBankDetailFeedback = () => {
            if (bankDetailError) {
                bankDetailError.hidden = true;
                bankDetailError.textContent = "";
            }
            if (bankDetailSuccess) {
                bankDetailSuccess.hidden = true;
                bankDetailSuccess.textContent = "";
            }
        };

        const showBankDetailError = (message) => {
            if (!bankDetailError) {
                return;
            }
            bankDetailError.textContent = message;
            bankDetailError.hidden = false;
            if (bankDetailSuccess) {
                bankDetailSuccess.hidden = true;
                bankDetailSuccess.textContent = "";
            }
        };

        const showBankDetailSuccess = (message) => {
            if (!bankDetailSuccess) {
                return;
            }
            bankDetailSuccess.textContent = message;
            bankDetailSuccess.hidden = false;
            if (bankDetailError) {
                bankDetailError.hidden = true;
                bankDetailError.textContent = "";
            }
        };

        const setBankDetailHint = (text) => {
            if (!bankDetailHint) {
                return;
            }
            const normalized = typeof text === "string" ? text.trim() : "";
            if (normalized) {
                bankDetailHint.textContent = normalized;
                bankDetailHint.hidden = false;
            } else {
                bankDetailHint.textContent = "";
                bankDetailHint.hidden = true;
            }
        };

        const setBankDetailFieldsDisabled = (disabled) => {
            Object.values(bankDetailFieldInputs).forEach((input) => {
                if (input) {
                    input.disabled = disabled;
                }
            });
        };

        const updateBankDetailControls = () => {
            const contextType = bankDetailModalState?.context?.type;
            const editing =
                contextType === "form" || bankDetailModalState?.editing === true;
            const loading = bankDetailModalState?.loading === true;

            if (bankDetailEditToggle) {
                if (contextType === "member") {
                    bankDetailEditToggle.hidden = false;
                    bankDetailEditToggle.textContent = editing
                        ? "Cancel edit"
                        : "Edit";
                    bankDetailEditToggle.disabled = loading;
                } else {
                    bankDetailEditToggle.hidden = true;
                    bankDetailEditToggle.disabled = false;
                }
            }

            if (bankDetailSaveButton) {
                const disableSave = loading || (contextType === "member" && !editing);
                bankDetailSaveButton.disabled = disableSave;
            }
        };

        const setBankDetailEditing = (editing, { focusField = true } = {}) => {
            if (!bankDetailModalState) {
                return;
            }
            const contextType = bankDetailModalState.context?.type;
            if (contextType === "form") {
                editing = true;
            }

            bankDetailModalState = {
                ...bankDetailModalState,
                editing,
            };

            const disableFields = contextType === "member" ? !editing : false;
            setBankDetailFieldsDisabled(disableFields);

            if (!editing && bankDetailModalState.values) {
                setBankDetailFormValues(bankDetailModalState.values);
            }

            updateBankDetailControls();

            if (editing && focusField) {
                window.requestAnimationFrame(() => {
                    bankDetailAccountNameInput?.focus();
                });
            }
        };

        const setBankDetailLoading = (loading) => {
            if (!bankDetailModalState) {
                return;
            }
            bankDetailModalState = {
                ...bankDetailModalState,
                loading,
            };

            if (loading) {
                setBankDetailFieldsDisabled(true);
            } else {
                const contextType = bankDetailModalState.context?.type;
                const disableFields = contextType === "member" ? !bankDetailModalState.editing : false;
                setBankDetailFieldsDisabled(disableFields);
            }

            updateBankDetailControls();
        };

        const closeBankDetailModal = () => {
            if (!bankDetailModal) {
                return;
            }
            bankDetailModal.classList.remove("modal--open");
            bankDetailModal.setAttribute("hidden", "");
            bankDetailModal.setAttribute("aria-hidden", "true");
            document.body.classList.remove("modal-open");
            if (bankDetailForm) {
                bankDetailForm.reset();
            }
            if (bankDetailModal?.dataset) {
                delete bankDetailModal.dataset.memberId;
            }
            resetBankDetailFeedback();
            setBankDetailHint("");
            bankDetailModalState = null;
        };

        const openBankDetailModalForForm = () => {
            if (!bankDetailModal || !bankDetailForm) {
                return;
            }

            if (attendanceModal && !attendanceModal.hasAttribute("hidden")) {
                closeAttendanceModal();
            }
            if (salaryModal && !salaryModal.hasAttribute("hidden")) {
                closeSalaryModal();
            }

            const values = getHiddenBankDetailValues();
            bankDetailModalState = {
                context: { type: "form" },
                editing: true,
                loading: false,
                values,
            };

            resetBankDetailFeedback();
            setBankDetailHint("These details will be submitted with the team member.");
            setBankDetailFormValues(values);
            setBankDetailFieldsDisabled(false);
            updateBankDetailControls();

            bankDetailModal.removeAttribute("hidden");
            bankDetailModal.setAttribute("aria-hidden", "false");
            bankDetailModal.classList.add("modal--open");
            document.body.classList.add("modal-open");

            window.requestAnimationFrame(() => {
                bankDetailAccountNameInput?.focus();
            });
        };

        const openBankDetailModalForMember = async (member) => {
            if (!bankDetailModal || !bankDetailForm) {
                return;
            }

            const memberId = parseMemberId(member?.id);
            if (memberId == null) {
                return;
            }

            if (attendanceModal && !attendanceModal.hasAttribute("hidden")) {
                closeAttendanceModal();
            }
            if (salaryModal && !salaryModal.hasAttribute("hidden")) {
                closeSalaryModal();
            }

            const displayName = getMemberDisplayName(member);
            bankDetailModalState = {
                context: { type: "member", memberId, member, displayName },
                editing: false,
                loading: true,
                values: getBankDetailValues({}),
            };

            resetBankDetailFeedback();
            setBankDetailHint(`Loading personal detail for ${displayName}…`);
            setBankDetailFormValues({});
            setBankDetailFieldsDisabled(true);
            updateBankDetailControls();

            bankDetailModal.removeAttribute("hidden");
            bankDetailModal.setAttribute("aria-hidden", "false");
            bankDetailModal.classList.add("modal--open");
            document.body.classList.add("modal-open");
            bankDetailModal.dataset.memberId = String(memberId);

            try {
                const response = await fetch(
                    `/api/team/members/${memberId}/personal-detail`,
                    {
                        headers: authHeaders,
                    }
                );

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => null);
                    const message = errorBody?.msg || `Request failed with status ${response.status}`;
                    throw new Error(message);
                }

                const data = await response.json();
                const values = getBankDetailValues(data);
                const hasExisting = hasBankDetail(values);

                bankDetailModalState = {
                    context: { type: "member", memberId, member, displayName },
                    editing: hasExisting ? false : true,
                    loading: false,
                    values,
                };

                setBankDetailFormValues(values);
                setBankDetailHint(
                    hasExisting
                        ? `Viewing personal detail for ${displayName}.`
                        : `Add personal detail for ${displayName}.`
                );
                setBankDetailEditing(bankDetailModalState.editing, { focusField: hasExisting === false });
            } catch (error) {
                console.error("Failed to load personal detail", error);
                bankDetailModalState = {
                    context: { type: "member", memberId, member, displayName },
                    editing: false,
                    loading: false,
                    values: getBankDetailValues({}),
                };
                setBankDetailFormValues({});
                setBankDetailFieldsDisabled(true);
                updateBankDetailControls();
                showBankDetailError(
                    error?.message || "Unable to load personal detail. Please try again."
                );
                setBankDetailHint(`Personal detail is unavailable for ${displayName}.`);
            }
        };


        if (workdayModalClose) {
            workdayModalClose.addEventListener("click", () => {
                closeWorkdayModal();
            });
        }

        if (workdayModalCancel) {
            workdayModalCancel.addEventListener("click", () => {
                closeWorkdayModal();
            });
        }

        if (workdayModal) {
            workdayModal.addEventListener("click", (event) => {
                if (event.target?.dataset?.modalDismiss !== undefined) {
                    closeWorkdayModal();
                }
            });
        }

        if (attendanceModalClose) {
            attendanceModalClose.addEventListener("click", () => {
                closeAttendanceModal();
            });
        }

        if (attendanceModalCancel) {
            attendanceModalCancel.addEventListener("click", () => {
                closeAttendanceModal();
            });
        }

        if (attendanceModal) {
            attendanceModal.addEventListener("click", (event) => {
                if (event.target?.dataset?.modalDismiss !== undefined) {
                    closeAttendanceModal();
                }
            });
        }

        if (salaryModalClose) {
            salaryModalClose.addEventListener("click", () => {
                closeSalaryModal();
            });
        }

        if (salaryModalCancel) {
            salaryModalCancel.addEventListener("click", () => {
                closeSalaryModal();
            });
        }

        if (salaryModal) {
            salaryModal.addEventListener("click", (event) => {
                if (event.target?.dataset?.modalDismiss !== undefined) {
                    closeSalaryModal();
                }
            });
        }

        if (bankDetailModalClose) {
            bankDetailModalClose.addEventListener("click", () => {
                closeBankDetailModal();
            });
        }

        if (bankDetailModalCancel) {
            bankDetailModalCancel.addEventListener("click", () => {
                closeBankDetailModal();
            });
        }

        if (bankDetailModal) {
            bankDetailModal.addEventListener("click", (event) => {
                if (event.target?.dataset?.modalDismiss !== undefined) {
                    closeBankDetailModal();
                }
            });
        }

        if (bankDetailEditToggle) {
            bankDetailEditToggle.addEventListener("click", () => {
                if (!bankDetailModalState || bankDetailModalState.context?.type !== "member") {
                    return;
                }

                const currentlyEditing = bankDetailModalState.editing === true;
                resetBankDetailFeedback();

                if (currentlyEditing) {
                    setBankDetailEditing(false, { focusField: false });
                    const displayName = bankDetailModalState.context?.displayName;
                    if (displayName) {
                        setBankDetailHint(`Viewing personal detail for ${displayName}.`);
                    }
                } else {
                    setBankDetailEditing(true);
                    const displayName = bankDetailModalState.context?.displayName;
                    if (displayName) {
                        setBankDetailHint(`Editing personal detail for ${displayName}.`);
                    }
                }
            });
        }

        document.addEventListener("keydown", (event) => {
            if (event.key !== "Escape") {
                return;
            }

            if (workdayModal && !workdayModal.hasAttribute("hidden")) {
                closeWorkdayModal();
                return;
            }

            if (attendanceModal && !attendanceModal.hasAttribute("hidden")) {
                closeAttendanceModal();
                return;
            }

            if (bankDetailModal && !bankDetailModal.hasAttribute("hidden")) {
                closeBankDetailModal();
                return;
            }

            if (salaryModal && !salaryModal.hasAttribute("hidden")) {
                closeSalaryModal();
            }
        });

        if (workdayForm) {
            workdayForm.addEventListener("submit", async (event) => {
                event.preventDefault();

                if (!workdayModalContext?.iso) {
                    closeWorkdayModal();
                    return;
                }

                const iso = workdayModalContext.iso;
                const isWorkDay = workdayStatusWork?.checked !== false;
                const holidayName =
                    !isWorkDay && workdayHolidayInput
                        ? workdayHolidayInput.value.trim()
                        : "";

                if (workdayFormError) {
                    workdayFormError.hidden = true;
                    workdayFormError.textContent = "";
                }

                if (workdayModalSave) {
                    workdayModalSave.disabled = true;
                }

                try {
                    const response = await fetch(
                        `/api/team/work-calendar/${encodeURIComponent(iso)}`,
                        {
                            method: "PUT",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({
                                isWorkDay,
                                holidayName: isWorkDay ? null : holidayName || null,
                            }),
                        },
                    );

                    let data = null;
                    try {
                        data = await response.json();
                    } catch (_error) {
                        data = null;
                    }

                    if (!response.ok) {
                        const message = data?.msg || "Unable to save the selected day.";
                        if (workdayFormError) {
                            workdayFormError.textContent = message;
                            workdayFormError.hidden = false;
                        } else {
                            window.alert(message);
                        }
                        return;
                    }

                    updateWorkCalendarStoreEntry(iso, data);
                    closeWorkdayModal();
                    renderWorkCalendar();

                    const label = workCalendarDateFormatter.format(createColomboDate(iso));
                    showWorkCalendarMessage(
                        `Saved calendar settings for ${label}.`,
                        "success",
                    );

                    const isoParts = parseIsoDate(iso);
                    if (isoParts) {
                        const normalizedMonth = normalizeMonthValue(
                            getMonthKey(isoParts.year, isoParts.month),
                        );

                        if (normalizedMonth) {
                            try {
                                await updateComputedAttendanceAllowances(normalizedMonth);
                            } catch (error) {
                                console.error(
                                    "Failed to refresh attendance allowance after calendar update",
                                    error,
                                );
                            }

                            if (
                                normalizeMonthValue(currentSalaryMonth) === normalizedMonth
                            ) {
                                renderSalarySheet();

                                if (salaryModalContext?.memberKey) {
                                    populateSalaryFormFields(
                                        getSalaryRecord(
                                            normalizedMonth,
                                            salaryModalContext.memberKey,
                                        ),
                                        {
                                            memberKey: salaryModalContext.memberKey,
                                            month: normalizedMonth,
                                            member: salaryModalContext.member,
                                        },
                                    );
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error("Failed to save work calendar day", error);
                    if (workdayFormError) {
                        workdayFormError.textContent =
                            "Unable to save the selected day. Please try again.";
                        workdayFormError.hidden = false;
                    } else {
                        window.alert(
                            "Unable to save the selected day. Please try again.",
                        );
                    }
                } finally {
                    if (workdayModalSave) {
                        workdayModalSave.disabled = false;
                    }
                }
            });
        }

        if (attendanceForm) {
            attendanceForm.addEventListener("submit", async (event) => {
                event.preventDefault();

                if (!attendanceForm.checkValidity()) {
                    attendanceForm.reportValidity();
                    return;
                }

                if (!attendanceModalContext?.memberKey) {
                    closeAttendanceModal();
                    return;
                }

                const normalizedMonth = normalizeMonthValue(currentSalaryMonth) || currentSalaryMonth;
                if (!normalizedMonth) {
                    window.alert("Select a valid month before saving attendance.");
                    return;
                }

                const formData = new FormData(attendanceForm);
                const entries = getMonthDateEntries(normalizedMonth);
                const record = {};

                entries.forEach(({ iso }) => {
                    const onValueRaw = formData.get(`on-${iso}`);
                    const offValueRaw = formData.get(`off-${iso}`);
                    const statusValueRaw = formData.get(`status-${iso}`);
                    const onValue = normalizeTimeValue(
                        typeof onValueRaw === "string" ? onValueRaw : ""
                    );
                    const offValue = normalizeTimeValue(
                        typeof offValueRaw === "string" ? offValueRaw : ""
                    );
                    const dayStatus = normalizeDayStatusValue(
                        typeof statusValueRaw === "string" ? statusValueRaw : ""
                    );
                    const includeDayStatus =
                        dayStatus &&
                        (dayStatus !== "Work Day" ||
                            onValue ||
                            offValue ||
                            !isWorkCalendarDateWorkDay(iso));

                    if (onValue || offValue || includeDayStatus) {
                        const entry = {};
                        if (onValue) {
                            entry.onTime = onValue;
                        }
                        if (offValue) {
                            entry.offTime = offValue;
                        }
                        if (includeDayStatus) {
                            entry.dayStatus = dayStatus;
                        }
                        record[iso] = entry;
                    }
                });

                const { memberId, memberKey } = attendanceModalContext;
                let responseData = null;

                if (memberId != null) {
                    try {
                        const response = await fetch(`/api/team/attendance/${memberId}`, {
                            method: "PUT",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({ month: normalizedMonth, entries: record }),
                        });

                        if (response.status === 401) {
                            logoutButton.click();
                            return;
                        }

                        responseData = await response.json().catch(() => ({}));

                        if (!response.ok) {
                            const message = responseData?.msg || "Unable to save attendance.";
                            window.alert(message);
                            return;
                        }
                    } catch (error) {
                        console.error("Failed to save attendance", error);
                        window.alert("Unable to save attendance. Please try again.");
                        return;
                    }
                }

                if (Object.keys(record).length > 0) {
                    const payload =
                        responseData?.entries && typeof responseData.entries === "object"
                            ? responseData.entries
                            : record;
                    setAttendanceRecord(normalizedMonth, memberKey, payload);
                } else {
                    removeAttendanceRecord(normalizedMonth, memberKey);
                }

                if (
                    responseData &&
                    Object.prototype.hasOwnProperty.call(responseData, "leaveSummary")
                ) {
                    setAttendanceLeaveSummaryRecord(
                        normalizedMonth,
                        memberKey,
                        responseData.leaveSummary,
                    );
                }

                try {
                    await updateComputedAttendanceAllowances(normalizedMonth);
                } catch (error) {
                    console.error(
                        "Failed to update attendance allowance after attendance save",
                        error,
                    );
                }

                renderSalarySheet();

                if (
                    salaryModalContext?.memberKey &&
                    normalizeMonthValue(salaryFormMonth?.value || currentSalaryMonth) ===
                        normalizedMonth
                ) {
                    populateSalaryFormFields(
                        getSalaryRecord(normalizedMonth, salaryModalContext.memberKey),
                        {
                            memberKey: salaryModalContext.memberKey,
                            month: normalizedMonth,
                            member: salaryModalContext.member,
                        },
                    );
                }

                closeAttendanceModal();
            });
        }

        if (bankDetailForm) {
            bankDetailForm.addEventListener("submit", async (event) => {
                event.preventDefault();

                if (!bankDetailModalState) {
                    closeBankDetailModal();
                    return;
                }

                resetBankDetailFeedback();

                const values = getBankDetailFormValues();
                const contextType = bankDetailModalState.context?.type;

                if (contextType === "form") {
                    setHiddenBankDetailValues(values);
                    closeBankDetailModal();
                    return;
                }

                const memberId = bankDetailModalState.context?.memberId;
                if (memberId == null) {
                    showBankDetailError(
                        "Unable to determine which member to update. Please close and try again."
                    );
                    return;
                }

                setBankDetailLoading(true);

                try {
                    const response = await fetch(
                        `/api/team/members/${memberId}/personal-detail`,
                        {
                            method: "PATCH",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify(values),
                        }
                    );

                    if (response.status === 401) {
                        logoutButton.click();
                        return;
                    }

                    if (!response.ok) {
                        const errorBody = await response.json().catch(() => null);
                        const message =
                            errorBody?.msg || `Request failed with status ${response.status}`;
                        throw new Error(message);
                    }

                    const payload = await response.json();
                    const savedValues = getBankDetailValues(payload);
                    bankDetailModalState = {
                        ...bankDetailModalState,
                        values: savedValues,
                        editing: false,
                        loading: false,
                    };
                    setBankDetailFormValues(savedValues);
                    setBankDetailFieldsDisabled(true);
                    updateBankDetailControls();
                    const displayName = bankDetailModalState.context?.displayName;
                    if (displayName) {
                        setBankDetailHint(`Viewing personal detail for ${displayName}.`);
                    }
                    showBankDetailSuccess("Personal detail saved.");
                    await loadTeamMembers();
                } catch (error) {
                    console.error("Failed to update personal detail", error);
                    showBankDetailError(
                        error?.message || "Unable to save personal detail."
                    );
                } finally {
                    setBankDetailLoading(false);
                }
            });
        }

        if (salaryFormMonth) {
            salaryFormMonth.addEventListener("change", (event) => {
                const normalized = normalizeMonthValue(event.target.value);
                if (!normalized) {
                    event.target.value = currentSalaryMonth;
                    return;
                }

                const memberKey = salaryModalContext?.memberKey;
                if (!memberKey) {
                    return;
                }

                populateSalaryFormFields(getSalaryRecord(normalized, memberKey), {
                    memberKey,
                    month: normalized,
                    member: salaryModalContext?.member,
                });
            });
        }

        if (salaryForm) {
            salaryForm.addEventListener("submit", async (event) => {
                event.preventDefault();

                if (!canManageSalary) {
                    closeSalaryModal();
                    return;
                }

                if (!salaryModalContext?.memberKey) {
                    closeSalaryModal();
                    return;
                }

                refreshSalaryFormTotals();

                const formData = new FormData(salaryForm);
                const monthRaw = formData.get("salaryMonth");
                const normalizedMonth = normalizeMonthValue(monthRaw) || currentSalaryMonth;
                const record = {};

                salaryFieldDefinitions.forEach(({ name }) => {
                    const rawValue = formData.get(name);
                    if (typeof rawValue === "string") {
                        const trimmed = rawValue.trim();
                        if (trimmed) {
                            record[name] = trimmed;
                        }
                    }
                });

                const computedTotalDeduction =
                    computeTotalDeductionAmountFromComponents(record);
                record.totalDeduction = formatNumberForInput(computedTotalDeduction);

                const computedNetPay = computeNetPayAmountFromComponents(
                    record,
                    computedTotalDeduction,
                );
                if (Number.isFinite(computedNetPay)) {
                    record.netPay = formatNumberForInput(computedNetPay);
                }

                const casualOtRateField = salaryForm.elements?.casualOtRate;
                if (casualOtRateField && typeof casualOtRateField.value === "string") {
                    const trimmedRate = casualOtRateField.value.trim();
                    if (trimmedRate) {
                        record.casualOtRate = trimmedRate;
                        setCasualOtRate(normalizedMonth, salaryModalContext.memberKey, trimmedRate);
                    } else {
                        delete record.casualOtRate;
                        removeCasualOtRate(normalizedMonth, salaryModalContext.memberKey);
                    }
                }

                if (!isFactoryPayCategory(salaryModalContext?.member)) {
                    delete record.attendanceAllowance;
                }

                delete record.overtime;

                const { memberId, memberKey } = salaryModalContext;
                let responseData = null;

                if (memberId != null) {
                    try {
                        const response = await fetch(`/api/team/salary/${memberId}`, {
                            method: "PUT",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify({ month: normalizedMonth, components: record }),
                        });

                        if (response.status === 401) {
                            logoutButton.click();
                            return;
                        }

                        responseData = await response.json().catch(() => ({}));

                        if (!response.ok) {
                            const message = responseData?.msg || "Unable to save salary details.";
                            window.alert(message);
                            return;
                        }
                    } catch (error) {
                        console.error("Failed to save salary record", error);
                        window.alert("Unable to save salary. Please try again.");
                        return;
                    }
                }

                if (Object.keys(record).length > 0) {
                    const payload =
                        responseData?.components && typeof responseData.components === "object"
                            ? responseData.components
                            : record;
                    setSalaryRecord(normalizedMonth, memberKey, payload);
                } else {
                    removeSalaryRecord(normalizedMonth, memberKey);
                }

                currentSalaryMonth = normalizedMonth;
                if (salaryMonthSelector) {
                    salaryMonthSelector.value = currentSalaryMonth;
                }

                closeSalaryModal();

                try {
                    await refreshMonthData(currentSalaryMonth);
                } catch (error) {
                    console.error("Failed to refresh monthly data after salary update", error);
                    renderSalarySheet();
                }
            });
        }

        const isEditingMember = () => editingMemberId != null;

        const setSelectValue = (select, value) => {
            if (!select) {
                return;
            }

            const options = Array.from(select.options || []);
            const normalized =
                typeof value === "string"
                    ? value
                    : value != null
                    ? String(value)
                    : "";

            const match = options.find((option) => option.value === normalized);

            if (match) {
                select.value = match.value;
            } else if (options.length > 0) {
                select.value = options[0].value;
            } else {
                select.value = "";
            }
        };

        const setFieldValue = (field, value) => {
            if (!field) {
                return;
            }

            if (typeof value === "string") {
                field.value = value;
                return;
            }

            if (value == null) {
                field.value = "";
                return;
            }

            field.value = String(value);
        };

        const exitEditMode = () => {
            editingMemberId = null;

            if (teamForm?.dataset) {
                delete teamForm.dataset.mode;
                delete teamForm.dataset.memberId;
            }

            if (teamForm) {
                teamForm.reset();
            }

            setHiddenBankDetailValues({});

            if (regNumberInput) {
                regNumberInput.disabled = false;
            }

            if (teamFormSubmitButton) {
                teamFormSubmitButton.textContent = "Save member";
            }

            if (teamFormEditingBanner) {
                teamFormEditingBanner.hidden = true;
            }

            if (teamFormEditingName) {
                teamFormEditingName.textContent = "";
            }

            if (teamFormCancelEditFooter) {
                teamFormCancelEditFooter.hidden = true;
                teamFormCancelEditFooter.disabled = false;
            }

            if (teamFormCancelEditBanner) {
                teamFormCancelEditBanner.disabled = false;
            }

            window.requestAnimationFrame(() => {
                if (teamForm) {
                    const firstField = teamForm.querySelector(
                        "input:not([type='hidden']):not([disabled]), textarea, select"
                    );
                    firstField?.focus();
                }
            });
        };

        const enterEditMode = (member) => {
            if (!teamForm || !canManageMembers) {
                return;
            }

            const memberId = parseMemberId(member?.id);

            if (memberId == null) {
                return;
            }

            editingMemberId = memberId;

            if (teamForm.dataset) {
                teamForm.dataset.mode = "edit";
                teamForm.dataset.memberId = String(memberId);
            }

            resetFormFeedback();

            const displayName = getMemberDisplayName(member);

            setFieldValue(regNumberInput, member?.regNumber);

            if (regNumberInput) {
                regNumberInput.disabled = true;
            }

            setFieldValue(nameInput, member?.name);
            setFieldValue(nicknameInput, member?.nickname);
            setFieldValue(epfInput, member?.epf);
            setFieldValue(positionInput, member?.position);
            setSelectValue(payCategorySelect, member?.payCategory);

            const normalizedJoinDate = toYyyyMmDd(member?.joinDate);
            if (joinDateInput) {
                joinDateInput.value = normalizedJoinDate ?? "";
            }

            setSelectValue(statusSelect, normalizeStatus(member?.status));
            const imageValue = member?.image ?? member?.imageUrl ?? member?.image_url;
            setFieldValue(imageInput, imageValue);
            setHiddenBankDetailValues(getMemberBankDetails(member));
            setFieldValue(personalDetailInput, member?.personalDetail);
            setFieldValue(assignmentsInput, member?.assignments);
            setFieldValue(trainingInput, member?.trainingRecords);
            setFieldValue(employmentLogInput, member?.employmentLog);
            setFieldValue(filesInput, member?.files);
            setFieldValue(assetsInput, member?.assets);

            if (teamFormSubmitButton) {
                teamFormSubmitButton.textContent = "Update member";
            }

            if (teamFormEditingBanner) {
                teamFormEditingBanner.hidden = false;
            }

            if (teamFormEditingName) {
                teamFormEditingName.textContent = displayName;
            }

            if (teamFormCancelEditFooter) {
                teamFormCancelEditFooter.hidden = false;
                teamFormCancelEditFooter.disabled = false;
            }

            if (teamFormCancelEditBanner) {
                teamFormCancelEditBanner.disabled = false;
            }

            if (teamForm) {
                teamForm.scrollIntoView({ behavior: "smooth", block: "start" });
            }

            window.requestAnimationFrame(() => {
                if (nameInput && !nameInput.disabled) {
                    nameInput.focus();
                }
            });
        };

        const cancelEditing = () => {
            if (!isEditingMember()) {
                return;
            }

            exitEditMode();
            resetFormFeedback();
        };

        if (teamFormCancelEditBanner) {
            teamFormCancelEditBanner.addEventListener("click", cancelEditing);
        }

        if (teamFormCancelEditFooter) {
            teamFormCancelEditFooter.addEventListener("click", cancelEditing);
        }

        if (bankDetailButton && canManageMembers) {
            bankDetailButton.addEventListener("click", () => {
                openBankDetailModalForForm();
            });
        }

        const renderMembers = (members) => {
            if (!tableBody) {
                return;
            }

            tableBody.innerHTML = "";

            if (!Array.isArray(members) || members.length === 0) {
                renderEmptyState();
                return;
            }

            hideEmptyState();

            members.forEach((member) => {
                const row = document.createElement("tr");

                const avatarElement = createAvatarElement(member);
                const personalDetailCell = createPersonalDetailCell(member);

                const cells = [
                    ["ID", sanitizeText(member?.id)],
                    ["Reg No", sanitizeText(member?.regNumber)],
                    ["Image", avatarElement],
                    ["Name", sanitizeText(member?.name)],
                    ["Nickname", sanitizeText(member?.nickname)],
                    ["EPF", sanitizeText(member?.epf)],
                    ["Position", sanitizeText(member?.position)],
                    ["Pay category", sanitizeText(member?.payCategory)],
                    ["Join date", formatJoinDate(member?.joinDate)],
                    ["Status", sanitizeText(member?.status)],
                    ["Created at", formatDateTime(member?.createdAt)],
                    ["Updated at", formatDateTime(member?.updatedAt)],
                    ["Personal detail", personalDetailCell],
                    ["Assignments", sanitizeText(member?.assignments)],
                    ["Training records", sanitizeText(member?.trainingRecords)],
                    ["Employment log", sanitizeText(member?.employmentLog)],
                    ["Files", sanitizeText(member?.files)],
                    ["Assets", sanitizeText(member?.assets)],
                ];

                cells.forEach(([label, value]) => {
                    const cell = createCell(label, value);

                    if (label === "Image") {
                        cell.classList.add("team-table__cell--avatar");
                    }

                    row.appendChild(cell);
                });

                if (canManageMembers) {
                    const actionCell = document.createElement("td");
                    actionCell.classList.add("team-table__cell--actions");
                    actionCell.setAttribute("data-label", "Update");

                    const updateButton = document.createElement("button");
                    updateButton.type = "button";
                    updateButton.className =
                        "button button--secondary button--small team-table__update-button";
                    updateButton.textContent = "Update";
                    updateButton.setAttribute(
                        "aria-label",
                        `Update ${getMemberDisplayName(member)}`
                    );
                    updateButton.addEventListener("click", () => {
                        enterEditMode(member);
                    });

                    actionCell.appendChild(updateButton);
                    row.appendChild(actionCell);
                }

                tableBody.appendChild(row);
            });
        };

        const loadTeamMembers = async () => {
            if (!tableBody) {
                return;
            }

            try {
                const response = await fetch("/api/team/members", {
                    headers: authHeaders,
                });

                if (response.status === 401) {
                    logoutButton.click();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }

                const data = await response.json();
                renderMembers(data);
                setActiveMembers(data);
                await refreshMonthData(currentSalaryMonth);
            } catch (error) {
                console.error("Failed to load team members", error);
                if (tableBody) {
                    tableBody.innerHTML = "";
                }
                renderEmptyState("Unable to load team members.");
                setActiveMembers([]);
            }
        };

        const resetFormFeedback = () => {
            if (teamFormError) {
                teamFormError.hidden = true;
                teamFormError.textContent = "";
            }
            if (teamFormSuccess) {
                teamFormSuccess.hidden = true;
                teamFormSuccess.textContent = "";
            }
        };

        const showFormError = (message) => {
            if (!teamFormError) {
                return;
            }
            teamFormError.textContent = message;
            teamFormError.hidden = false;
            if (teamFormSuccess) {
                teamFormSuccess.hidden = true;
                teamFormSuccess.textContent = "";
            }
        };

        const showFormSuccess = (message) => {
            if (!teamFormSuccess) {
                return;
            }
            teamFormSuccess.textContent = message;
            teamFormSuccess.hidden = false;
            if (teamFormError) {
                teamFormError.hidden = true;
                teamFormError.textContent = "";
            }
        };

        const setFormDisabled = (disabled) => {
            if (!teamForm) {
                return;
            }
            Array.from(teamForm.elements || []).forEach((element) => {
                element.disabled = disabled;
            });

            if (teamFormCancelEditBanner) {
                teamFormCancelEditBanner.disabled = disabled;
            }
        };

        if (teamForm && canManageMembers) {
            teamForm.addEventListener("submit", async (event) => {
                event.preventDefault();

                if (!teamForm.checkValidity()) {
                    teamForm.reportValidity();
                    return;
                }

                resetFormFeedback();

                const formData = new FormData(teamForm);
                const payload = {};

                const editing = isEditingMember();
                const memberId = editingMemberId;

                if (editing && memberId == null) {
                    showFormError(
                        "Unable to determine which member to update. Please refresh and try again."
                    );
                    return;
                }

                if (!editing) {
                    const regRaw = formData.get("regNumber");
                    const regNumber = typeof regRaw === "string" ? regRaw.trim() : "";
                    if (!regNumber) {
                        showFormError("Registration number and name are required.");
                        return;
                    }
                    payload.regNumber = regNumber;
                }

                const nameRaw = formData.get("name");
                const nameValue = typeof nameRaw === "string" ? nameRaw.trim() : "";
                if (!nameValue) {
                    showFormError("Registration number and name are required.");
                    return;
                }
                payload.name = nameValue;

                const joinDateRaw = formData.get("joinDate");
                const normalizedDate = toYyyyMmDd(joinDateRaw);

                if (joinDateRaw && !normalizedDate) {
                    showFormError("Invalid date for join date. Please use YYYY-MM-DD.");
                    return;
                }

                if (normalizedDate) {
                    payload.joinDate = normalizedDate;
                }

                const statusRaw = formData.get("status");
                if (typeof statusRaw === "string" && statusRaw.trim()) {
                    payload.status = normalizeStatus(statusRaw);
                }

                const optionalFields = [
                    "nickname",
                    "epf",
                    "position",
                    "payCategory",
                    "image",
                    "bankAccountName",
                    "bankName",
                    "branchName",
                    "bankAccountNumber",
                    "personalDetail",
                    "assignments",
                    "trainingRecords",
                    "employmentLog",
                    "files",
                    "assets",
                ];

                optionalFields.forEach((field) => {
                    const rawValue = formData.get(field);
                    if (typeof rawValue !== "string") {
                        return;
                    }
                    const trimmed = rawValue.trim();
                    if (trimmed) {
                        payload[field] = trimmed;
                    } else if (editing) {
                        payload[field] = "";
                    }
                });

                setFormDisabled(true);

                try {
                    let response;

                    if (editing) {
                        response = await fetch(`/api/team/members/${memberId}`, {
                            method: "PATCH",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify(payload),
                        });
                    } else {
                        response = await fetch("/api/team/members", {
                            method: "POST",
                            headers: {
                                ...authHeaders,
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify(payload),
                        });
                    }

                    if (response.status === 401) {
                        logoutButton.click();
                        return;
                    }

                    const body = await response.json().catch(() => ({}));

                    if (!response.ok) {
                        const defaultMessage = editing
                            ? "Unable to update team member."
                            : "Unable to register team member.";
                        const message = body?.msg || defaultMessage;
                        showFormError(message);
                        return;
                    }

                    if (editing) {
                        showFormSuccess("Team member updated successfully.");
                        exitEditMode();
                    } else {
                        showFormSuccess("Team member registered successfully.");
                        teamForm.reset();
                    }

                    await loadTeamMembers();
                } catch (error) {
                    const defaultMessage = editing
                        ? "Unable to update team member."
                        : "Unable to register team member.";
                    showFormError(error?.message || defaultMessage);
                } finally {
                    setFormDisabled(false);
                }
            });

            teamForm.addEventListener("input", () => {
                if (teamFormError && !teamFormError.hidden) {
                    teamFormError.hidden = true;
                    teamFormError.textContent = "";
                }
                if (teamFormSuccess && !teamFormSuccess.hidden) {
                    teamFormSuccess.hidden = true;
                    teamFormSuccess.textContent = "";
                }
            });
        }

        if (typeof window.initResponsibilityReport === "function") {
            window.initResponsibilityReport({
                form: responsibilityReportForm,
                startInput: responsibilityReportStart,
                endInput: responsibilityReportEnd,
                memberSelect: responsibilityReportMember,
                summaryElement: responsibilityReportSummary,
                messageElement: responsibilityReportMessage,
                tableBody: responsibilityReportTableBody,
                emptyState: responsibilityReportEmpty,
                chartCanvas: responsibilityReportChart,
                downloadButtons: Array.from(responsibilityReportDownloads || []),
                authHeaders,
            });
        }

        populateLoadingPayFilters();
        loadLoadingPayData();
        loadTeamMembers();
    </script>
</body>
</html>
